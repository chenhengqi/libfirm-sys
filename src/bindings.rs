/* automatically generated by rust-bindgen 0.64.0 */

pub const cc_bits: u32 = 4278190080;
pub const cc_cdecl_set: u32 = 0;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const DEFAULT_CLONE_THRESHOLD: u32 = 20;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " Type for visited counters\n @see visited_counters"]
pub type ir_visited_t = ::std::os::raw::c_ulong;
#[doc = " A label in the code (usually attached to a @ref Block)"]
pub type ir_label_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbg_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_dbg_info {
    _unused: [u8; 0],
}
#[doc = " @ingroup ir_ident\n Identifier\n\n @note This is currently defined as a normal C string, but you should not\n  rely on that and always use get_id_str() before using it as a C string."]
pub type ident = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_op {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_mode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_edge_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_heights_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_tarval {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_graph {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_prog {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_loop {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_entity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_cdep {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ir_initializer_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_machine_triple_t {
    _unused: [u8; 0],
}
#[doc = " @ingroup irgwalk\n type for graph-walk callbacks"]
pub type irg_walk_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ir_node, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_switch_table {
    _unused: [u8; 0],
}
#[doc = " @ingroup ir_cons\n This function is called, whenever a local variable is used before definition\n\n @param irg       the IR graph on which this happens\n @param mode      the mode of the local var\n @param pos       position chosen be the frontend for this variable (n_loc)\n\n @return a firm node of mode @p mode that initializes the var at position pos\n\n @note\n      Do not return NULL!\n      If this function is not set, FIRM will create an Unknown node.\n      Use set_irg_loc_description()/get_irg_loc_description() to assign additional\n      informations to local variables."]
pub type uninitialized_local_variable_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        pos: ::std::os::raw::c_int,
    ) -> *mut ir_node,
>;
#[doc = "< always false"]
pub const ir_relation_ir_relation_false: ir_relation = 0;
#[doc = "< equal"]
pub const ir_relation_ir_relation_equal: ir_relation = 1;
#[doc = "< less"]
pub const ir_relation_ir_relation_less: ir_relation = 2;
#[doc = "< greater"]
pub const ir_relation_ir_relation_greater: ir_relation = 4;
#[doc = "< unordered"]
pub const ir_relation_ir_relation_unordered: ir_relation = 8;
#[doc = "< less or equal"]
pub const ir_relation_ir_relation_less_equal: ir_relation = 3;
#[doc = "< greater or equal"]
pub const ir_relation_ir_relation_greater_equal: ir_relation = 5;
#[doc = "< less or greater ('not equal' for integer numbers)"]
pub const ir_relation_ir_relation_less_greater: ir_relation = 6;
#[doc = "< less equal or greater ('not unordered')"]
pub const ir_relation_ir_relation_less_equal_greater: ir_relation = 7;
#[doc = "< unordered or equal"]
pub const ir_relation_ir_relation_unordered_equal: ir_relation = 9;
#[doc = "< unordered or less"]
pub const ir_relation_ir_relation_unordered_less: ir_relation = 10;
#[doc = "< unordered, less or equal"]
pub const ir_relation_ir_relation_unordered_less_equal: ir_relation = 11;
#[doc = "< unordered or greater"]
pub const ir_relation_ir_relation_unordered_greater: ir_relation = 12;
#[doc = "< unordered, greater or equal"]
pub const ir_relation_ir_relation_unordered_greater_equal: ir_relation = 13;
#[doc = "< unordered, less or greater ('not equal' for floatingpoint numbers)"]
pub const ir_relation_ir_relation_unordered_less_greater: ir_relation = 14;
#[doc = "< always true"]
pub const ir_relation_ir_relation_true: ir_relation = 15;
#[doc = " @ingroup ir_node\n Relations for comparing numbers"]
pub type ir_relation = ::std::os::raw::c_uint;
#[doc = "< No constrains."]
pub const ir_cons_flags_cons_none: ir_cons_flags = 0;
#[doc = "< Memory operation is volatile."]
pub const ir_cons_flags_cons_volatile: ir_cons_flags = 1;
#[doc = "< Memory operation is unaligned."]
pub const ir_cons_flags_cons_unaligned: ir_cons_flags = 2;
#[doc = "< Memory operation can float."]
pub const ir_cons_flags_cons_floats: ir_cons_flags = 4;
#[doc = "< fragile op throws exception (and\nproduces X_regular and X_except\nvalues)"]
pub const ir_cons_flags_cons_throws_exception: ir_cons_flags = 8;
#[doc = " @ingroup ir_node\n constrained flags for memory operations."]
pub type ir_cons_flags = ::std::os::raw::c_uint;
#[doc = "< Nodes of this opcode can be placed in any basic block."]
pub const op_pin_state_op_pin_state_floats: op_pin_state = 0;
#[doc = "< Nodes must remain in this basic block."]
pub const op_pin_state_op_pin_state_pinned: op_pin_state = 1;
#[doc = "< Node must remain in this basic block if it\ncan throw an exception, else can float."]
pub const op_pin_state_op_pin_state_exc_pinned: op_pin_state = 2;
#[doc = " @ingroup ir_node\n pinned states."]
pub type op_pin_state = ::std::os::raw::c_uint;
#[doc = "< No jump prediction. Default."]
pub const cond_jmp_predicate_COND_JMP_PRED_NONE: cond_jmp_predicate = 0;
#[doc = "< The True case is predicted."]
pub const cond_jmp_predicate_COND_JMP_PRED_TRUE: cond_jmp_predicate = 1;
#[doc = "< The False case is predicted."]
pub const cond_jmp_predicate_COND_JMP_PRED_FALSE: cond_jmp_predicate = 2;
#[doc = " @ingroup Cond\n A type to express conditional jump predictions."]
pub type cond_jmp_predicate = ::std::os::raw::c_uint;
#[doc = " No additional properties"]
pub const mtp_additional_properties_mtp_no_property: mtp_additional_properties = 0;
#[doc = " This method does not change any memory known to the rest of the\n program."]
pub const mtp_additional_properties_mtp_property_no_write: mtp_additional_properties = 1;
#[doc = " The behaviour of the method does not depend on any global/external\n state. This mostly means that no waiting/reading of user input\n is performed, no global variables read, or pointers to memory visible\n outside of the function dereferenced. The result of the function\n solely depends on its arguments."]
pub const mtp_additional_properties_mtp_property_pure: mtp_additional_properties = 2;
#[doc = " This method never returns. The method may for example abort or exit the\n program or contain an infinite loop).\n GCC: __attribute__((noreturn))."]
pub const mtp_additional_properties_mtp_property_noreturn: mtp_additional_properties = 4;
#[doc = " The function is guaranteed not to end in an endless and to not abort\n the program."]
pub const mtp_additional_properties_mtp_property_terminates: mtp_additional_properties = 8;
#[doc = " This method cannot throw an exception. GCC: __attribute__((nothrow))."]
pub const mtp_additional_properties_mtp_property_nothrow: mtp_additional_properties = 16;
#[doc = " This method is naked. GCC: __attribute__((naked))."]
pub const mtp_additional_properties_mtp_property_naked: mtp_additional_properties = 32;
#[doc = " This method returns newly allocate memory.\n GCC: __attribute__((malloc))."]
pub const mtp_additional_properties_mtp_property_malloc: mtp_additional_properties = 64;
#[doc = " This method can return more than once (typically setjmp).\n GCC: __attribute__((returns_twice))."]
pub const mtp_additional_properties_mtp_property_returns_twice: mtp_additional_properties = 128;
#[doc = " All method invocations are known and inside the current compilation\n unit, the backend can freely choose the calling convention."]
pub const mtp_additional_properties_mtp_property_private: mtp_additional_properties = 256;
#[doc = " Try to always inline this function, even if it seems nonprofitable"]
pub const mtp_additional_properties_mtp_property_always_inline: mtp_additional_properties = 512;
#[doc = " The function should not be inlined"]
pub const mtp_additional_properties_mtp_property_noinline: mtp_additional_properties = 1024;
#[doc = " The programmer recommends to inline the function"]
pub const mtp_additional_properties_mtp_property_inline_recommended: mtp_additional_properties =
    2048;
#[doc = " Marker used by opt_funccall (really a hack)..."]
pub const mtp_additional_properties_mtp_temporary: mtp_additional_properties = 4096;
#[doc = " marker used for oo analyses needing info whether method is constructor or not"]
pub const mtp_additional_properties_mtp_property_is_constructor: mtp_additional_properties = 8192;
#[doc = " @ingroup method_type\n Additional method type properties:\n Tell about special properties of a method type. Some\n of these may be discovered by analyses."]
pub type mtp_additional_properties = ::std::os::raw::c_uint;
#[doc = " A input/output constraint attribute.\n @ingroup ASM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_asm_constraint {
    #[doc = "< The input position for this constraint."]
    pub in_pos: ::std::os::raw::c_int,
    #[doc = "< The output position for this constraint."]
    pub out_pos: ::std::os::raw::c_int,
    #[doc = "< The constraint for this input/output."]
    pub constraint: *const ::std::os::raw::c_char,
    #[doc = "< The mode of the constraint."]
    pub mode: *mut ir_mode,
}
#[test]
fn bindgen_test_layout_ir_asm_constraint() {
    const UNINIT: ::std::mem::MaybeUninit<ir_asm_constraint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ir_asm_constraint>(),
        24usize,
        concat!("Size of: ", stringify!(ir_asm_constraint))
    );
    assert_eq!(
        ::std::mem::align_of::<ir_asm_constraint>(),
        8usize,
        concat!("Alignment of ", stringify!(ir_asm_constraint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(in_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_pos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(out_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constraint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(constraint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ir_asm_constraint),
            "::",
            stringify!(mode)
        )
    );
}
#[doc = "< GCC __builtin_trap(): insert trap"]
pub const ir_builtin_kind_ir_bk_trap: ir_builtin_kind = 0;
#[doc = "< MS __debugbreak(): insert debug break"]
pub const ir_builtin_kind_ir_bk_debugbreak: ir_builtin_kind = 1;
#[doc = "< GCC __builtin_return_address()"]
pub const ir_builtin_kind_ir_bk_return_address: ir_builtin_kind = 2;
#[doc = "< GCC __builtin_frame_address()"]
pub const ir_builtin_kind_ir_bk_frame_address: ir_builtin_kind = 3;
#[doc = "< GCC __builtin_prefetch()"]
pub const ir_builtin_kind_ir_bk_prefetch: ir_builtin_kind = 4;
#[doc = "< GCC __builtin_ffs(): find first (least)\nsignificant 1 bit"]
pub const ir_builtin_kind_ir_bk_ffs: ir_builtin_kind = 5;
#[doc = "< GCC __builtin_clz(): count leading zero"]
pub const ir_builtin_kind_ir_bk_clz: ir_builtin_kind = 6;
#[doc = "< GCC __builtin_ctz(): count trailing zero"]
pub const ir_builtin_kind_ir_bk_ctz: ir_builtin_kind = 7;
#[doc = "< GCC __builtin_popcount(): population\ncount"]
pub const ir_builtin_kind_ir_bk_popcount: ir_builtin_kind = 8;
#[doc = "< GCC __builtin_parity(): parity"]
pub const ir_builtin_kind_ir_bk_parity: ir_builtin_kind = 9;
#[doc = "< byte swap"]
pub const ir_builtin_kind_ir_bk_bswap: ir_builtin_kind = 10;
#[doc = "< in port"]
pub const ir_builtin_kind_ir_bk_inport: ir_builtin_kind = 11;
#[doc = "< out port"]
pub const ir_builtin_kind_ir_bk_outport: ir_builtin_kind = 12;
#[doc = "< saturating increment"]
pub const ir_builtin_kind_ir_bk_saturating_increment: ir_builtin_kind = 13;
#[doc = "< compare exchange (aka. compare and swap)"]
pub const ir_builtin_kind_ir_bk_compare_swap: ir_builtin_kind = 14;
#[doc = "< replaced by 0 if args cannot alias,\n1 otherwise"]
pub const ir_builtin_kind_ir_bk_may_alias: ir_builtin_kind = 15;
#[doc = "< va_start from <stdarg.h>"]
pub const ir_builtin_kind_ir_bk_va_start: ir_builtin_kind = 16;
#[doc = "< va_arg from <stdarg.h>"]
pub const ir_builtin_kind_ir_bk_va_arg: ir_builtin_kind = 17;
pub const ir_builtin_kind_ir_bk_last: ir_builtin_kind = 17;
#[doc = " Supported libFirm builtins.\n @ingroup Builtin"]
pub type ir_builtin_kind = ::std::os::raw::c_uint;
#[doc = "< The entity is not volatile. Default."]
pub const ir_volatility_volatility_non_volatile: ir_volatility = 0;
#[doc = "< The entity is volatile."]
pub const ir_volatility_volatility_is_volatile: ir_volatility = 1;
#[doc = " This enumeration flags the volatility of entities and Loads/Stores."]
pub type ir_volatility = ::std::os::raw::c_uint;
#[doc = "< The entity is aligned. Default"]
pub const ir_align_align_is_aligned: ir_align = 0;
#[doc = "< The entity is not aligned."]
pub const ir_align_align_non_aligned: ir_align = 1;
#[doc = " This enumeration flags the align of Loads/Stores."]
pub type ir_align = ::std::os::raw::c_uint;
#[doc = "< the integer indefinite value (=INT_MIN) is\nreturned. (e.g. x86 does this)"]
pub const float_int_conversion_overflow_style_t_ir_overflow_indefinite:
    float_int_conversion_overflow_style_t = 0;
#[doc = "< INT_MIN/INT_MAX is returned depending on the\nsign of the floatingpoint number. (e.g. sparc\ndoes this)."]
pub const float_int_conversion_overflow_style_t_ir_overflow_min_max:
    float_int_conversion_overflow_style_t = 1;
#[doc = " Specifies what happens when a float value is converted to an integer and\n overflow happens."]
pub type float_int_conversion_overflow_style_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_entry {
    _unused: [u8; 0],
}
pub type hook_entry_t = hook_entry;
#[doc = " The entity is visible across compilation units. It might have an\n initializer/graph.\n Note that entities with visibility_external without initializer are\n assumed to be defined in another compilation unit (not like C variables\n which are considered 'uninitialized' in this case)."]
pub const ir_visibility_ir_visibility_external: ir_visibility = 0;
#[doc = " The entity is visible across compilation units, but not across modules.\n This is equivalent to __attribute__((visibility(\"hidden\"))) in gcc."]
pub const ir_visibility_ir_visibility_external_private: ir_visibility = 1;
#[doc = " The entity is visible across compilation units and modules and cannot be\n overridden by other modules.\n Equivalent to __attribute__((visible(\"protected\"))) in gcc."]
pub const ir_visibility_ir_visibility_external_protected: ir_visibility = 2;
#[doc = " The entity is local to the compilation unit.\n A local entity is not visible in other compilation units.\n Note that the entity might still be accessed indirectly from other units\n through pointers."]
pub const ir_visibility_ir_visibility_local: ir_visibility = 3;
#[doc = " This has the same semantic as visibility_local. Additionally the symbol\n is completely hidden from the linker (it only appears in the assembly).\n While visibility_local is probably still visible to debuggers,\n visibility_private symbols aren't and probably won't appear in the object\n files"]
pub const ir_visibility_ir_visibility_private: ir_visibility = 4;
#[doc = " Visibility classes for entities."]
pub type ir_visibility = ::std::os::raw::c_uint;
pub const ir_linkage_IR_LINKAGE_DEFAULT: ir_linkage = 0;
#[doc = " A symbol whose definition won't change in a program.\n Optimization might replace loads from this entity with constants.\n Also most linkers put such data in a constant segment which is shared\n between multiple running instances of the same application."]
pub const ir_linkage_IR_LINKAGE_CONSTANT: ir_linkage = 1;
#[doc = " The entity is a weak symbol.\n A weak symbol is overridden by a non-weak symbol if one exists.\n Most linkers only support the IR_LINKAGE_WEAK in combination with\n IR_LINKAGE_MERGE."]
pub const ir_linkage_IR_LINKAGE_WEAK: ir_linkage = 2;
#[doc = " The entity may be removed when it isn't referenced anywhere in the\n compilation unit even if it is exported (non-local).\n Typically used for C++ instantiated template code (,,COMDAT'' section)."]
pub const ir_linkage_IR_LINKAGE_GARBAGE_COLLECT: ir_linkage = 4;
#[doc = " The linker will try to merge entities with same name from different\n compilation units. This is the usual behaviour for global variables\n without explicit initialisation in C (``COMMON'' symbols). It's also\n typically used in C++ for instantiated template code (,,COMDAT'' section)"]
pub const ir_linkage_IR_LINKAGE_MERGE: ir_linkage = 8;
#[doc = " Some entity uses are potentially hidden from the compiler.\n (For example because they happen in an asm(\"\") statement. This flag\n  should be set for __attribute__((used)) in C code).\n Setting this flag prohibits that the compiler making assumptions about\n read/write behaviour to global variables or changing calling conventions\n from cdecl to fastcall."]
pub const ir_linkage_IR_LINKAGE_HIDDEN_USER: ir_linkage = 16;
#[doc = " Do not generate code even if the entity has a graph or\n initialization data attached.  The graph/data is only used for\n inlining.  Otherwise the entity is regarded as a declaration of\n an externally defined entity.\n This linkage flag can be used to implement C99 \"inline\" or GNU89\n \"extern inline\"."]
pub const ir_linkage_IR_LINKAGE_NO_CODEGEN: ir_linkage = 32;
#[doc = " The entity does not need to have an address that is different from other\n entities. When this property is set the entity may be safely merged with\n entities with the same content."]
pub const ir_linkage_IR_LINKAGE_NO_IDENTITY: ir_linkage = 64;
#[doc = " linkage specifies how the linker treats symbols"]
pub type ir_linkage = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the visibility class of an entity"]
    pub fn get_entity_visibility(entity: *const ir_entity) -> ir_visibility;
}
extern "C" {
    #[doc = " Sets visibility class of an entity"]
    pub fn set_entity_visibility(entity: *mut ir_entity, visibility: ir_visibility);
}
extern "C" {
    #[doc = " Returns 1 if the entity is visible outside the current compilation unit\n or to unknown callers (like asm statements).\n If invisible, the entity might still be accessible indirectly through pointers.\n This is a convenience function and does the same as\n get_entity_visibility(entity) != ir_visibility_local ||\n (get_entity_linkage(entity) & IR_LINKAGE_HIDDEN_USER)"]
    pub fn entity_is_externally_visible(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if the entity has a definition (initializer) in the current\n compilation unit. Note that this function returns false if\n IR_LINKAGE_NO_CODEGEN is set even if a graph is present."]
    pub fn entity_has_definition(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new entity.\n\n Automatically inserts the entity as a member of owner.\n Entity is automatic_allocated and uninitialized except if the type\n is type_method, then it is static_allocated and constant.\n Visibility is external, offset -1, and it is not volatile."]
    pub fn new_entity(
        owner: *mut ir_type,
        name: *const ::std::os::raw::c_char,
        tp: *mut ir_type,
    ) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Creates a new global entity."]
    pub fn new_global_entity(
        segment: *mut ir_type,
        ld_name: *const ::std::os::raw::c_char,
        type_: *mut ir_type,
        visibility: ir_visibility,
        linkage: ir_linkage,
    ) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Creates a new entity corresponding to a function parameter.\n The owner must be an ir_graph's frame_type.\n @sa get_irg_frame_type()"]
    pub fn new_parameter_entity(
        owner: *mut ir_type,
        pos: usize,
        type_: *mut ir_type,
    ) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Creates a new entity aliasing another entity.\n An aliasing entity is a logically separate entity with its own name,\n but instead of having a definition the linker will merge the name with\n the definition of the aliased entity.\n In gcc this feature is known as __attribute__((alias())).\n\n @param owner  owning type (must be a global segment)\n @param name   name of the entity\n @param alias  entity that is aliased\n @param type   type of the aliasing entity, should but need not be the same\n               type as the one of the aliased entity\n @param visibility  visibility of the entity\n @return       the newly created entity"]
    pub fn new_alias_entity(
        owner: *mut ir_type,
        name: *const ::std::os::raw::c_char,
        alias: *mut ir_entity,
        type_: *mut ir_type,
        visibility: ir_visibility,
    ) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets the aliased entity of an alias entity."]
    pub fn set_entity_alias(alias: *mut ir_entity, aliased: *mut ir_entity);
}
extern "C" {
    #[doc = " Returns the entity aliased by an alias entity."]
    pub fn get_entity_alias(alias: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Check an entity.\n\n @return non-zero if no errors were found"]
    pub fn check_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new entity with attributes copied from an existing entity.\n\n Does not copy the overwrites, overwritten_by, visited and usage fields, sets\n a new name and inserts the entity into @p owner."]
    pub fn clone_entity(
        old: *const ir_entity,
        name: *const ::std::os::raw::c_char,
        owner: *mut ir_type,
    ) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Frees the entity.\n\n The owner will still contain the pointer to this\n entity, as well as all other references!"]
    pub fn free_entity(ent: *mut ir_entity);
}
extern "C" {
    #[doc = " Returns the name of an entity."]
    pub fn get_entity_name(ent: *const ir_entity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the ident of an entity."]
    pub fn get_entity_ident(ent: *const ir_entity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the ident of the entity."]
    pub fn set_entity_ident(ent: *mut ir_entity, id: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns the mangled name of the entity.\n\n If the mangled name is set it returns the existing name.\n Else it generates a name with mangle_entity()\n and remembers this new name internally."]
    pub fn get_entity_ld_ident(ent: *const ir_entity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the mangled name of the entity."]
    pub fn set_entity_ld_ident(ent: *mut ir_entity, ld_ident: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns the mangled name of the entity as a string."]
    pub fn get_entity_ld_name(ent: *const ir_entity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns 1 if the entity has an ld_ident set explicitely"]
    pub fn entity_has_ld_ident(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the owner of the entity."]
    pub fn get_entity_owner(ent: *const ir_entity) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets the owner field in entity to owner.\n Automatically removes entity from old owner type and adds it to the new\n one."]
    pub fn set_entity_owner(ent: *mut ir_entity, owner: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the type of an entity."]
    pub fn get_entity_type(ent: *const ir_entity) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets the type of an entity."]
    pub fn set_entity_type(ent: *mut ir_entity, tp: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the linkage of an entity."]
    pub fn get_entity_linkage(entity: *const ir_entity) -> ir_linkage;
}
extern "C" {
    #[doc = " Sets the linkage flags of entity @p entity to @p linkage."]
    pub fn set_entity_linkage(entity: *mut ir_entity, linkage: ir_linkage);
}
extern "C" {
    #[doc = " Adds linkage flags @p linkage to entity @p entity."]
    pub fn add_entity_linkage(entity: *mut ir_entity, linkage: ir_linkage);
}
extern "C" {
    #[doc = " Remove linkage flags @p linkage from entity @p entity."]
    pub fn remove_entity_linkage(entity: *mut ir_entity, linkage: ir_linkage);
}
extern "C" {
    #[doc = " Returns the volatility of an entity.\n @deprecated"]
    pub fn get_entity_volatility(ent: *const ir_entity) -> ir_volatility;
}
extern "C" {
    #[doc = " Sets the volatility of an entity.\n @deprecated"]
    pub fn set_entity_volatility(ent: *mut ir_entity, vol: ir_volatility);
}
extern "C" {
    #[doc = " Returns the name of the volatility."]
    pub fn get_volatility_name(var: ir_volatility) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns alignment of entity in bytes"]
    pub fn get_entity_alignment(entity: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Allows you to override the type alignment for an entity.\n @param entity      the entity\n @param alignment   alignment in bytes"]
    pub fn set_entity_alignment(entity: *mut ir_entity, alignment: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Returns indication whether entity is aligned in memory.\n @deprecated"]
    pub fn get_entity_aligned(ent: *const ir_entity) -> ir_align;
}
extern "C" {
    #[doc = " Sets indication whether entity is aligned in memory\n @deprecated"]
    pub fn set_entity_aligned(ent: *mut ir_entity, a: ir_align);
}
extern "C" {
    #[doc = " Returns the name of the alignment."]
    pub fn get_align_name(a: ir_align) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the offset of an entity (in a compound) in bytes. Only set if\n the layout of the entity's owner has been fixed.\n @sa get_type_state()"]
    pub fn get_entity_offset(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the offset of an entity (in a compound) in bytes."]
    pub fn set_entity_offset(entity: *mut ir_entity, offset: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " For bitfields, returns the offset in bits to the bitfield base."]
    pub fn get_entity_bitfield_offset(entity: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the offset in bits to the base for a bitfield."]
    pub fn set_entity_bitfield_offset(entity: *mut ir_entity, offset: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Sets the size in bits for a bitfield. 0 means not a bitfield."]
    pub fn set_entity_bitfield_size(entity: *mut ir_entity, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Returns the size in bits for a bitfield, 0 if entity is not a bitfield."]
    pub fn get_entity_bitfield_size(entity: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the stored intermediate information."]
    pub fn get_entity_link(ent: *const ir_entity) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Stores new intermediate information."]
    pub fn set_entity_link(ent: *mut ir_entity, l: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Return the method graph of a method entity.\n @warning If the entity has IR_LINKAGE_WEAK, then this is not necessarily the final code\n          bound to the entity. If you are writing an analysis use\n          get_entity_linktime_irg()!"]
    pub fn get_entity_irg(ent: *const ir_entity) -> *mut ir_graph;
}
extern "C" {
    #[doc = " Return the method graph the method entity points to after linking.\n This is different to get_entity_irg() in case of weak symbols where this\n function returns NULL because the code may be replaced by a non-weak symbol\n after linking."]
    pub fn get_entity_linktime_irg(ent: *const ir_entity) -> *mut ir_graph;
}
extern "C" {
    #[doc = " Returns the entity vtable number."]
    pub fn get_entity_vtable_number(ent: *const ir_entity) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the entity vtable number."]
    pub fn set_entity_vtable_number(ent: *mut ir_entity, vtable_number: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Sets label number of an entity with code type"]
    pub fn set_entity_label(ent: *mut ir_entity, label: ir_label_t);
}
extern "C" {
    #[doc = " Returns label number of an entity with code type"]
    pub fn get_entity_label(ent: *const ir_entity) -> ir_label_t;
}
#[doc = "< This entity is unused."]
pub const ir_entity_usage_ir_usage_none: ir_entity_usage = 0;
#[doc = "< The address of this entity was taken."]
pub const ir_entity_usage_ir_usage_address_taken: ir_entity_usage = 1;
#[doc = "< The entity was written to."]
pub const ir_entity_usage_ir_usage_write: ir_entity_usage = 2;
#[doc = "< The entity was read."]
pub const ir_entity_usage_ir_usage_read: ir_entity_usage = 4;
#[doc = "< The entity was read but with a wrong mode\n(an implicit reinterpret cast)"]
pub const ir_entity_usage_ir_usage_reinterpret_cast: ir_entity_usage = 8;
#[doc = " Unknown access"]
pub const ir_entity_usage_ir_usage_unknown: ir_entity_usage = 15;
#[doc = " Bitfield type indicating the way an entity is used."]
pub type ir_entity_usage = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the entity usage"]
    pub fn get_entity_usage(ent: *const ir_entity) -> ir_entity_usage;
}
extern "C" {
    #[doc = " Sets/resets the state of the address taken flag of an entity."]
    pub fn set_entity_usage(ent: *mut ir_entity, flag: ir_entity_usage);
}
extern "C" {
    #[doc = " Returns the debug information of an entity.\n\n @param ent The entity."]
    pub fn get_entity_dbg_info(ent: *const ir_entity) -> *mut dbg_info;
}
extern "C" {
    #[doc = " Sets the debug information of an entity.\n\n @param ent The entity.\n @param db  The debug info."]
    pub fn set_entity_dbg_info(ent: *mut ir_entity, db: *mut dbg_info);
}
extern "C" {
    #[doc = " returns true if a given entity is a parameter_entity representing the\n address of a function parameter"]
    pub fn is_parameter_entity(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the parameter number of the parameter which @p entity represents."]
    pub fn get_entity_parameter_number(entity: *const ir_entity) -> usize;
}
extern "C" {
    #[doc = " Sets the parameter number of the parameter which @p entity represents."]
    pub fn set_entity_parameter_number(entity: *mut ir_entity, n: usize);
}
#[doc = " initializer containing an ir_node from the const-code irg"]
pub const ir_initializer_kind_t_IR_INITIALIZER_CONST: ir_initializer_kind_t = 0;
#[doc = " initializer containing a tarval"]
pub const ir_initializer_kind_t_IR_INITIALIZER_TARVAL: ir_initializer_kind_t = 1;
#[doc = " initializes type with default values (usually 0)"]
pub const ir_initializer_kind_t_IR_INITIALIZER_NULL: ir_initializer_kind_t = 2;
#[doc = " list of initializers used to initialize a compound or array type"]
pub const ir_initializer_kind_t_IR_INITIALIZER_COMPOUND: ir_initializer_kind_t = 3;
#[doc = " the kind (type) of an initializer"]
pub type ir_initializer_kind_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the kind of an initializer"]
    pub fn get_initializer_kind(initializer: *const ir_initializer_t) -> ir_initializer_kind_t;
}
extern "C" {
    #[doc = " Returns the name of the initializer kind."]
    pub fn get_initializer_kind_name(ini: ir_initializer_kind_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the null initializer (there is only one instance of it in a program )"]
    pub fn get_initializer_null() -> *mut ir_initializer_t;
}
extern "C" {
    #[doc = " Creates an initializer containing a reference to a node on the const-code\n irg."]
    pub fn create_initializer_const(value: *mut ir_node) -> *mut ir_initializer_t;
}
extern "C" {
    #[doc = " Creates an initializer containing a single tarval value"]
    pub fn create_initializer_tarval(tv: *mut ir_tarval) -> *mut ir_initializer_t;
}
extern "C" {
    #[doc = " Returns the value contained in a const initializer"]
    pub fn get_initializer_const_value(initializer: *const ir_initializer_t) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the value contained in a tarval initializer"]
    pub fn get_initializer_tarval_value(initialzier: *const ir_initializer_t) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Creates a compound initializer which holds @p n_entries entries"]
    pub fn create_initializer_compound(n_entries: usize) -> *mut ir_initializer_t;
}
extern "C" {
    #[doc = " Returns the number of entries in a compound initializer"]
    pub fn get_initializer_compound_n_entries(initializer: *const ir_initializer_t) -> usize;
}
extern "C" {
    #[doc = " Sets entry with index @p index to the initializer @p value"]
    pub fn set_initializer_compound_value(
        initializer: *mut ir_initializer_t,
        index: usize,
        value: *mut ir_initializer_t,
    );
}
extern "C" {
    #[doc = " Returns the value with index @p index of a compound initializer"]
    pub fn get_initializer_compound_value(
        initializer: *const ir_initializer_t,
        index: usize,
    ) -> *mut ir_initializer_t;
}
extern "C" {
    #[doc = " Sets the initializer of an entity."]
    pub fn set_entity_initializer(entity: *mut ir_entity, initializer: *mut ir_initializer_t);
}
extern "C" {
    #[doc = " Returns the initializer of an entity."]
    pub fn get_entity_initializer(entity: *const ir_entity) -> *mut ir_initializer_t;
}
extern "C" {
    #[doc = " Adds entity @p ent to the list of entities that overwrite @p overwritten."]
    pub fn add_entity_overwrites(ent: *mut ir_entity, overwritten: *mut ir_entity);
}
extern "C" {
    #[doc = " Returns the number of entities in the list of entities that overwrite\n entity @p ent."]
    pub fn get_entity_n_overwrites(ent: *const ir_entity) -> usize;
}
extern "C" {
    #[doc = " Returns index of @p overwritten in list of entities overwriting entity\n @p ent."]
    pub fn get_entity_overwrites_index(ent: *const ir_entity, overwritten: *mut ir_entity)
        -> usize;
}
extern "C" {
    #[doc = " Returns entry @p pos in list of entities overwriting entity @p ent."]
    pub fn get_entity_overwrites(ent: *const ir_entity, pos: usize) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets entry @p pos in list of entities overwriting entity @p ent."]
    pub fn set_entity_overwrites(ent: *mut ir_entity, pos: usize, overwritten: *mut ir_entity);
}
extern "C" {
    #[doc = " Remove @p overwritten from list of entities overwriting entity @p ent."]
    pub fn remove_entity_overwrites(ent: *mut ir_entity, overwritten: *mut ir_entity);
}
extern "C" {
    #[doc = " Returns number of entities overwritten by @p ent."]
    pub fn get_entity_n_overwrittenby(ent: *const ir_entity) -> usize;
}
extern "C" {
    #[doc = " Returns index of @p overwrites in list of entities overwritten by entity\n @p ent."]
    pub fn get_entity_overwrittenby_index(
        ent: *const ir_entity,
        overwrites: *mut ir_entity,
    ) -> usize;
}
extern "C" {
    #[doc = " Return entry @p pos in list of entities overwritten by entity @p ent."]
    pub fn get_entity_overwrittenby(ent: *const ir_entity, pos: usize) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets entry @p pos in list of entities overwritten by entity @p ent."]
    pub fn set_entity_overwrittenby(ent: *mut ir_entity, pos: usize, overwrites: *mut ir_entity);
}
extern "C" {
    #[doc = " Removes entry @p overwrites in list of entities overwritten by @p ent."]
    pub fn remove_entity_overwrittenby(ent: *mut ir_entity, overwrites: *mut ir_entity);
}
extern "C" {
    #[doc = " Returns true if the type of the entity is a class, structure,\narray or union type."]
    pub fn is_compound_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the entity is a method entity."]
    pub fn is_method_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the entity is an alias entity."]
    pub fn is_alias_entity(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Outputs a unique number for this entity."]
    pub fn get_entity_nr(ent: *const ir_entity) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Returns the entities visited counter.\n @see @ref visited_counters"]
    pub fn get_entity_visited(ent: *const ir_entity) -> ir_visited_t;
}
extern "C" {
    #[doc = " Sets the entities visited counter.\n @see @ref visited_counters"]
    pub fn set_entity_visited(ent: *mut ir_entity, num: ir_visited_t);
}
extern "C" {
    #[doc = " Marks entity as visited.\n @see @ref visited_counters"]
    pub fn mark_entity_visited(ent: *mut ir_entity);
}
extern "C" {
    #[doc = " Returns true if this entity was visited.\n @see @ref visited_counters"]
    pub fn entity_visited(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if this entity was not visited.\n @see @ref visited_counters"]
    pub fn entity_not_visited(ent: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return true if this entity can be queried for additional properties.\n\n This is possible for method and alias entities."]
    pub fn entity_has_additional_properties(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the mask of the additional entity properties.\n The properties are automatically inherited from the irg if available\n or from the method type if they were not set using\n set_entity_additional_properties() or\n set_entity_additional_property()."]
    pub fn get_entity_additional_properties(ent: *const ir_entity) -> mtp_additional_properties;
}
extern "C" {
    #[doc = " Sets the mask of the additional graph properties."]
    pub fn set_entity_additional_properties(ent: *mut ir_entity, prop: mtp_additional_properties);
}
extern "C" {
    #[doc = " Sets additional graph properties."]
    pub fn add_entity_additional_properties(ent: *mut ir_entity, flag: mtp_additional_properties);
}
extern "C" {
    #[doc = " Returns the @link unknown_entity unknown entity @endlink."]
    pub fn get_unknown_entity() -> *mut ir_entity;
}
extern "C" {
    #[doc = " Tests whether entity @p entity is (the) unknown entity.\n @returns 1 if it is the unknown entity, 0 otherwise"]
    pub fn is_unknown_entity(entity: *const ir_entity) -> ::std::os::raw::c_int;
}
#[doc = "< no access"]
pub const ptr_access_kind_ptr_access_none: ptr_access_kind = 0;
#[doc = "< read access"]
pub const ptr_access_kind_ptr_access_read: ptr_access_kind = 1;
#[doc = "< write access"]
pub const ptr_access_kind_ptr_access_write: ptr_access_kind = 2;
#[doc = "< read AND write access"]
pub const ptr_access_kind_ptr_access_rw: ptr_access_kind = 3;
#[doc = "< the pointer is stored"]
pub const ptr_access_kind_ptr_access_store: ptr_access_kind = 4;
#[doc = "< all possible access"]
pub const ptr_access_kind_ptr_access_all: ptr_access_kind = 7;
#[doc = " Encodes how a pointer parameter is accessed."]
pub type ptr_access_kind = ::std::os::raw::c_uint;
pub const tp_opcode_tpo_uninitialized: tp_opcode = 0;
#[doc = "< A struct type."]
pub const tp_opcode_tpo_struct: tp_opcode = 1;
#[doc = "< A union type."]
pub const tp_opcode_tpo_union: tp_opcode = 2;
#[doc = "< A class type."]
pub const tp_opcode_tpo_class: tp_opcode = 3;
#[doc = "< A segment type."]
pub const tp_opcode_tpo_segment: tp_opcode = 4;
#[doc = "< A method type."]
pub const tp_opcode_tpo_method: tp_opcode = 5;
#[doc = "< An array type."]
pub const tp_opcode_tpo_array: tp_opcode = 6;
#[doc = "< A pointer type."]
pub const tp_opcode_tpo_pointer: tp_opcode = 7;
#[doc = "< A primitive type."]
pub const tp_opcode_tpo_primitive: tp_opcode = 8;
#[doc = "< a piece of code (a basic block)"]
pub const tp_opcode_tpo_code: tp_opcode = 9;
#[doc = "< Special code for the Unknown type."]
pub const tp_opcode_tpo_unknown: tp_opcode = 10;
pub const tp_opcode_tpo_last: tp_opcode = 10;
#[doc = "  An enum for the type kinds.\n  For each type kind exists a typecode to identify it."]
pub type tp_opcode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the name of the type opcode @p opcode."]
    pub fn get_type_opcode_name(opcode: tp_opcode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns true if low is subclass of high.\n\n  Low is a subclass of high if low == high or if low is a subclass of\n  a subclass of high.  I.e, we search in all subtypes of high for low.\n  @@@ this can be implemented more efficient if we know the set of all\n  subclasses of high."]
    pub fn is_SubClass_of(low: *const ir_type, high: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Subclass check for pointers to classes.\n\n  Dereferences both types the same number of times (as much as possible).\n  If the remaining types are both class types and subclasses, returns\n  true, else false.  Can also be called with two class types.\n  @sa is_SubClass_of()"]
    pub fn is_SubClass_ptr_of(low: *mut ir_type, high: *mut ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if high is (transitively) overwritten by low.\n\n  Returns false if high == low."]
    pub fn is_overwritten_by(high: *mut ir_entity, low: *mut ir_entity) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resolve polymorphism in the inheritance relation.\n\n  Returns the dynamically referenced entity if the static entity and the\n  dynamic type are given.\n  Searches downwards in overwritten tree."]
    pub fn resolve_ent_polymorphy(
        dynamic_class: *mut ir_type,
        static_ent: *mut ir_entity,
    ) -> *mut ir_entity;
}
#[doc = "<  Closure is not computed, can not be accessed."]
pub const inh_transitive_closure_state_inh_transitive_closure_none: inh_transitive_closure_state =
    0;
#[doc = "<  Closure computed and valid."]
pub const inh_transitive_closure_state_inh_transitive_closure_valid: inh_transitive_closure_state =
    1;
#[doc = "<  Closure invalid, but can be accessed."]
pub const inh_transitive_closure_state_inh_transitive_closure_invalid:
    inh_transitive_closure_state = 2;
#[doc = "<  Invalid value."]
pub const inh_transitive_closure_state_inh_transitive_closure_max: inh_transitive_closure_state = 3;
#[doc = " The state of the transitive closure."]
pub type inh_transitive_closure_state = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sets the transitive closure of sub/superclass state for the\n whole program."]
    pub fn set_irp_inh_transitive_closure_state(s: inh_transitive_closure_state);
}
extern "C" {
    #[doc = " Sets the transitive closure of sub/superclass state for the\n whole program to #inh_transitive_closure_invalid"]
    pub fn invalidate_irp_inh_transitive_closure_state();
}
extern "C" {
    #[doc = " Returns the transitive closure of sub/superclass state for the\n whole program."]
    pub fn get_irp_inh_transitive_closure_state() -> inh_transitive_closure_state;
}
extern "C" {
    #[doc = " Compute transitive closure of the subclass/superclass and\n overwrites/overwrittenby relation.\n\n This function walks over the ir (O(\\#types+\\#entities)) to compute the\n transitive closure."]
    pub fn compute_inh_transitive_closure();
}
extern "C" {
    #[doc = " Free memory occupied by the transitive closure information."]
    pub fn free_inh_transitive_closure();
}
extern "C" {
    #[doc = " Start iteration over all transitive subtypes of @p tp"]
    pub fn get_class_trans_subtype_first(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns next type in a subtype iteration started by\n get_class_trans_subtype_first()"]
    pub fn get_class_trans_subtype_next(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Check if @p subtp is a subtype of @p tp. This function checks the full\n transitive closure of the subtype relation and not just direct subtyping.\n @return 1 if it is a subtype, 0 otherwise"]
    pub fn is_class_trans_subtype(
        tp: *const ir_type,
        subtp: *const ir_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start iteration over all transitive supertypes of @p tp"]
    pub fn get_class_trans_supertype_first(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns next type in a supertype iteration started by\n get_class_trans_supertype_first()"]
    pub fn get_class_trans_supertype_next(tp: *const ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Start iteration over all entities that transitive overwrite entity @p ent."]
    pub fn get_entity_trans_overwrittenby_first(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns next entity in a overwrittenby iteration started by\n get_entity_trans_overwrittenby_first()"]
    pub fn get_entity_trans_overwrittenby_next(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Start iteration over all transitive overwritten entities, overwritten by\n entity @p ent"]
    pub fn get_entity_trans_overwrites_first(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns next entity in a overwrites iteration started by\n get_entity_trans_overwrites_first()"]
    pub fn get_entity_trans_overwrites_next(ent: *const ir_entity) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Checks a type for memory corruption, dangling pointers and consistency.\n\n @return non-zero if no errors were found"]
    pub fn check_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walks the type information and performs a set of sanity checks.\n\n @return 0 in case of an error"]
    pub fn tr_verify() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees the memory used by the type.\n\n Removes the type from the type list and frees all entities\n belonging to the type."]
    pub fn free_type(tp: *mut ir_type);
}
extern "C" {
    #[doc = " Returns opcode of type @p type"]
    pub fn get_type_opcode(type_: *const ir_type) -> tp_opcode;
}
extern "C" {
    #[doc = " construct a string representing the type.\n This uses the info retrieved by the type_dbg_info if available.\n Otherwise it tries to create an approximate textual representation of the\n type.\n Keep in mind that this representation is not unique for each type,\n might abstract away some details. The main intention of this is creating\n human redable strings giving an idea of the type."]
    pub fn ir_print_type(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        tp: *const ir_type,
    );
}
#[doc = "< The layout of this type is not defined.\nAddress computation to access fields is not\npossible, fields must be accessed by Sel\nnodes.\nThis is the default value except for\npointer, primitive and method types."]
pub const ir_type_state_layout_undefined: ir_type_state = 0;
#[doc = "< The layout is fixed, all component/member entities\nhave an offset assigned. Size of the type is\nknown. Arrays can be accessed by explicit address\ncomputation.\nDefault for pointer, primitive and method types."]
pub const ir_type_state_layout_fixed: ir_type_state = 1;
#[doc = " The state of the type layout."]
pub type ir_type_state = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns a human readable string for the enum entry."]
    pub fn get_type_state_name(s: ir_type_state) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the type layout state of a type."]
    pub fn get_type_state(tp: *const ir_type) -> ir_type_state;
}
extern "C" {
    #[doc = " Sets the type layout state of a type.\n\n For primitives, pointer and method types the layout is always fixed.\n This call is legal but has no effect."]
    pub fn set_type_state(tp: *mut ir_type, state: ir_type_state);
}
extern "C" {
    #[doc = " Returns the mode of a type.\n\n Returns NULL for all non atomic types."]
    pub fn get_type_mode(tp: *const ir_type) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns the size of a type in bytes."]
    pub fn get_type_size(tp: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the size of a type in bytes.\n\n For primitive, pointer and method types the size is always fixed.\n This call is legal but has no effect."]
    pub fn set_type_size(tp: *mut ir_type, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Returns the alignment of a type in bytes."]
    pub fn get_type_alignment(tp: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the alignment of a type in bytes."]
    pub fn set_type_alignment(tp: *mut ir_type, align: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Returns the visited counter of a type.\n @see @ref visited_counters"]
    pub fn get_type_visited(tp: *const ir_type) -> ir_visited_t;
}
extern "C" {
    #[doc = " Sets the visited counter of a type to num.\n @see @ref visited_counters"]
    pub fn set_type_visited(tp: *mut ir_type, num: ir_visited_t);
}
extern "C" {
    #[doc = " Sets visited field in type to type_visited.\n @see @ref visited_counters"]
    pub fn mark_type_visited(tp: *mut ir_type);
}
extern "C" {
    #[doc = " Returns non-zero if the type is already visited\n @see @ref visited_counters"]
    pub fn type_visited(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the associated link field of a type."]
    pub fn get_type_link(tp: *const ir_type) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the associated link field of a type."]
    pub fn set_type_link(tp: *mut ir_type, l: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Increments type visited reference counter by one.\n @see @ref visited_counters, mark_type_visited(), type_visited()"]
    pub fn inc_master_type_visited();
}
extern "C" {
    #[doc = " Sets type visited reference counter.\n @see @ref visited_counters"]
    pub fn set_master_type_visited(val: ir_visited_t);
}
extern "C" {
    #[doc = " Returns type visited reference counter.\n @see @ref visited_counters"]
    pub fn get_master_type_visited() -> ir_visited_t;
}
extern "C" {
    #[doc = " Sets the debug information of a type.\n\n @param tp  The type.\n @param db  The debug info."]
    pub fn set_type_dbg_info(tp: *mut ir_type, db: *mut type_dbg_info);
}
extern "C" {
    #[doc = " Returns the debug information of a type.\n\n @param tp  The type."]
    pub fn get_type_dbg_info(tp: *const ir_type) -> *mut type_dbg_info;
}
extern "C" {
    #[doc = "  Outputs a unique number for this type if libfirm is compiled for\n  debugging, (configure with --enable-debug) else returns the address\n  of the type cast to long."]
    pub fn get_type_nr(tp: *const ir_type) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Creates a new class type."]
    pub fn new_type_class(name: *const ::std::os::raw::c_char) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the number of members of this class."]
    pub fn get_class_n_members(clss: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the member at position pos, 0 <= pos < n_member"]
    pub fn get_class_member(clss: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns index of mem in clss, INVALID_MEMBER_INDEX if not contained."]
    pub fn get_class_member_index(clss: *const ir_type, mem: *const ir_entity) -> usize;
}
extern "C" {
    #[doc = " Adds subtype as subtype to clss.\n\n  Checks whether clss is a supertype of subtype.  If not\n  adds also clss as supertype to subtype."]
    pub fn add_class_subtype(clss: *mut ir_type, subtype: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the number of subtypes"]
    pub fn get_class_n_subtypes(clss: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the subtype at position pos, 0 <= pos < n_subtype."]
    pub fn get_class_subtype(clss: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the index to access subclass as subtype of class.\n\n  If subclass is no direct subtype of class returns -1."]
    pub fn get_class_subtype_index(clss: *const ir_type, subclass: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Sets the subtype at position pos, 0 <= pos < n_subtype.\n\n  Does not set the corresponding supertype relation for subtype: this might\n  be a different position!"]
    pub fn set_class_subtype(clss: *mut ir_type, subtype: *mut ir_type, pos: usize);
}
extern "C" {
    #[doc = " Finds subtype in the list of subtypes and removes it"]
    pub fn remove_class_subtype(clss: *mut ir_type, subtype: *mut ir_type);
}
extern "C" {
    #[doc = " Adds supertype as supertype to class.\n\n  Checks whether clss is a subtype of supertype.  If not\n  adds also clss as subtype to supertype."]
    pub fn add_class_supertype(clss: *mut ir_type, supertype: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the number of supertypes"]
    pub fn get_class_n_supertypes(clss: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the index to access superclass as supertype of class.\n\n  If superclass is no direct supertype of class returns -1."]
    pub fn get_class_supertype_index(clss: *const ir_type, super_clss: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the supertype at position pos,  0 <= pos < n_supertype."]
    pub fn get_class_supertype(clss: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets the supertype at position pos, 0 <= pos < n_supertype.\n\n  Does not set the corresponding subtype relation for supertype: this might\n  be at a different position!"]
    pub fn set_class_supertype(clss: *mut ir_type, supertype: *mut ir_type, pos: usize);
}
extern "C" {
    #[doc = " Finds supertype in the list of supertypes and removes it"]
    pub fn remove_class_supertype(clss: *mut ir_type, supertype: *mut ir_type);
}
extern "C" {
    #[doc = " Returns true if a type is a class type."]
    pub fn is_Class_type(clss: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new type struct"]
    pub fn new_type_struct(name: *const ::std::os::raw::c_char) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the number of members of this struct."]
    pub fn get_struct_n_members(strct: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the member at position pos, pos < n_member"]
    pub fn get_struct_member(strct: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns index of member in strct, -1 if not contained."]
    pub fn get_struct_member_index(strct: *const ir_type, member: *const ir_entity) -> usize;
}
extern "C" {
    #[doc = " Returns true if a type is a struct type."]
    pub fn is_Struct_type(strct: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup compound_type\n @defgroup union_type  Union\n\n   The union type represents union types.  Note that this representation\n   resembles the C union type.  For tagged variant types like in Pascal or\n   Modula, a combination of a struct and a union type must be used.\n\n   - n_types:     Number of alternatives.\n   - members:     Entities for the alternatives.\n @{\n/\n/** Creates a new type union."]
    pub fn new_type_union(name: *const ::std::os::raw::c_char) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the number of unioned types of this union"]
    pub fn get_union_n_members(uni: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the entity at position pos of a union"]
    pub fn get_union_member(uni: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns index of member in uni, -1 if not contained."]
    pub fn get_union_member_index(uni: *const ir_type, member: *const ir_entity) -> usize;
}
extern "C" {
    #[doc = " Returns true if a type is a union type."]
    pub fn is_Union_type(uni: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new method type.\n\n @param n_param        the number of parameters\n @param n_res          the number of results\n @param is_variadic    whether the function is variadic\n @param cc_mask        the calling convention\n @param property_mask  the mask of the additional graph properties\n\n The arrays for the parameter and result types are not populated by\n the constructor."]
    pub fn new_type_method(
        n_param: usize,
        n_res: usize,
        is_variadic: ::std::os::raw::c_int,
        cc_mask: ::std::os::raw::c_uint,
        property_mask: mtp_additional_properties,
    ) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the number of parameters of this method."]
    pub fn get_method_n_params(method: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the type of the parameter at position pos of a method."]
    pub fn get_method_param_type(method: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets the type of the parameter at position pos of a method.\n Note: does not change the corresponding parameter entities (if there are any)"]
    pub fn set_method_param_type(method: *mut ir_type, pos: usize, tp: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the number of results of a method type."]
    pub fn get_method_n_ress(method: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the return type of a method type at position pos."]
    pub fn get_method_res_type(method: *const ir_type, pos: usize) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets the type of the result at position pos of a method."]
    pub fn set_method_res_type(method: *mut ir_type, pos: usize, tp: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the variadicity of a method."]
    pub fn is_method_variadic(method: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the mask of the additional graph properties."]
    pub fn get_method_additional_properties(method: *const ir_type) -> mtp_additional_properties;
}
#[doc = "< Transmit parameters in registers, else the stack is used.\nThis flag may be set as default on some architectures."]
pub const calling_convention_cc_reg_param: calling_convention = 16777216;
#[doc = "< The last non-register parameter is transmitted on top of\nthe stack. This is equivalent to the pascal\ncalling convention. If this flag is not set, the first\nnon-register parameter is used (stdcall or cdecl\ncalling convention)"]
pub const calling_convention_cc_last_on_top: calling_convention = 33554432;
#[doc = "< The callee clears the stack. This forbids variadic\nfunction calls (stdcall)."]
pub const calling_convention_cc_callee_clear_stk: calling_convention = 67108864;
#[doc = "< The first parameter is a this pointer and is transmitted\nin a special way."]
pub const calling_convention_cc_this_call: calling_convention = 134217728;
#[doc = "< The method returns a compound type."]
pub const calling_convention_cc_compound_ret: calling_convention = 268435456;
#[doc = "< The method did not allocate an own stack frame, instead the\ncaller must reserve size on its own stack."]
pub const calling_convention_cc_frame_on_caller_stk: calling_convention = 536870912;
#[doc = "< Transmit floating point parameters in registers, else the stack is used."]
pub const calling_convention_cc_fpreg_param: calling_convention = 1073741824;
#[doc = " Calling conventions: lower 24 bits are the number of register parameters,\n upper 8 encode the calling conventions."]
pub type calling_convention = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the calling convention of an entities graph."]
    pub fn get_method_calling_convention(method: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the number of registers parameters, 0 means default."]
    pub fn get_method_n_regparams(method: *mut ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns true if a type is a method type."]
    pub fn is_Method_type(method: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new array type with @p n_elements of type @p element_type.\n\n 0 elements designates an array of unknown length."]
    pub fn new_type_array(
        element_type: *mut ir_type,
        n_elements: ::std::os::raw::c_uint,
    ) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the size (number of elements) of an array."]
    pub fn get_array_size(array: *const ir_type) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the array element type."]
    pub fn get_array_element_type(array: *const ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns true if a type is an array type."]
    pub fn is_Array_type(array: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new type pointer."]
    pub fn new_type_pointer(points_to: *mut ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets the type to which a pointer points to."]
    pub fn set_pointer_points_to_type(pointer: *mut ir_type, tp: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the type to which a pointer points to."]
    pub fn get_pointer_points_to_type(pointer: *const ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns true if a type is a pointer type."]
    pub fn is_Pointer_type(pointer: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup primitive_type Primitive\n\n Primitive types are types that represent atomic data values that\n map directly to modes.  They don't have private attributes.  The\n important information they carry is held in the common mode field.\n @{\n/\n/** Creates a new primitive type."]
    pub fn new_type_primitive(mode: *mut ir_mode) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns true if a type is a primitive type."]
    pub fn is_Primitive_type(primitive: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup code_type Code\n @{\n/\n/** Returns the code type."]
    pub fn get_code_type() -> *mut ir_type;
}
extern "C" {
    #[doc = " Checks whether a type is a code type."]
    pub fn is_code_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup unknown_type  Unknown\n\n  This type is an auxiliary type dedicated to support type analyses.\n\n  The unknown type represents that there could be a type, but it is not\n  known.  This type can be used to initialize fields before an analysis (not known\n  yet) or to represent the top of a lattice (could not be determined).  There exists\n  exactly one type unknown. This type is not on the type list in ir_prog.  It is\n  allocated when initializing the type module.\n\n  The following values are set:\n    - mode:  mode_ANY\n    - name:  \"type_unknown\"\n    - state: layout_fixed\n    - size:  0\n @{\n/\n/** Returns the unknown type."]
    pub fn get_unknown_type() -> *mut ir_type;
}
extern "C" {
    #[doc = " Checks whether type @p type is the unknown type"]
    pub fn is_unknown_type(type_: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Checks whether a type is atomic.\n  @param tp   any type\n  @return true if type is primitive or pointer"]
    pub fn is_atomic_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the identifier of a compound type"]
    pub fn get_compound_ident(tp: *const ir_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns compound identifier as c-string"]
    pub fn get_compound_name(tp: *const ir_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the number of elements in a Firm compound type.\n\n This is just a comfortability function, because structs and\n classes can often be treated be the same code, but they have\n different access functions to their members.\n\n @param tp  The type (must be struct, union or class).\n\n @return Number of members in the compound type."]
    pub fn get_compound_n_members(tp: *const ir_type) -> usize;
}
extern "C" {
    #[doc = " Returns the member of a Firm compound type at position pos.\n\n @param tp  The type (must be struct, union or class).\n @param pos The number of the member.\n\n @return The member entity at position pos."]
    pub fn get_compound_member(tp: *const ir_type, pos: usize) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns index of member in tp, -1 if not contained."]
    pub fn get_compound_member_index(tp: *const ir_type, member: *const ir_entity) -> usize;
}
extern "C" {
    #[doc = " Remove a member from a compound type."]
    pub fn remove_compound_member(compound: *mut ir_type, entity: *mut ir_entity);
}
extern "C" {
    #[doc = " Layout members of a compound type in the default way (as determined\n by the target ABI). The compound type may not contain bitfield\n members, in which case it must be laid out by hand."]
    pub fn default_layout_compound_type(tp: *mut ir_type);
}
extern "C" {
    #[doc = " Checks whether a type is a compound type.\n\n @param tp - any type\n\n @return true if the type is class, structure, union or segment type."]
    pub fn is_compound_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Makes a new frame type. Frame types are class types,\n so all class access functions work.\n Frame types are not in the global list of types."]
    pub fn new_type_frame() -> *mut ir_type;
}
extern "C" {
    #[doc = " Checks, whether a type is a frame type."]
    pub fn is_frame_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Makes a clone of a frame type.\n Sets entity links from old frame entities to new ones and\n vice versa."]
    pub fn clone_frame_type(type_: *mut ir_type) -> *mut ir_type;
}
extern "C" {
    #[doc = " Checks, whether a type is a frame type."]
    pub fn is_segment_type(tp: *const ir_type) -> ::std::os::raw::c_int;
}
#[doc = "  Type for a function that compares two types.\n\n   @param tp1  The first type to compare.\n   @param tp2  The second type to compare."]
pub type compare_types_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        tp1: *const ::std::os::raw::c_void,
        tp2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Type of argument functions for type walkers.\n\n @param type    points to the visited type, either this or entity is non-null\n @param entity  points to the visited entity, either this or type is non-null\n @param env     free environment pointer"]
pub type type_walk_func = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *mut ir_type,
        entity: *mut ir_entity,
        env: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "  The class walk function\n\n @param clss    points to the visited class\n @param env     free environment pointer"]
pub type class_walk_func = ::std::option::Option<
    unsafe extern "C" fn(clss: *mut ir_type, env: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Touches every type and entity in unspecified order.  If new\n  types/entities are created during the traversal these will\n  be visited, too.\n  Does not touch frame types or types for value params ..."]
    pub fn type_walk(pre: type_walk_func, post: type_walk_func, env: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Walks over all type information reachable from an ir graph.\n\n  Walks over all type information reachable from irg, i.e., starts a\n  type walk at the irgs entity, the irgs frame type and all types and\n  entities that are attributes to firm nodes."]
    pub fn type_walk_irg(
        irg: *mut ir_graph,
        pre: type_walk_func,
        post: type_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Touches every class in specified order:\n    - first the super class\n    - second the class itself\n    - third the sub classes.  If new classes are created\n    during the traversal these will be visited, too.\n\n    @deprecated will be removed?"]
    pub fn type_walk_super2sub(
        pre: type_walk_func,
        post: type_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walker for class types in inheritance order.\n\n Touches every class in specified order:\n   - first the super class\n   - second the class itself\n   If new classes are created during the traversal these\n   will be visited, too.\n Starts the walk at arbitrary classes.\n Executes pre when first visiting a class.  Executes post after\n visiting all superclasses.\n\n The arguments pre, post, env may be NULL."]
    pub fn type_walk_super(
        pre: type_walk_func,
        post: type_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Same as type_walk_super2sub, but visits only class types.\n Executes pre for a class if all superclasses have been visited.\n Then iterates to subclasses.  Executes post after return from\n subclass.\n Does not visit global type, frame types."]
    pub fn class_walk_super2sub(
        pre: class_walk_func,
        post: class_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
#[doc = " the entity walk function.  A function type for entity walkers.\n\n @param ent     points to the visited entity\n @param env     free environment pointer"]
pub type entity_walk_func = ::std::option::Option<
    unsafe extern "C" fn(ent: *mut ir_entity, env: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Walks over all entities in the type.\n\n @param tp    the type\n @param doit  the entity walker function\n @param env   environment, will be passed to the walker function"]
    pub fn walk_types_entities(
        tp: *mut ir_type,
        doit: entity_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns for a method with pointer parameter\n if they will be read or written.\n\n @param ent  The entity that represent this method.\n @param pos  The position of method's parameter for that\n             we need information.\n\n If the pos'th parameter is NOT of a pointer type, ptr_access_none\n is returned;"]
    pub fn get_method_param_access(ent: *mut ir_entity, pos: usize) -> ptr_access_kind;
}
extern "C" {
    #[doc = " Analyze how pointer arguments of a given\n ir graph are accessed.\n\n @param irg   The ir graph to analyze."]
    pub fn analyze_irg_args(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns for a method the 'weight' that every parameter\n has on optimization possibility. Higher values allows\n higher optimization with procedure cloning.\n\n The values are calculated on demand only."]
    pub fn get_method_param_weight(ent: *mut ir_entity, pos: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Analyze the parameters of a given ir graph.\n\n @param irg The ir graph to analyze."]
    pub fn analyze_irg_args_weight(irg: *mut ir_graph);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = "< For modes for which no representation is\nspecified."]
pub const ir_mode_arithmetic_irma_none: ir_mode_arithmetic = 1;
#[doc = "< Values of the mode are represented as two's\ncomplement. Only legal for modes of sort\nint_number and reference."]
pub const ir_mode_arithmetic_irma_twos_complement: ir_mode_arithmetic = 2;
#[doc = "< Values of the mode are represented according\nto ieee754 floating point standard.  Only\nlegal for modes of sort float_number."]
pub const ir_mode_arithmetic_irma_ieee754: ir_mode_arithmetic = 256;
#[doc = "< x86 extended floating point values"]
pub const ir_mode_arithmetic_irma_x86_extended_float: ir_mode_arithmetic = 257;
pub const ir_mode_arithmetic_irma_last: ir_mode_arithmetic = 257;
#[doc = " These values represent the different arithmetic operations possible with a\n mode."]
pub type ir_mode_arithmetic = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Creates a new mode.\n\n @param name          the name of the mode to be created\n @param bit_size      number of bits this mode allocate\n @param sign          non-zero if this is a signed mode\n @param modulo_shift  Is ignored for modes other than integer.\n\n This function constructs a new mode given by the parameters.\n If the parameters match an already defined mode, this mode is returned\n (including the default modes).\n Arithmetic of int modes is irma_twos_complement.\n\n @return\n   The new mode or NULL on error."]
    pub fn new_int_mode(
        name: *const ::std::os::raw::c_char,
        bit_size: ::std::os::raw::c_uint,
        sign: ::std::os::raw::c_int,
        modulo_shift: ::std::os::raw::c_uint,
    ) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Create a new reference mode.\n Reference modes are always unsigned.\n Arithmetic of reference modes is irma_twos_complement."]
    pub fn new_reference_mode(
        name: *const ::std::os::raw::c_char,
        bit_size: ::std::os::raw::c_uint,
        modulo_shift: ::std::os::raw::c_uint,
    ) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Create a new ieee754 float mode.\n\n float-modes are always signed and have no modulo shift.\n @param name          the name of the mode to be created\n @param arithmetic    arithmetic/representation of the mode\n @param exponent_size size of exponent in bits\n @param mantissa_size size of mantissa in bits (including explicit one in\n                      irma_x86_extended_float)\n @param int_conv_overflow Semantic on float to integer conversion overflow."]
    pub fn new_float_mode(
        name: *const ::std::os::raw::c_char,
        arithmetic: ir_mode_arithmetic,
        exponent_size: ::std::os::raw::c_uint,
        mantissa_size: ::std::os::raw::c_uint,
        int_conv_overflow: float_int_conversion_overflow_style_t,
    ) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Creates a new mode for data values which are not used to perform arithmetic.\n Arithmetic will be set to irma_none."]
    pub fn new_non_arithmetic_mode(
        name: *const ::std::os::raw::c_char,
        bit_size: ::std::os::raw::c_uint,
    ) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns the ident* of the mode"]
    pub fn get_mode_ident(mode: *const ir_mode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the null-terminated name of this mode."]
    pub fn get_mode_name(mode: *const ir_mode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the size of values of the mode in bits."]
    pub fn get_mode_size_bits(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the size of values of the mode in bytes.\n  If the size is not dividable by 8 returns -1."]
    pub fn get_mode_size_bytes(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the arithmetic of a mode"]
    pub fn get_mode_arithmetic(mode: *const ir_mode) -> ir_mode_arithmetic;
}
extern "C" {
    #[doc = " Returns the modulo shift attribute.\n\n  Attribute modulo shift specifies for modes of kind irms_int_number\n  whether shift applies modulo to value of bits to shift.  Zero for\n  modes that are not integer."]
    pub fn get_mode_modulo_shift(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the smallest representable value of a given mode.\n\n For modes of the sort float_number this is the most negative value\n bigger than -infinite."]
    pub fn get_mode_min(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the biggest representable value of a given mode.\n\n For modes of the sort float_number this is the largest value lower\n than infinite."]
    pub fn get_mode_max(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the value Zero represented in this mode.\n\n Zero is the additive neutral element and as such\n is defined only for modes allowing addition, i.e.\n op_pin_state_floats and ints, and references (NULL-Pointer)\n else returns tarval_bad."]
    pub fn get_mode_null(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the value One, represented in this mode.\n\n One, being the multiplicative neutral element,\n is defined only for modes allowing multiplication,\n i.e. ints and floats."]
    pub fn get_mode_one(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the value where all bits are One, represented in this mode.\n\n All One is defined only for modes integer, reference and boolean modes\n This represents the value -1 for signed modes with irma_twos_complement."]
    pub fn get_mode_all_one(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns a positive infinite value of a mode.\n\n This is only valid for float_numbers, other modes will result in tarval_bad.\n There are typically multiple possible representations of infinity, don't\n compare with this value but use tarval_is_plus_inf() instead."]
    pub fn get_mode_infinite(mode: *const ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = "< memory"]
    pub static mut mode_M: *mut ir_mode;
}
extern "C" {
    #[doc = "< ieee754 binary32 float (single precision)"]
    pub static mut mode_F: *mut ir_mode;
}
extern "C" {
    #[doc = "< ieee754 binary64 float (double precision)"]
    pub static mut mode_D: *mut ir_mode;
}
extern "C" {
    #[doc = "< int8"]
    pub static mut mode_Bs: *mut ir_mode;
}
extern "C" {
    #[doc = "< uint8"]
    pub static mut mode_Bu: *mut ir_mode;
}
extern "C" {
    #[doc = "< int16"]
    pub static mut mode_Hs: *mut ir_mode;
}
extern "C" {
    #[doc = "< uint16"]
    pub static mut mode_Hu: *mut ir_mode;
}
extern "C" {
    #[doc = "< int32"]
    pub static mut mode_Is: *mut ir_mode;
}
extern "C" {
    #[doc = "< uint32"]
    pub static mut mode_Iu: *mut ir_mode;
}
extern "C" {
    #[doc = "< int64"]
    pub static mut mode_Ls: *mut ir_mode;
}
extern "C" {
    #[doc = "< uint64"]
    pub static mut mode_Lu: *mut ir_mode;
}
extern "C" {
    #[doc = "< pointer"]
    pub static mut mode_P: *mut ir_mode;
}
extern "C" {
    #[doc = " This mode represents (parts of) the processor status flag queried in\n conditional jumps or predicated code.\n\n Do not confuse this with boolean variables found in some languages.\n mode_b values are used as the inputs to conditional jumps or Mux nodes.\n As is the case with most hardware flags registers you cannot simply\n load/store them to memory or convert them to integer/float values with a\n single operation. You have to use an if-like construct to produce integer\n numbers based on a mode_b value."]
    pub static mut mode_b: *mut ir_mode;
}
extern "C" {
    #[doc = "< execution"]
    pub static mut mode_X: *mut ir_mode;
}
extern "C" {
    #[doc = "< block"]
    pub static mut mode_BB: *mut ir_mode;
}
extern "C" {
    #[doc = "< tuple (none)"]
    pub static mut mode_T: *mut ir_mode;
}
extern "C" {
    #[doc = "< undefined mode"]
    pub static mut mode_ANY: *mut ir_mode;
}
extern "C" {
    #[doc = "< bad mode"]
    pub static mut mode_BAD: *mut ir_mode;
}
extern "C" {
    #[doc = " Returns float mode. @copydoc mode_F"]
    pub fn get_modeF() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns double mode. @copydoc mode_D"]
    pub fn get_modeD() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns byte signed mode. @copydoc mode_Bs"]
    pub fn get_modeBs() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns byte unsigned mode. @copydoc mode_Bu"]
    pub fn get_modeBu() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns halfword signed mode. @copydoc mode_Hs"]
    pub fn get_modeHs() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns halfword unsigned mode. @copydoc mode_Hu"]
    pub fn get_modeHu() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns integer signed mode. @copydoc mode_Is"]
    pub fn get_modeIs() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns integer unsigned mode. @copydoc mode_Iu"]
    pub fn get_modeIu() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns long signed mode. @copydoc mode_Ls"]
    pub fn get_modeLs() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns long unsigned mode. @copydoc mode_Lu"]
    pub fn get_modeLu() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns pointer mode. @copydoc mode_P"]
    pub fn get_modeP() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns internal boolean mode. @copydoc mode_b"]
    pub fn get_modeb() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns control-flow mode. @copydoc mode_X"]
    pub fn get_modeX() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns Basic-Block mode. @copydoc mode_BB"]
    pub fn get_modeBB() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns memory mode. @copydoc mode_M"]
    pub fn get_modeM() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns tuple mode. @copydoc mode_T"]
    pub fn get_modeT() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns ANY mode. @copydoc mode_ANY"]
    pub fn get_modeANY() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns BAD mode. @copydoc mode_BAD"]
    pub fn get_modeBAD() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Sets the machine specific pointer mode."]
    pub fn set_modeP(p: *mut ir_mode);
}
extern "C" {
    #[doc = " Returns 1 if @p mode is signed, 0 otherwise"]
    pub fn mode_is_signed(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if @p mode is for floating point numbers, 0 otherwise"]
    pub fn mode_is_float(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if @p mode is for integer numbers, 0 otherwise"]
    pub fn mode_is_int(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if @p mode is for references/pointers, 0 otherwise"]
    pub fn mode_is_reference(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if @p mode is for numeric values, 0 otherwise.\n\n A numeric mode supports the Add, Sub, Mul, Div and Minus operations."]
    pub fn mode_is_num(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if @p mode is for data values, 0 otherwise.\n\n A data value is made from a fixed size of bits, you can build a tarval for\n such values."]
    pub fn mode_is_data(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if a value of mode @p sm can be converted to mode @p lm without\n loss.\n\n That is the interpretation of the numbers does not changes, so a signed\n integer mode is never smaller than an unsigned integer mode since the\n unsigned mode can't represent negative numbers in a way that they are\n interpreted as negative numbers.\n\n @see values_in_mode()"]
    pub fn smaller_mode(sm: *const ir_mode, lm: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if no information is lost when converting a value of mode @p sm\n into mode @p lm (and back to mode @p sm).\n\n So the interpretation of the values may change in the intermediate mode @p lm\n (for example when converting negative signed integer numbers into unsigned\n integers) but after a conversion back they are exactly the same value.\n\n @see smaller_mode()"]
    pub fn values_in_mode(sm: *const ir_mode, lm: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a matching unsigned mode for a given integer signed mode.\n Returns NULL if no matching mode exists."]
    pub fn find_unsigned_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns a matching signed mode for a given integer unsigned mode.\n Returns NULL if no matching mode exists."]
    pub fn find_signed_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns an integer mode with 2*n bits for a given integer mode with n bits.\n Returns NULL if no matching mode exists."]
    pub fn find_double_bits_int_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns non-zero if the given mode has negative zeros, i.e. +0 and -0 exist.\n Note that for comparisons +0 and -0 are considered equal, the sign only\n shows in expressions like 1/x which results in +inf/-inf."]
    pub fn mode_has_signed_zero(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the given mode might overflow on unary Minus."]
    pub fn mode_overflow_on_unary_Minus(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the mode has a reversed wrap-around\n logic, especially (a + x) - x == a.\n This is normally true for integer modes, not for floating\n point modes."]
    pub fn mode_wrap_around(mode: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the integer equivalent mode for an reference mode. This is typically\n used to add/subtract offsets from reference values."]
    pub fn get_reference_offset_mode(mode: *const ir_mode) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Sets the (signed) integer equivalent mode for an reference mode."]
    pub fn set_reference_offset_mode(ref_mode: *mut ir_mode, int_mode: *mut ir_mode);
}
extern "C" {
    #[doc = " Returns size of bits used for to encode the mantissa (for float modes).\n This includes the leading one for modes with irma_x86_extended_float."]
    pub fn get_mode_mantissa_size(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns size of exponent in bits (for float modes)"]
    pub fn get_mode_exponent_size(mode: *const ir_mode) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns semantic on float to integer conversion overflow."]
    pub fn get_mode_float_int_overflow(
        mode: *const ir_mode,
    ) -> float_int_conversion_overflow_style_t;
}
extern "C" {
    #[doc = " Returns non-zero if the cast from mode src to mode dst is a\n reinterpret cast (i.e. only the bit pattern is reinterpreted,\n no conversion is done)"]
    pub fn is_reinterpret_cast(src: *const ir_mode, dst: *const ir_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the primitive type matching the given mode"]
    pub fn get_type_for_mode(mode: *const ir_mode) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns number of known modes."]
    pub fn ir_get_n_modes() -> usize;
}
extern "C" {
    #[doc = " Returns known mode number @p num."]
    pub fn ir_get_mode(num: usize) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Control flow optimization.\n\n Removes empty blocks doing if simplifications and loop simplifications.\n A block is empty if it contains only a Jmp node and Phi nodes.\n Merges single entry single exit blocks with their predecessor\n and propagates dead control flow by calling equivalent_node().\n Independent of compiler flag it removes Tuples from cf edges,\n Bad predecessors from Blocks and Phis, and unnecessary predecessors of End.\n Destroys backedge information."]
    pub fn optimize_cf(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Perform path-sensitive jump threading on the given graph.\n\n @param irg  the graph"]
    pub fn opt_jumpthreading(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Simplifies boolean expression in the given ir graph.\n eg. x < 5 && x < 6 becomes x < 5\n\n @param irg  the graph"]
    pub fn opt_bool(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Reduces the number of Conv nodes in the given ir graph.\n\n @param irg  the graph"]
    pub fn conv_opt(irg: *mut ir_graph);
}
#[doc = " A callback that checks whether a entity is an allocation\n routine."]
pub type check_alloc_entity_func =
    ::std::option::Option<unsafe extern "C" fn(ent: *mut ir_entity) -> ::std::os::raw::c_int>;
extern "C" {
    #[doc = " Optimize function calls by handling const functions.\n\n This optimization first detects all \"const functions\", i.e.,\n IR graphs that neither read nor write memory (and hence did\n not create exceptions, as these use memory in Firm).\n\n The result of calls to such functions depends only on its\n arguments, hence those calls are no more pinned.\n\n This is a rather strong criteria, so do not expect that a\n lot of functions will be found. Moreover, all of them might\n already be inlined if inlining is activated.\n Anyway, it might be good for handling builtin's\n even if the later read/write memory (but we know how).\n\n This optimization reads the irg_const_function property of\n entities, and sets the irg_const_function property of\n graphs.\n\n If callee information is valid, we also optimize polymorphic Calls."]
    pub fn optimize_funccalls();
}
extern "C" {
    #[doc = " Does Partial Redundancy Elimination combined with\n Global Value Numbering.\n Can be used to replace place_code() completely.\n\n Based on VanDrunen and Hosking 2004.\n\n @param irg  the graph"]
    pub fn do_gvn_pre(irg: *mut ir_graph);
}
#[doc = " This function is called to evaluate, if a\n mux(@p sel, @p mux_false, @p mux_true) should be built for the current\n architecture.\n If it returns non-zero, a mux is created, else the code\n is not modified.\n @param sel        A selector of a Cond.\n @param phi_list   phi node to be converted\n @param i          First data predecessor involved in if conversion\n @param j          Second data predecessor involved in if conversion"]
pub type arch_allow_ifconv_func = ::std::option::Option<
    unsafe extern "C" fn(
        sel: *const ir_node,
        mux_false: *const ir_node,
        mux_true: *const ir_node,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Perform If conversion on a graph.\n\n @param irg The graph.\n\n Cannot handle blocks with Bad control predecessors, so call it after control\n flow optimization."]
    pub fn opt_if_conv(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Perform If conversion on a graph - callback version.\n\n @param irg      The graph.\n @param callback The predicate.\n\n Like above, but let the caller decide about valid transformations\n by supplying a predicate function."]
    pub fn opt_if_conv_cb(irg: *mut ir_graph, callback: arch_allow_ifconv_func);
}
extern "C" {
    #[doc = " Tries to reduce dependencies for memory nodes where possible by parallelizing\n them and synchronizing with Sync nodes\n @param irg   the graph where memory operations should be parallelized"]
    pub fn opt_parallelize_mem(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Check if we can replace the load by a given const from\n the const code irg.\n\n @param load   the load to replace\n @param c      the constant\n\n @return if the modes match or can be transformed using a reinterpret cast\n         returns a copy of the constant (possibly Conv'ed) in the graph where\n         the load is."]
    pub fn can_replace_load_by_const(load: *const ir_node, c: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Load/Store optimization.\n\n Removes redundant non-volatile Loads and Stores.\n May introduce Bad nodes if exceptional control flow\n is removed. The following cases are optimized:\n\n Load without result: A Load which has only a memory use\n   is removed.\n\n Load after Store: A Load after a Store is removed, if\n   the Load doesn't have an exception handler OR is in\n   the same block as the Store.\n\n Load after Load: A Load after a Load is removed, if the\n   Load doesn't have an exception handler OR is in the\n   same block as the previous Load.\n\n Store before Store: A Store immediately before another\n   Store in the same block is removed, if the Store doesn't\n   have an exception handler.\n\n Store after Load: A Store after a Load is removed, if the\n   Store doesn't have an exception handler."]
    pub fn optimize_load_store(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Combine adjacent \"small\" load/store operations into bigger ones."]
    pub fn combine_memops(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " New experimental alternative to optimize_load_store.\n Based on a dataflow analysis, so load/stores are moved out of loops\n where possible"]
    pub fn opt_ldst(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Optimize the frame type of an irg by removing\n never touched entities.\n\n @param irg  The graph whose frame type will be optimized\n\n This function did not change the graph, only its frame type.\n The layout state of the frame type will be set to layout_undefined\n if entities were removed."]
    pub fn opt_frame_irg(irg: *mut ir_graph);
}
#[doc = "< no additional flags"]
pub const osr_flags_osr_flag_none: osr_flags = 0;
#[doc = "< do linear function test replacement\nonly if no overflow can occur."]
pub const osr_flags_osr_flag_lftr_with_ov_check: osr_flags = 1;
#[doc = "< ignore Multiplications by 2, 4, 8"]
pub const osr_flags_osr_flag_ignore_x86_shift: osr_flags = 2;
#[doc = "< do NOT increase register pressure by introducing new\ninduction variables."]
pub const osr_flags_osr_flag_keep_reg_pressure: osr_flags = 4;
#[doc = " Possible flags for the Operator Scalar Replacement."]
pub type osr_flags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Performs the Operator Scalar Replacement optimization and linear\n function test replacement for loop control.\n\n @param irg    the graph which should be optimized\n @param flags  set of osr_flags\n\n The linear function replacement test is controlled by the flags.\n If the osr_flag_lftr_with_ov_check is set, the replacement is only\n done if do overflow can occur.\n Otherwise it is ALWAYS done which might be insecure.\n\n For instance:\n\n for (i = 0; i < 100; ++i)\n\n might be replaced by\n\n for (i = 0; i < 400; i += 4)\n\n But\n\n for (i = 0; i < 0x7FFFFFFF; ++i)\n\n will not be replaced by\n\n for (i = 0; i < 0xFFFFFFFC; i += 4)\n\n because of overflow.\n\n More bad cases:\n\n for (i = 0; i <= 0xF; ++i)\n\n will NOT be transformed into\n\n for (i = 0xFFFFFFF0; i <= 0xFFFFFFFF; ++i)\n\n although here is no direct overflow. The OV occurs when the ++i\n is executed (and would created an endless loop here!).\n\n For the same reason, a loop\n\n for (i = 0; i <= 9; i += x)\n\n will NOT be transformed because we cannot estimate whether an overflow\n might happen adding x.\n\n Note that i < a + 400 is also not possible with the current implementation\n although this might be allowed by other compilers...\n\n Note further that tests for equality can be handled some simpler (but are not\n implemented yet).\n\n This algorithm destroys the link field of nodes."]
    pub fn opt_osr(irg: *mut ir_graph, flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Removes useless Phi cycles, i.e cycles of Phi nodes with only one\n non-Phi node.\n This is automatically done in opt_osr(), so there is no need to call it\n additionally.\n\n @param irg    the graph which should be optimized\n\n This algorithm destroys the link field of nodes."]
    pub fn remove_phi_cycles(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Performs procedure cloning. Evaluate a heuristic weight for every\n Call(..., Const, ...). If the weight is bigger than threshold,\n clone the entity and fix the calls.\n\n @param threshold   the threshold for cloning\n\n The threshold is an estimation of how many instructions are saved\n when executing a cloned method. If threshold is 0.0, every possible\n call is cloned."]
    pub fn proc_cloning(threshold: f32);
}
extern "C" {
    #[doc = " Reassociation.\n\n Applies Reassociation rules to integer expressions.\n Beware: Works only if integer overflow might be ignored, as for C, Java\n and for address expression.\n Works only if Constant folding is activated.\n\n Uses loop information to detect loop-invariant (i.e. constant\n inside the loop) values.\n\n See Muchnik 12.3.1 Algebraic Simplification and Reassociation of\n Addressing Expressions."]
    pub fn optimize_reassociation(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Normalize the Returns of a graph by creating a new End block\n with One Return(Phi).\n This is the preferred input for the if-conversion.\n\n In pseudocode, it means:\n\n if (a)\n   return b;\n else\n   return c;\n\n is transformed into\n\n if (a)\n   res = b;\n else\n   res = c;\n return res;"]
    pub fn normalize_one_return(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Normalize the Returns of a graph by moving\n the Returns upwards as much as possible.\n This might be preferred for code generation.\n\n In pseudocode, it means:\n\n if (a)\n   res = b;\n else\n   res = c;\n return res;\n\n is transformed into\n\n if (a)\n   return b;\n else\n   return c;"]
    pub fn normalize_n_returns(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Performs the scalar replacement optimization.\n Replaces local compound entities (like structures and arrays)\n with atomic values if possible. Does not handle classes yet.\n\n @param irg  the graph which should be optimized"]
    pub fn scalar_replacement_opt(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Optimizes tail-recursion calls by converting them into loops.\n Depends on the flag opt_tail_recursion.\n Currently supports the following forms:\n  - return func();\n  - return x + func();\n  - return func() - x;\n  - return x * func();\n  - return -func();\n\n Does not work for Calls that use the exception stuff.\n\n @param irg   the graph to be optimized"]
    pub fn opt_tail_rec_irg(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " CLiff Click's combo algorithm from\n   \"Combining Analyses, combining Optimizations\".\n\n Does conditional constant propagation, unreachable code elimination and\n optimistic global value numbering at once.\n\n @param irg  the graph to run on"]
    pub fn combo(irg: *mut ir_graph);
}
#[doc = " pointer to an optimization function"]
pub type opt_ptr = ::std::option::Option<unsafe extern "C" fn(irg: *mut ir_graph)>;
extern "C" {
    #[doc = " Heuristic inliner. Calculates a benefice value for every call and inlines\n those calls with a value higher than the threshold.\n\n @param maxsize             Do not inline any calls if a method has more than\n                            maxsize firm nodes.  It may reach this limit by\n                            inlining.\n @param inline_threshold    inlining threshold\n @param after_inline_opt    optimizations performed immediately after inlining\n                            some calls"]
    pub fn inline_functions(
        maxsize: ::std::os::raw::c_uint,
        inline_threshold: ::std::os::raw::c_int,
        after_inline_opt: opt_ptr,
    );
}
extern "C" {
    #[doc = " Combines congruent blocks into one.\n\n @param irg   The IR-graph to optimize."]
    pub fn shape_blocks(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Perform loop inversion on a given graph.\n Loop inversion transforms a head controlled loop (like while(...) {} and\n for(...) {}) into a foot controlled loop (do {} while(...))."]
    pub fn do_loop_inversion(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Perform loop unrolling on a given graph.\n Loop unrolling multiplies the number loop completely by a number found\n through a heuristic."]
    pub fn do_loop_unrolling(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Perform loop unrolling on a given graph.\n\n @param irg       the IR-graph to optimize\n @param factor    the unroll factor\n @param maxsize   the maximum number of nodes in a loop"]
    pub fn unroll_loops(
        irg: *mut ir_graph,
        factor: ::std::os::raw::c_uint,
        maxsize: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Perform loop peeling on a given graph."]
    pub fn do_loop_peeling(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Removes all entities which are unused.\n\n Unused entities have ir_visibility_local and are not used directly or\n indirectly through entities/code visible outside the compilation unit.\n This is usually conservative than gc_irgs, but does not respect properties\n of object-oriented programs."]
    pub fn garbage_collect_entities();
}
extern "C" {
    #[doc = " Performs dead node elimination by copying the ir graph to a new obstack.\n\n  The major intention of this pass is to free memory occupied by\n  dead nodes and outdated analyzes information.  Further this\n  function removes Bad predecessors from Blocks and the corresponding\n  inputs to Phi nodes.  This opens optimization potential for other\n  optimizations.  Further this phase reduces dead Block<->Jmp\n  self-cycles to Bad nodes.\n\n  Dead_node_elimination is only performed if options `optimize' and\n  `opt_dead_node_elimination' are set.  The graph may\n  not be in state phase_building.  The outs data structure is freed,\n  the outs state set to outs_none.  Backedge information is conserved.\n  Removes old attributes of nodes.  Sets link field to NULL.\n  Callee information must be freed (irg_callee_info_none).\n\n @param irg  The graph to be optimized."]
    pub fn dead_node_elimination(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Code Placement.\n\n Pins all floating nodes to a block where they\n will be executed only if needed.   Depends on the flag opt_global_cse.\n Graph may not be in phase_building.  Does not schedule control dead\n code.  Uses dominator information which it computes if the irg is not\n in state dom_consistent.  Destroys the out information as it moves nodes\n to other blocks.  Optimizes Tuples in Control edges.\n\n Call remove_critical_cf_edges() before place_code().  This normalizes\n the control flow graph so that for all operations a basic block exists\n where they can be optimally placed."]
    pub fn place_code(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " This optimization finds values where the bits are either constant or irrelevant\n and exchanges them for a corresponding constant."]
    pub fn occult_consts(arg1: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns true if the value @p n is known not be zero/null.\n\n @param n        a node representing the value\n @param confirm  if n is confirmed to be != 0, returns\n                 the the Confirm-node, else NULL"]
    pub fn value_not_null(n: *const ir_node, confirm: *mut *const ir_node)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the value of a Cmp if one or both predecessors are Confirm nodes.\n\n @param left      the left operand of the Cmp\n @param right     the right operand of the Cmp\n @param relation  the compare relation"]
    pub fn computed_value_Cmp_Confirm(
        left: *mut ir_node,
        right: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Constructs the entity for a given function using the current compilerlib\n entity creation callback."]
    pub fn create_compilerlib_entity(
        name: *const ::std::os::raw::c_char,
        mt: *mut ir_type,
    ) -> *mut ir_entity;
}
#[doc = "< no constraints"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_NONE: asm_constraint_flags_t = 0;
#[doc = " input/output can be in a register"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_SUPPORTS_REGISTER: asm_constraint_flags_t = 1;
#[doc = " input/output can be read/written to/from a memory address"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_SUPPORTS_MEMOP: asm_constraint_flags_t = 2;
#[doc = " input can be encoded as an immediate number"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_SUPPORTS_IMMEDIATE: asm_constraint_flags_t = 4;
#[doc = " input/output can be in a register, in memory or an immediate"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_SUPPORTS_ANY: asm_constraint_flags_t = 7;
#[doc = " the constraint is not supported yet by libFirm (but valid in gcc)"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_NO_SUPPORT: asm_constraint_flags_t = 8;
#[doc = " The input is also written to"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_MODIFIER_WRITE: asm_constraint_flags_t = 16;
#[doc = " the input is read"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_MODIFIER_READ: asm_constraint_flags_t = 32;
#[doc = " the value is modified before all inputs to the asm block\n are handled."]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_MODIFIER_EARLYCLOBBER: asm_constraint_flags_t =
    64;
#[doc = " This operand and the following operand are commutative"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_MODIFIER_COMMUTATIVE: asm_constraint_flags_t =
    128;
#[doc = " invalid constraint (due to parse error)"]
pub const asm_constraint_flags_t_ASM_CONSTRAINT_FLAG_INVALID: asm_constraint_flags_t = 256;
#[doc = " flags categorizing assembler constraint specifications"]
pub type asm_constraint_flags_t = ::std::os::raw::c_uint;
pub const dwarf_source_language_DW_LANG_C89: dwarf_source_language = 1;
pub const dwarf_source_language_DW_LANG_C: dwarf_source_language = 2;
pub const dwarf_source_language_DW_LANG_Ada83: dwarf_source_language = 3;
pub const dwarf_source_language_DW_LANG_C_plus_plus: dwarf_source_language = 4;
pub const dwarf_source_language_DW_LANG_Cobol74: dwarf_source_language = 5;
pub const dwarf_source_language_DW_LANG_Cobol85: dwarf_source_language = 6;
pub const dwarf_source_language_DW_LANG_Fortran77: dwarf_source_language = 7;
pub const dwarf_source_language_DW_LANG_Fortran90: dwarf_source_language = 8;
pub const dwarf_source_language_DW_LANG_Pascal83: dwarf_source_language = 9;
pub const dwarf_source_language_DW_LANG_Modula2: dwarf_source_language = 10;
pub const dwarf_source_language_DW_LANG_Java: dwarf_source_language = 11;
pub const dwarf_source_language_DW_LANG_C99: dwarf_source_language = 12;
pub const dwarf_source_language_DW_LANG_Ada95: dwarf_source_language = 13;
pub const dwarf_source_language_DW_LANG_Fortran95: dwarf_source_language = 14;
pub const dwarf_source_language_DW_LANG_PLI: dwarf_source_language = 15;
pub const dwarf_source_language_DW_LANG_ObjC: dwarf_source_language = 16;
pub const dwarf_source_language_DW_LANG_ObjC_plus_plus: dwarf_source_language = 17;
pub const dwarf_source_language_DW_LANG_UPC: dwarf_source_language = 18;
pub const dwarf_source_language_DW_LANG_D: dwarf_source_language = 19;
pub const dwarf_source_language_DW_LANG_Python: dwarf_source_language = 20;
pub const dwarf_source_language_DW_LANG_Go: dwarf_source_language = 22;
#[doc = " Dwarf source language codes."]
pub type dwarf_source_language = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Lowers current program for the target architecture.\n This must be run once before using be_main. The idea here is that the backend\n can perform lowerings like doubleword-lowering, ABI adjustments or\n implementation of boolean values, if-conversion, with target specific\n settings.\n The resulting graph is still a \"normal\" firm-graph on which you can and\n should perform further architecture-neutral optimizations before be_main."]
    pub fn be_lower_for_target();
}
pub type after_transform_func = ::std::option::Option<
    unsafe extern "C" fn(irg: *mut ir_graph, name: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " Sets a callback that is called after each transformation step in\n be_lower_for_target(). This is typically used to run dump & verify steps\n to help debugging."]
    pub fn be_set_after_transform_func(func: after_transform_func);
}
extern "C" {
    #[doc = " Main interface to the frontend."]
    pub fn be_main(output: *mut FILE, compilation_unit_name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " parse assembler constraint strings and returns flags (so the frontend knows\n which operands are inputs/outputs and whether memory is required)"]
    pub fn be_parse_asm_constraints(
        constraints: *const ::std::os::raw::c_char,
    ) -> asm_constraint_flags_t;
}
extern "C" {
    #[doc = " tests whether a string is a valid clobber in an ASM instruction"]
    pub fn be_is_valid_clobber(clobber: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets source language for dwarf debug information."]
    pub fn be_dwarf_set_source_language(language: dwarf_source_language);
}
extern "C" {
    #[doc = " Sets working directory of the compiler (or directory where the compiler\n searched for sources) for dwarf debug information."]
    pub fn be_dwarf_set_compilation_directory(directory: *const ::std::os::raw::c_char);
}
#[doc = "< No callgraph allocated."]
pub const irp_callgraph_state_irp_callgraph_none: irp_callgraph_state = 0;
#[doc = "< Callgraph constistent but calltree is inconsistent"]
pub const irp_callgraph_state_irp_callgraph_consistent: irp_callgraph_state = 1;
#[doc = "< Callgraph is allocated but inconsistent."]
pub const irp_callgraph_state_irp_callgraph_inconsistent: irp_callgraph_state = 2;
#[doc = "< Both callgraph and calltree are consistent."]
pub const irp_callgraph_state_irp_callgraph_and_calltree_consistent: irp_callgraph_state = 3;
#[doc = " Flag to indicate state of callgraph."]
pub type irp_callgraph_state = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the callgraph state of the program representation."]
    pub fn get_irp_callgraph_state() -> irp_callgraph_state;
}
extern "C" {
    #[doc = " Sets the callgraph state of the program representation."]
    pub fn set_irp_callgraph_state(s: irp_callgraph_state);
}
extern "C" {
    #[doc = " Returns the number of procedures that call the given irg."]
    pub fn get_irg_n_callers(irg: *const ir_graph) -> usize;
}
extern "C" {
    #[doc = " Returns the caller at position pos."]
    pub fn get_irg_caller(irg: *const ir_graph, pos: usize) -> *mut ir_graph;
}
extern "C" {
    #[doc = " Returns non-zero if the caller at position pos is \"a backedge\", i.e. a recursion."]
    pub fn is_irg_caller_backedge(irg: *const ir_graph, pos: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the irg has a backedge caller."]
    pub fn has_irg_caller_backedge(irg: *const ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the maximal loop depth of call nodes that call along this edge."]
    pub fn get_irg_caller_loop_depth(irg: *const ir_graph, pos: usize) -> usize;
}
extern "C" {
    #[doc = " Returns the number of procedures that are called by the given irg."]
    pub fn get_irg_n_callees(irg: *const ir_graph) -> usize;
}
extern "C" {
    #[doc = " Returns the callee at position pos."]
    pub fn get_irg_callee(irg: *const ir_graph, pos: usize) -> *mut ir_graph;
}
extern "C" {
    #[doc = " Returns non-zero if the callee at position pos is \"a backedge\", i.e. a recursion."]
    pub fn is_irg_callee_backedge(irg: *const ir_graph, pos: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the irg has a backedge callee."]
    pub fn has_irg_callee_backedge(irg: *const ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the maximal loop depth of call nodes that call along this edge."]
    pub fn get_irg_callee_loop_depth(irg: *const ir_graph, pos: usize) -> usize;
}
extern "C" {
    #[doc = " Returns the method execution frequency of a graph."]
    pub fn get_irg_method_execution_frequency(irg: *const ir_graph) -> f64;
}
extern "C" {
    #[doc = " Construct the callgraph. Expects callee information, i.e.,\n irg_callee_info_consistent must be set.  This can be computed with\n cgana()."]
    pub fn compute_callgraph();
}
extern "C" {
    #[doc = " Destruct the callgraph."]
    pub fn free_callgraph();
}
#[doc = " A function type for functions passed to the callgraph walker."]
pub type callgraph_walk_func =
    ::std::option::Option<unsafe extern "C" fn(g: *mut ir_graph, env: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Walks over the callgraph.\n\n Walks over the callgraph, starting at the irp main graph.\n Visits ALL graphs in the irp, even if not reached by the main irg, but for\n those the call order is not guaranteed.\n\n Executes pre before visiting the callees of a node, post after.\n The void* env can be used to pass status information between the\n pre and post functions.\n\n @param pre  - walker function, executed before the predecessor of a node are visited\n @param post - walker function, executed after the predecessor of a node are visited\n @param env  - environment, passed to pre and post"]
    pub fn callgraph_walk(
        pre: callgraph_walk_func,
        post: callgraph_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Compute the backedges that represent recursions and a looptree."]
    pub fn find_callgraph_recursions();
}
extern "C" {
    #[doc = " Computes the interprocedural loop nesting information.\n\n Computes two numbers for each irg:  the depth it is called in 'normal'\n loops and the depth of recursions it is in.\n\n Computes callee info and the callgraph if\n this information is not available.\n\n Expects the main irg is set, see set_irp_main_irg();"]
    pub fn analyse_loop_nesting_depth();
}
#[doc = "< Loop nesting depths are not computed, no memory is\nallocated, access fails."]
pub const loop_nesting_depth_state_loop_nesting_depth_none: loop_nesting_depth_state = 0;
#[doc = "< Loop nesting depth information is computed and correct."]
pub const loop_nesting_depth_state_loop_nesting_depth_consistent: loop_nesting_depth_state = 1;
#[doc = "< Loop nesting depth is computed but the graphs have been\nchanged since."]
pub const loop_nesting_depth_state_loop_nesting_depth_inconsistent: loop_nesting_depth_state = 2;
#[doc = " The state of loop nesting depth."]
pub type loop_nesting_depth_state = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the nesting depth state of the program representation."]
    pub fn get_irp_loop_nesting_depth_state() -> loop_nesting_depth_state;
}
extern "C" {
    #[doc = " Sets the nesting depth state of the program representation."]
    pub fn set_irp_loop_nesting_depth_state(s: loop_nesting_depth_state);
}
extern "C" {
    #[doc = " Marks the nesting depth state of the program representation as inconsistent."]
    pub fn set_irp_loop_nesting_depth_state_inconsistent();
}
extern "C" {
    #[doc = " Computes the control dependence graph for a graph."]
    pub fn compute_cdep(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Frees the control dependence info."]
    pub fn free_cdep(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns control dependent block"]
    pub fn get_cdep_node(cdep: *const ir_cdep) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns next entry in a list of cdeps"]
    pub fn get_cdep_next(cdep: *const ir_cdep) -> *mut ir_cdep;
}
extern "C" {
    #[doc = " Returns a list of all control dependences of a block."]
    pub fn find_cdep(block: *const ir_node) -> *mut ir_cdep;
}
extern "C" {
    #[doc = " Replaces the control dependence info of old by the info of nw."]
    pub fn exchange_cdep(old: *mut ir_node, nw: *const ir_node);
}
extern "C" {
    #[doc = " Checks whether dependee is (directly) control dependent on candidate.\n\n @param dependee   the (possible) dependent block\n @param candidate  the (possible) block on which dependee is dependent"]
    pub fn is_cdep_on(dependee: *const ir_node, candidate: *const ir_node)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If block is control dependent on exactly one node, returns this node,\n else NULL.\n\n @param block  the block to check"]
    pub fn get_unique_cdep(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Checks if the given block is control dependent of more than one node.\n\n @param block   the block to check"]
    pub fn has_multiple_cdep(block: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Analyses a rough estimation of the possible call graph.\n\n  Determines for each Call node the set of possibly called methods.\n  Stores the result in the field 'callees' of the Call node.  If the\n  address can not be analysed, e.g. because it is loaded from a\n  variable, the array contains the unknown_entity. (See\n  set_Call_callee()). cgana() returns the set of 'free' methods, i.e.,\n  the methods that can be called from external or via function\n  pointers.  This data structure must be freed with 'xfree()' by the\n  caller of cgana().\n\n  cgana() sets the callee_info_state of each graph and the program to\n  consistent.\n\n  The algorithm implements roughly Static Class Hierarchy Analysis\n  as described in \"Optimization of Object-Oriented Programs Using\n  Static Class Hierarchy Analysis\" by Jeffrey Dean and David Grove\n  and Craig Chambers.\n\n  Performs some optimizations possible by the analysed information:\n  - Replace (Sel-method(Alloc)) by Address.\n  - Replaces Sel-method by Address if the method is never overwritten."]
    pub fn cgana(free_methods: *mut *mut *mut ir_entity) -> usize;
}
extern "C" {
    #[doc = " Frees callee information.\n\n Sets callee_info_state of the graph passed to none.  Sets callee field\n in all call nodes to NULL.  Else it happens that the field contains\n pointers to other than firm arrays."]
    pub fn free_callee_info(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Frees callee information for all graphs in the current program."]
    pub fn free_irp_callee_info();
}
extern "C" {
    #[doc = " Optimizes the address expressions passed to call nodes.\n Performs only the optimizations done by cgana."]
    pub fn opt_call_addrs();
}
extern "C" {
    #[doc = " Sets, get and remove the callee information for a Call node.\n\n  The callee information lists all method entities that can be called\n  from this node.  If the address expression can not be analyzed fully,\n  e.g., as entities can be called that are not in the compilation unit,\n  the array contains the unknown_entity.  The array contains only entities\n  with peculiarity_existent, but with all kinds of visibility.  The entities\n  not necessarily contain an irg.\n\n  The array is only accessible if callee information is valid.  See flag\n  in graph.\n\n  The memory allocated for the array is managed automatically, i.e., it must\n  not be freed if the Call node is removed from the graph.\n\n  @param node A Call node."]
    pub fn cg_call_has_callees(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of callees of Call node @p node."]
    pub fn cg_get_call_n_callees(node: *const ir_node) -> usize;
}
extern "C" {
    #[doc = " Returns callee number @p pos of Call node @p node."]
    pub fn cg_get_call_callee(node: *const ir_node, pos: usize) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets the full callee array.\n\n  The passed array is copied."]
    pub fn cg_set_call_callee_arr(node: *mut ir_node, n: usize, arr: *mut *mut ir_entity);
}
extern "C" {
    #[doc = " Frees callee array of call node @p node"]
    pub fn cg_remove_call_callee_arr(node: *mut ir_node);
}
pub const dbg_action_dbg_error: dbg_action = 0;
#[doc = "< Optimization of the SSA representation, e.g. removal of superfluent Phi nodes."]
pub const dbg_action_dbg_opt_ssa: dbg_action = 1;
#[doc = "< Removal of unnecessary auxiliary nodes."]
pub const dbg_action_dbg_opt_auxnode: dbg_action = 2;
#[doc = "< A Firm subgraph was evaluated to a single constant."]
pub const dbg_action_dbg_const_eval: dbg_action = 3;
#[doc = "< A Firm node was replaced due to common subexpression elimination."]
pub const dbg_action_dbg_opt_cse: dbg_action = 4;
#[doc = "< A Firm subgraph was replaced by a single, existing block."]
pub const dbg_action_dbg_straightening: dbg_action = 5;
#[doc = "< The control flow of an if is changed as either the\nelse, the then or both blocks are empty."]
pub const dbg_action_dbg_if_simplification: dbg_action = 6;
#[doc = "< A Firm subgraph was replaced because of an algebraic\nsimplification."]
pub const dbg_action_dbg_algebraic_simplification: dbg_action = 7;
#[doc = "< A Firm subgraph was replaced because of a write\nafter write optimization."]
pub const dbg_action_dbg_write_after_write: dbg_action = 8;
#[doc = "< A Firm subgraph was replaced because of a write\nafter read optimization."]
pub const dbg_action_dbg_write_after_read: dbg_action = 9;
#[doc = "< A Firm subgraph was replaced because of a read\nafter write optimization."]
pub const dbg_action_dbg_read_after_write: dbg_action = 10;
#[doc = "< A Firm subgraph was replaced because of a read\nafter read optimization."]
pub const dbg_action_dbg_read_after_read: dbg_action = 11;
#[doc = "< A Firm subgraph was replaced because of a read\na constant optimization."]
pub const dbg_action_dbg_read_a_const: dbg_action = 12;
#[doc = "< Removing unreachable code, i.e. blocks that are never executed."]
pub const dbg_action_dbg_dead_code: dbg_action = 13;
#[doc = "< A Firm subgraph was replace because of a Confirmation."]
pub const dbg_action_dbg_opt_confirm: dbg_action = 14;
#[doc = "< A Firm node was replace because of the GVN-PRE algorithm."]
pub const dbg_action_dbg_gvn_pre: dbg_action = 15;
#[doc = "< A Firm node was replace because of the combo algorithm."]
pub const dbg_action_dbg_combo: dbg_action = 16;
#[doc = "< A Firm node was replace because of the jumpthreading algorithm."]
pub const dbg_action_dbg_jumpthreading: dbg_action = 17;
#[doc = "< A Firm subgraph was replaced because of a Backend transformation"]
pub const dbg_action_dbg_backend: dbg_action = 18;
#[doc = "< Maximum value."]
pub const dbg_action_dbg_max: dbg_action = 19;
#[doc = " An enumeration indicating the action performed by a transformation."]
pub type dbg_action = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Converts a debug_action into a string.\n\n @param a  the debug action"]
    pub fn dbg_action_2_str(a: dbg_action) -> *const ::std::os::raw::c_char;
}
#[doc = " The type of the debug info merge function.\n\n @param new_node    the new ir node\n @param old_node    the old ir node\n @param action      the action that triggers the merge\n\n @see dbg_init()"]
pub type merge_pair_func = ::std::option::Option<
    unsafe extern "C" fn(new_node: *mut ir_node, old_node: *mut ir_node, action: dbg_action),
>;
#[doc = " The type of the debug info merge sets function.\n\n @param new_node_array    array of new nodes\n @param new_num_entries   number of entries in new_node_array\n @param old_node_array    array of old nodes\n @param old_num_entries   number of entries in old_node_array\n @param action            the action that triggers the merge\n\n @see dbg_init()"]
pub type merge_sets_func = ::std::option::Option<
    unsafe extern "C" fn(
        new_node_array: *const *mut ir_node,
        new_num_entries: ::std::os::raw::c_int,
        old_node_array: *const *mut ir_node,
        old_num_entries: ::std::os::raw::c_int,
        action: dbg_action,
    ),
>;
extern "C" {
    #[doc = "  Initializes the debug support.\n\n  This function takes pointers to two functions that merge the\n  debug information when a\n  transformation of a Firm graph is performed.\n  Firm transformations call one of these functions.\n\n   - dbg_info_merge_pair() is called in the following situation:\n     The optimization replaced the old node by the new one.  The new node\n     might be a recent allocated node not containing any debug information,\n     or just another node from somewhere in the graph with the same\n     semantics.\n   - dbg_info_merge_sets() is called in the following situation:\n     The optimization replaced a subgraph by another subgraph.  There is no\n     obviously mapping between single nodes in both subgraphs.  The optimization\n     simply passes two lists to the debug module, one containing the nodes in\n     the old subgraph, the other containing the nodes in the new subgraph.\n     The same node can be in both lists.\n\n   Further both functions pass an enumeration indicating the action\n   performed by the transformation, e.g. the kind of optimization performed."]
    pub fn dbg_init(dbg_info_merge_pair: merge_pair_func, dbg_info_merge_sets: merge_sets_func);
}
#[doc = " A sourcecode location"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct src_loc_t {
    #[doc = "< the name of the source (usually a file)"]
    pub file: *const ::std::os::raw::c_char,
    #[doc = "< line number (starting at 1; 0 if unknown)"]
    pub line: ::std::os::raw::c_uint,
    #[doc = "< column number (starting at 1; 0 if unknown)"]
    pub column: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_src_loc_t() {
    const UNINIT: ::std::mem::MaybeUninit<src_loc_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<src_loc_t>(),
        16usize,
        concat!("Size of: ", stringify!(src_loc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<src_loc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(src_loc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(src_loc_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(src_loc_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(src_loc_t),
            "::",
            stringify!(column)
        )
    );
}
#[doc = " The type of the debug info retriever function.\n  When given a dbg_info returns the name (usually the filename), line number\n  and column number of the definition.\n  Any part of the returned information may be NULL/0, which means it is not\n  available."]
pub type retrieve_dbg_func =
    ::std::option::Option<unsafe extern "C" fn(dbg: *const dbg_info) -> src_loc_t>;
extern "C" {
    #[doc = " Sets a debug info retriever.\n\n @param func   the debug retriever function."]
    pub fn ir_set_debug_retrieve(func: retrieve_dbg_func);
}
#[doc = " The type of the type debug info retrieve function.\n Prints a human readable source representation of a type to a buffer.\n  (Used for generating debug info like stabs or dwarf)"]
pub type retrieve_type_dbg_func = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        tdbgi: *const type_dbg_info,
    ),
>;
extern "C" {
    #[doc = " Sets global print_type_dbg_info function in firm"]
    pub fn ir_set_type_debug_retrieve(func: retrieve_type_dbg_func);
}
extern "C" {
    #[doc = " Retrieve the debug info."]
    pub fn ir_retrieve_dbg_info(dbg: *const dbg_info) -> src_loc_t;
}
extern "C" {
    #[doc = " Retrieve type debug info"]
    pub fn ir_retrieve_type_dbg_info(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        tdbgi: *const type_dbg_info,
    );
}
extern "C" {
    #[doc = " Estimates execution frequency of a graph.\n You can query the frequencies with get_block_execfreq()."]
    pub fn ir_estimate_execfreq(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns execution frequency of block @p block."]
    pub fn get_block_execfreq(block: *const ir_node) -> f64;
}
extern "C" {
    #[doc = " Initializes the firm library and prepares code generation for the host.\n\n This is a convenince function that does:\n\n     ir_init_library();\n     ir_target_set_triple(ir_get_host_machine_triple());\n     ir_target_init();"]
    pub fn ir_init();
}
extern "C" {
    #[doc = " Initializes the firm library but does not prepare for any code generation.\n This is typically followed by target initialization (\\see target,\n ir_target_set(), ir_target_set_triple(), ir_target_init()) to get mode_P\n defined, a number of transformations also depend on target information being\n available."]
    pub fn ir_init_library();
}
extern "C" {
    #[doc = " Frees all memory occupied by the firm library."]
    pub fn ir_finish();
}
extern "C" {
    #[doc = " returns the libFirm major version number"]
    pub fn ir_get_version_major() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns libFirm minor version number"]
    pub fn ir_get_version_minor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns libFirm micro version number"]
    pub fn ir_get_version_micro() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns string describing libFirm revision"]
    pub fn ir_get_version_revision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns string describing libFirm build"]
    pub fn ir_get_version_build() -> *const ::std::os::raw::c_char;
}
#[doc = "< An invalid firm node."]
pub const firm_kind_k_BAD: firm_kind = 0;
#[doc = "< An entity."]
pub const firm_kind_k_entity: firm_kind = 1;
#[doc = "< A type."]
pub const firm_kind_k_type: firm_kind = 2;
#[doc = "< An IR graph."]
pub const firm_kind_k_ir_graph: firm_kind = 3;
#[doc = "< An IR node."]
pub const firm_kind_k_ir_node: firm_kind = 4;
#[doc = "< An IR mode."]
pub const firm_kind_k_ir_mode: firm_kind = 5;
#[doc = "< A tarval."]
pub const firm_kind_k_tarval: firm_kind = 6;
#[doc = "< A loop."]
pub const firm_kind_k_ir_loop: firm_kind = 7;
#[doc = "< maximum value -- illegal for firm nodes."]
pub const firm_kind_k_ir_max: firm_kind = 8;
#[doc = " A list of firm kinds.\n Most important data structures in firm contain a firm_kind field at the\n beginning so given void* pointer you can usually still guess the kind\n of thing the pointer points to.\n This is used in debug helper functions and printers."]
pub type firm_kind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the kind of a thing.\n\n @param firm_thing  pointer representing a firm object"]
    pub fn get_kind(firm_thing: *const ::std::os::raw::c_void) -> firm_kind;
}
extern "C" {
    #[doc = " Returns the height of a node inside a basic block.\n The height of the node is the maximal number of edges between a sink node in\n that block and the node itself (plus 1).\n @param h    The heights object.\n @param irn  The node.\n @return     The height of the node."]
    pub fn get_irn_height(h: *const ir_heights_t, irn: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Checks if the node @p tgt is reachable according to data dependence edges\n from the node @p src. Both nodes must be in the same block.\n @param h   The heights object.\n @param src The source node of a possible path.\n @param tgt The target node of a possible path.\n @return    1, if src is data dependent on tgt, 0 if not."]
    pub fn heights_reachable_in_block(
        h: *mut ir_heights_t,
        src: *const ir_node,
        tgt: *const ir_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Recomputes the height information for a certain block.\n This can be used to recompute the height information of a block.\n @param h     The heights object.\n @param block The block\n @return The maximum over all heights in the block."]
    pub fn heights_recompute_block(
        h: *mut ir_heights_t,
        block: *mut ir_node,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Creates a new heights object. This also computes the heights for each block\n in the graph.\n @param irg The graph."]
    pub fn heights_new(irg: *mut ir_graph) -> *mut ir_heights_t;
}
extern "C" {
    #[doc = " Frees a heights object.\n @param h The heights object."]
    pub fn heights_free(h: *mut ir_heights_t);
}
extern "C" {
    #[doc = "  Store a string and create an ident.\n\n  Stores a string in the ident module and returns a handle for the string.\n\n  Copies the string. @p str must be zero terminated\n\n @param str   the string which shall be stored\n @return id   a handle for the generated ident"]
    pub fn new_id_from_str(str_: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Store a string and create an ident.\n\n Stores a string in the ident module and returns a handle for the string.\n Copies the string. This version takes non-zero-terminated strings.\n\n @param str   the string (or whatever) which shall be stored\n @param len   the length of the data in bytes\n @return id   a handle for the generated ident"]
    pub fn new_id_from_chars(
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create an ident from a format string.\n\n @return a handle for the generated ident"]
    pub fn new_id_fmt(fmt: *const ::std::os::raw::c_char, ...) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a string represented by an ident.\n\n Returns the string represented by id. This string is\n NULL terminated. The string may not be changed.\n\n @param id   the ident\n @return cp   a string"]
    pub fn get_id_str(id: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " helper function for creating unique idents. It contains an internal counter\n and appends it separated by a dot to the given tag."]
    pub fn id_unique(tag: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Removes all methods which are not reachable from \"keep_arr\".\n\n Frees all interprocedural loop information."]
    pub fn gc_irgs(n_keep: usize, keep_arr: *mut *mut ir_entity);
}
pub const op_arity_oparity_invalid: op_arity = 0;
#[doc = "< A binary operator  -- considering 'numeric' arguments."]
pub const op_arity_oparity_binary: op_arity = 1;
#[doc = "< The arity depends on state of Firm representation.\nCan be changed by optimizations...\nWe must allocate a dynamic in array for the node!"]
pub const op_arity_oparity_dynamic: op_arity = 2;
#[doc = " Any other arity, either fixed for the opcode or known when creating the node."]
pub const op_arity_oparity_any: op_arity = 3;
#[doc = " The allowed arities."]
pub type op_arity = ::std::os::raw::c_uint;
#[doc = "< Nothing."]
pub const irop_flags_irop_flag_none: irop_flags = 0;
#[doc = "< This operation is commutative."]
pub const irop_flags_irop_flag_commutative: irop_flags = 1;
#[doc = "< This operation is a control flow operation."]
pub const irop_flags_irop_flag_cfopcode: irop_flags = 2;
#[doc = "< Set if the operation can change the\ncontrol flow because of an exception."]
pub const irop_flags_irop_flag_fragile: irop_flags = 4;
#[doc = "< Forking control flow at this operation."]
pub const irop_flags_irop_flag_forking: irop_flags = 8;
#[doc = "< This operation has no arguments and is some\nkind of a constant."]
pub const irop_flags_irop_flag_constlike: irop_flags = 32;
#[doc = "< This operation can be kept in End's keep-alive list."]
pub const irop_flags_irop_flag_keep: irop_flags = 64;
#[doc = "< This operation is always placed in the Start block."]
pub const irop_flags_irop_flag_start_block: irop_flags = 128;
#[doc = "< This operation has a memory input and may change the memory state."]
pub const irop_flags_irop_flag_uses_memory: irop_flags = 256;
#[doc = "< node should be dumped outside any blocks"]
pub const irop_flags_irop_flag_dump_noblock: irop_flags = 512;
#[doc = " This operation jumps to an unknown destination. The CFG is a\n conservative approximation in this case. You cannot change the destination\n of an unknown_jump"]
pub const irop_flags_irop_flag_unknown_jump: irop_flags = 2048;
#[doc = " The opcode has a memory input/output but does not actually change the\n contents of any memory block known to the program. The input/output is\n just necessary for scheduling reasons. Implies irop_flag_uses_memory."]
pub const irop_flags_irop_flag_const_memory: irop_flags = 4096;
#[doc = " The irop flags"]
pub type irop_flags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the string for the opcode."]
    pub fn get_op_name(op: *const ir_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the enum for the opcode"]
    pub fn get_op_code(op: *const ir_op) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns a human readable name of an op_pin_state."]
    pub fn get_op_pin_state_name(s: op_pin_state) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns pinned state of an opcode."]
    pub fn get_op_pinned(op: *const ir_op) -> op_pin_state;
}
extern "C" {
    #[doc = " Returns the next free IR opcode number, allows to register user ops."]
    pub fn get_next_ir_opcode() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the next free n IR opcode number, allows to register a bunch of user ops."]
    pub fn get_next_ir_opcodes(num: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
#[doc = " A generic function pointer type."]
pub type op_func = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " Returns the generic function pointer from an IR operation."]
    pub fn get_generic_function_ptr(op: *const ir_op) -> op_func;
}
extern "C" {
    #[doc = " Stores a generic function pointer into an IR operation."]
    pub fn set_generic_function_ptr(op: *mut ir_op, func: op_func);
}
extern "C" {
    #[doc = " Returns the irop flags of an IR opcode."]
    pub fn get_op_flags(op: *const ir_op) -> irop_flags;
}
#[doc = " The hash operation.\n This operation calculates a hash value for a given IR node."]
pub type hash_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> ::std::os::raw::c_uint>;
#[doc = " The compute value operation.\n If a node is known to always produce a specific value, this value is\n returned, if it is known to always throw an exception or produce undefined\n behaviour (like division by zero) tarval_bad is returned, otherwise\n tarval_unknown is returned."]
pub type computed_value_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> *mut ir_tarval>;
#[doc = " The equivalent node operation.\n This operation returns an equivalent node for the input node.\n It does not create new nodes.  It is therefore safe to free self\n if the node returned is not self.\n If a node returns a Tuple we can not just skip it.  If the size of the\n in array fits, we transform n into a tuple (e.g., possible for Div)."]
pub type equivalent_node_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ir_node) -> *mut ir_node>;
#[doc = " The transform node operation.\n This operation tries several [inplace] [optimizing] transformations\n and returns an equivalent node.\n The difference to equivalent_node() is that these\n transformations _do_ generate new nodes, and thus the old node must\n not be freed even if the equivalent node isn't the old one."]
pub type transform_node_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ir_node) -> *mut ir_node>;
#[doc = " The node attribute compare operation.\n Compares the nodes attributes of two nodes of identical opcode\n and returns 1 if the attributes are identical, 0 if they differ."]
pub type node_attrs_equal_func = ::std::option::Option<
    unsafe extern "C" fn(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int,
>;
#[doc = " The reassociation operation.\n Called from a walker.  Returns non-zero if\n a reassociation rule was applied.\n The pointer n is set to the newly created node, if some reassociation\n was applied."]
pub type reassociate_func =
    ::std::option::Option<unsafe extern "C" fn(n: *mut *mut ir_node) -> ::std::os::raw::c_int>;
#[doc = " The copy attribute operation.\n Copy the node attributes from an 'old' node to a 'new' one."]
pub type copy_attr_func = ::std::option::Option<
    unsafe extern "C" fn(irg: *mut ir_graph, old_node: *const ir_node, new_node: *mut ir_node),
>;
#[doc = " The get_type_attr operation. Used to traverse all types that can be\n accessed from an ir_graph.\n Returns the type attribute of the node self."]
pub type get_type_attr_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> *mut ir_type>;
#[doc = " The get_entity_attr operation. Used to traverse all entities that can be\n accessed from an ir_graph.\n Returns the entity attribute of the node self."]
pub type get_entity_attr_func =
    ::std::option::Option<unsafe extern "C" fn(self_: *const ir_node) -> *mut ir_entity>;
#[doc = " The verify_node operation.\n Returns non-zero if the node verification is ok, else 0.\n Depending on the node verification settings, may even assert.\n\n @see do_node_verification()"]
pub type verify_node_func =
    ::std::option::Option<unsafe extern "C" fn(node: *const ir_node) -> ::std::os::raw::c_int>;
#[doc = " The verify_node operation for Proj(X).\n Returns non-zero if the node verification is ok, else 0.\n Depending on the node verification settings, may even assert.\n\n @see do_node_verification()"]
pub type verify_proj_node_func =
    ::std::option::Option<unsafe extern "C" fn(proj: *const ir_node) -> ::std::os::raw::c_int>;
#[doc = "< Dump the opcode."]
pub const dump_reason_t_dump_node_opcode_txt: dump_reason_t = 0;
#[doc = "< Dump the mode."]
pub const dump_reason_t_dump_node_mode_txt: dump_reason_t = 1;
#[doc = "< Dump node attributes to be shown in the label."]
pub const dump_reason_t_dump_node_nodeattr_txt: dump_reason_t = 2;
#[doc = "< Dump node attributes into info1."]
pub const dump_reason_t_dump_node_info_txt: dump_reason_t = 3;
#[doc = " Reasons to call the dump_node operation:"]
pub type dump_reason_t = ::std::os::raw::c_uint;
#[doc = " The dump_node operation.\n Writes several informations requested by reason to\n an output file"]
pub type dump_node_func = ::std::option::Option<
    unsafe extern "C" fn(out: *mut FILE, self_: *const ir_node, reason: dump_reason_t),
>;
extern "C" {
    #[doc = " Sets hash callback @p func for operation @p op"]
    pub fn set_op_hash(op: *mut ir_op, func: hash_func);
}
extern "C" {
    #[doc = " Sets computed_value callback @p func for operation @p op"]
    pub fn set_op_computed_value(op: *mut ir_op, func: computed_value_func);
}
extern "C" {
    #[doc = " Sets compute_value for Proj callback @p func for operation @p op"]
    pub fn set_op_computed_value_proj(op: *mut ir_op, func: computed_value_func);
}
extern "C" {
    #[doc = " Sets equivalent node callback @p func for operation @p op"]
    pub fn set_op_equivalent_node(op: *mut ir_op, func: equivalent_node_func);
}
extern "C" {
    #[doc = " Sets equivalent Proj node callback @p func for operation @p op"]
    pub fn set_op_equivalent_node_proj(op: *mut ir_op, func: equivalent_node_func);
}
extern "C" {
    #[doc = " Sets transform node callback @p func for operation @p op"]
    pub fn set_op_transform_node(op: *mut ir_op, func: transform_node_func);
}
extern "C" {
    #[doc = " Sets transform Proj node callback @p func for operation @p op"]
    pub fn set_op_transform_node_proj(op: *mut ir_op, func: transform_node_func);
}
extern "C" {
    #[doc = " Sets attrs_equal callback @p func for operation @p op"]
    pub fn set_op_attrs_equal(op: *mut ir_op, func: node_attrs_equal_func);
}
extern "C" {
    #[doc = " Sets reassociation callback @p func for operation @p op"]
    pub fn set_op_reassociate(op: *mut ir_op, func: reassociate_func);
}
extern "C" {
    #[doc = " Sets attribute copy callback @p func for operation @p op"]
    pub fn set_op_copy_attr(op: *mut ir_op, func: copy_attr_func);
}
extern "C" {
    #[doc = " Sets get type callback @p func for operation @p op"]
    pub fn set_op_get_type_attr(op: *mut ir_op, func: get_type_attr_func);
}
extern "C" {
    #[doc = " Sets get entity callback @p func for operation @p op"]
    pub fn set_op_get_entity_attr(op: *mut ir_op, func: get_entity_attr_func);
}
extern "C" {
    #[doc = " Sets verify callback @p func for operation @p op"]
    pub fn set_op_verify(op: *mut ir_op, func: verify_node_func);
}
extern "C" {
    #[doc = " Sets proj verify callback @p func for operation @p op"]
    pub fn set_op_verify_proj(op: *mut ir_op, func: verify_proj_node_func);
}
extern "C" {
    #[doc = " Sets dump callback @p func for operation @p op"]
    pub fn set_op_dump(op: *mut ir_op, func: dump_node_func);
}
extern "C" {
    #[doc = " Creates a new IR operation.\n\n @param code      the opcode, one of type \\c opcode\n @param name      the printable name of this opcode\n @param p         whether operations of this opcode are op_pin_state_pinned or floating\n @param flags     a bitmask of irop_flags describing the behavior of the IR operation\n @param opar      the parity of this IR operation\n @param op_index  if the parity is oparity_unary, oparity_binary or oparity_trinary the index\n                  of the left operand\n @param attr_size attribute size for this IR operation\n\n @return The generated IR operation.\n\n This function can create all standard Firm opcode as well as new ones.\n The behavior of new opcode depends on the operations \\c ops and the \\c flags."]
    pub fn new_ir_op(
        code: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        p: op_pin_state,
        flags: irop_flags,
        opar: op_arity,
        op_index: ::std::os::raw::c_int,
        attr_size: usize,
    ) -> *mut ir_op;
}
extern "C" {
    #[doc = " Frees an ir operation.\n\n Obviously nodes with this op mustn't exist at this point."]
    pub fn free_ir_op(code: *mut ir_op);
}
extern "C" {
    #[doc = " Returns one more than the highest opcode code in use."]
    pub fn ir_get_n_opcodes() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the opcode with code @p code.\n\n @p code has to be smaller than get_irp_n_opcode(), returns NULL if\n no opcode with the code exists."]
    pub fn ir_get_opcode(code: ::std::os::raw::c_uint) -> *mut ir_op;
}
extern "C" {
    #[doc = " Sets the generic function pointer of all opcodes to NULL"]
    pub fn ir_clear_opcodes_generic_func();
}
extern "C" {
    #[doc = " Sets memory input of operation using memory"]
    pub fn ir_op_set_memory_index(op: *mut ir_op, memory_index: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sets proj-number for X_regular and X_except projs of fragile nodes.\n Note: should only be used immediately after new_ir_op"]
    pub fn ir_op_set_fragile_indices(
        op: *mut ir_op,
        pn_x_regular: ::std::os::raw::c_uint,
        pn_x_except: ::std::os::raw::c_uint,
    );
}
pub const ir_opcode_iro_ASM: ir_opcode = 0;
pub const ir_opcode_iro_Add: ir_opcode = 1;
pub const ir_opcode_iro_Address: ir_opcode = 2;
pub const ir_opcode_iro_Align: ir_opcode = 3;
pub const ir_opcode_iro_Alloc: ir_opcode = 4;
pub const ir_opcode_iro_Anchor: ir_opcode = 5;
pub const ir_opcode_iro_And: ir_opcode = 6;
pub const ir_opcode_iro_Bad: ir_opcode = 7;
pub const ir_opcode_iro_Bitcast: ir_opcode = 8;
pub const ir_opcode_iro_Block: ir_opcode = 9;
pub const ir_opcode_iro_Builtin: ir_opcode = 10;
pub const ir_opcode_iro_Call: ir_opcode = 11;
pub const ir_opcode_iro_Cmp: ir_opcode = 12;
pub const ir_opcode_iro_Cond: ir_opcode = 13;
pub const ir_opcode_iro_Confirm: ir_opcode = 14;
pub const ir_opcode_iro_Const: ir_opcode = 15;
pub const ir_opcode_iro_Conv: ir_opcode = 16;
pub const ir_opcode_iro_CopyB: ir_opcode = 17;
pub const ir_opcode_iro_Deleted: ir_opcode = 18;
pub const ir_opcode_iro_Div: ir_opcode = 19;
pub const ir_opcode_iro_Dummy: ir_opcode = 20;
pub const ir_opcode_iro_End: ir_opcode = 21;
pub const ir_opcode_iro_Eor: ir_opcode = 22;
pub const ir_opcode_iro_Free: ir_opcode = 23;
pub const ir_opcode_iro_IJmp: ir_opcode = 24;
pub const ir_opcode_iro_Id: ir_opcode = 25;
pub const ir_opcode_iro_Jmp: ir_opcode = 26;
pub const ir_opcode_iro_Load: ir_opcode = 27;
pub const ir_opcode_iro_Member: ir_opcode = 28;
pub const ir_opcode_iro_Minus: ir_opcode = 29;
pub const ir_opcode_iro_Mod: ir_opcode = 30;
pub const ir_opcode_iro_Mul: ir_opcode = 31;
pub const ir_opcode_iro_Mulh: ir_opcode = 32;
pub const ir_opcode_iro_Mux: ir_opcode = 33;
pub const ir_opcode_iro_NoMem: ir_opcode = 34;
pub const ir_opcode_iro_Not: ir_opcode = 35;
pub const ir_opcode_iro_Offset: ir_opcode = 36;
pub const ir_opcode_iro_Or: ir_opcode = 37;
pub const ir_opcode_iro_Phi: ir_opcode = 38;
pub const ir_opcode_iro_Pin: ir_opcode = 39;
pub const ir_opcode_iro_Proj: ir_opcode = 40;
pub const ir_opcode_iro_Raise: ir_opcode = 41;
pub const ir_opcode_iro_Return: ir_opcode = 42;
pub const ir_opcode_iro_Sel: ir_opcode = 43;
pub const ir_opcode_iro_Shl: ir_opcode = 44;
pub const ir_opcode_iro_Shr: ir_opcode = 45;
pub const ir_opcode_iro_Shrs: ir_opcode = 46;
pub const ir_opcode_iro_Size: ir_opcode = 47;
pub const ir_opcode_iro_Start: ir_opcode = 48;
pub const ir_opcode_iro_Store: ir_opcode = 49;
pub const ir_opcode_iro_Sub: ir_opcode = 50;
pub const ir_opcode_iro_Switch: ir_opcode = 51;
pub const ir_opcode_iro_Sync: ir_opcode = 52;
pub const ir_opcode_iro_Tuple: ir_opcode = 53;
pub const ir_opcode_iro_Unknown: ir_opcode = 54;
pub const ir_opcode_iro_first: ir_opcode = 0;
pub const ir_opcode_iro_last: ir_opcode = 54;
#[doc = " The opcodes of the libFirm predefined operations.\n @ingroup ir_op"]
pub type ir_opcode = ::std::os::raw::c_uint;
#[doc = "< memory dependency"]
pub const n_ASM_n_ASM_mem: n_ASM = 0;
pub const n_ASM_n_ASM_max: n_ASM = 0;
#[doc = " Input numbers for ASM node"]
pub type n_ASM = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_ASM_pn_ASM_M: pn_ASM = 0;
#[doc = "< control flow when no jump occurs"]
pub const pn_ASM_pn_ASM_X_regular: pn_ASM = 1;
#[doc = "< first output"]
pub const pn_ASM_pn_ASM_first_out: pn_ASM = 2;
pub const pn_ASM_pn_ASM_max: pn_ASM = 2;
#[doc = " Projection numbers for result of ASM node (use for Proj nodes)"]
pub type pn_ASM = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct an ASM node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param text      assembler text\n @param n_constraints number of constraints\n @param constraints constraints\n @param n_clobbers number of clobbered registers/memory\n @param clobbers  list of clobbered registers/memory\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_rd_ASM(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        text: *const ::std::os::raw::c_char,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobbers: usize,
        clobbers: *mut *const ::std::os::raw::c_char,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an ASM node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param text      assembler text\n @param n_constraints number of constraints\n @param constraints constraints\n @param n_clobbers number of clobbered registers/memory\n @param clobbers  list of clobbered registers/memory\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_r_ASM(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        text: *const ::std::os::raw::c_char,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobbers: usize,
        clobbers: *mut *const ::std::os::raw::c_char,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an ASM node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param text      assembler text\n @param n_constraints number of constraints\n @param constraints constraints\n @param n_clobbers number of clobbered registers/memory\n @param clobbers  list of clobbered registers/memory\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_d_ASM(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        text: *const ::std::os::raw::c_char,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobbers: usize,
        clobbers: *mut *const ::std::os::raw::c_char,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an ASM node.\n\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param text      assembler text\n @param n_constraints number of constraints\n @param constraints constraints\n @param n_clobbers number of clobbered registers/memory\n @param clobbers  list of clobbered registers/memory\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_ASM(
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        text: *const ::std::os::raw::c_char,
        n_constraints: usize,
        constraints: *mut ir_asm_constraint,
        n_clobbers: usize,
        clobbers: *mut *const ::std::os::raw::c_char,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a ASM\n @returns 1 if the node is a ASM node, 0 otherwise"]
    pub fn is_ASM(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of an ASM node."]
    pub fn get_ASM_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of an ASM node."]
    pub fn set_ASM_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Get the number of ASM inputs."]
    pub fn get_ASM_n_inputs(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the ASM input with index @p pos."]
    pub fn get_ASM_input(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the ASM input with index @p pos."]
    pub fn set_ASM_input(node: *mut ir_node, pos: ::std::os::raw::c_int, input: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all ASM inputs."]
    pub fn get_ASM_input_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Returns constraints attribute of an ASM node."]
    pub fn get_ASM_constraints(node: *const ir_node) -> *mut ir_asm_constraint;
}
extern "C" {
    #[doc = " Sets constraints attribute of an ASM node."]
    pub fn set_ASM_constraints(node: *mut ir_node, constraints: *mut ir_asm_constraint);
}
extern "C" {
    #[doc = " Returns clobbers attribute of an ASM node."]
    pub fn get_ASM_clobbers(node: *const ir_node) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets clobbers attribute of an ASM node."]
    pub fn set_ASM_clobbers(node: *mut ir_node, clobbers: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns text attribute of an ASM node."]
    pub fn get_ASM_text(node: *const ir_node) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets text attribute of an ASM node."]
    pub fn set_ASM_text(node: *mut ir_node, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " ASM opcode"]
    pub static mut op_ASM: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for ASM nodes."]
    pub fn get_op_ASM() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Add_n_Add_left: n_Add = 0;
#[doc = "< second operand"]
pub const n_Add_n_Add_right: n_Add = 1;
pub const n_Add_n_Add_max: n_Add = 1;
#[doc = " Input numbers for Add node"]
pub type n_Add = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct an Add node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Add(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Add node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Add(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Add node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Add(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Add node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Add(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Add\n @returns 1 if the node is a Add node, 0 otherwise"]
    pub fn is_Add(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of an Add node."]
    pub fn get_Add_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of an Add node."]
    pub fn set_Add_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of an Add node."]
    pub fn get_Add_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of an Add node."]
    pub fn set_Add_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Add opcode"]
    pub static mut op_Add: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Add nodes."]
    pub fn get_op_Add() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct an Address node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param entity    entity to operate on"]
    pub fn new_rd_Address(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Address node.\n\n @param irg       The IR graph the node belongs to.\n @param entity    entity to operate on"]
    pub fn new_r_Address(irg: *mut ir_graph, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Address node.\n\n @param dbgi      A pointer to debug information.\n @param entity    entity to operate on"]
    pub fn new_d_Address(dbgi: *mut dbg_info, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Address node.\n\n @param entity    entity to operate on"]
    pub fn new_Address(entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Address\n @returns 1 if the node is a Address node, 0 otherwise"]
    pub fn is_Address(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns entity attribute of an Address node."]
    pub fn get_Address_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets entity attribute of an Address node."]
    pub fn set_Address_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[doc = " Address opcode"]
    pub static mut op_Address: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Address nodes."]
    pub fn get_op_Address() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct an Align node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_rd_Align(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Align node.\n\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_r_Align(irg: *mut ir_graph, mode: *mut ir_mode, type_: *mut ir_type)
        -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Align node.\n\n @param dbgi      A pointer to debug information.\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_d_Align(
        dbgi: *mut dbg_info,
        mode: *mut ir_mode,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Align node.\n\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_Align(mode: *mut ir_mode, type_: *mut ir_type) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Align\n @returns 1 if the node is a Align node, 0 otherwise"]
    pub fn is_Align(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns type attribute of an Align node."]
    pub fn get_Align_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of an Align node."]
    pub fn set_Align_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Align opcode"]
    pub static mut op_Align: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Align nodes."]
    pub fn get_op_Align() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Alloc_n_Alloc_mem: n_Alloc = 0;
#[doc = "< size of the block in bytes"]
pub const n_Alloc_n_Alloc_size: n_Alloc = 1;
pub const n_Alloc_n_Alloc_max: n_Alloc = 1;
#[doc = " Input numbers for Alloc node"]
pub type n_Alloc = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Alloc_pn_Alloc_M: pn_Alloc = 0;
#[doc = "< pointer to newly allocated memory"]
pub const pn_Alloc_pn_Alloc_res: pn_Alloc = 1;
pub const pn_Alloc_pn_Alloc_max: pn_Alloc = 1;
#[doc = " Projection numbers for result of Alloc node (use for Proj nodes)"]
pub type pn_Alloc = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct an Alloc node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_size  size\n @param alignment alignment of the memory block (must be a power of 2)"]
    pub fn new_rd_Alloc(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Alloc node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_size  size\n @param alignment alignment of the memory block (must be a power of 2)"]
    pub fn new_r_Alloc(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Alloc node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_size  size\n @param alignment alignment of the memory block (must be a power of 2)"]
    pub fn new_d_Alloc(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Alloc node.\n\n @param irn_mem   mem\n @param irn_size  size\n @param alignment alignment of the memory block (must be a power of 2)"]
    pub fn new_Alloc(
        irn_mem: *mut ir_node,
        irn_size: *mut ir_node,
        alignment: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Alloc\n @returns 1 if the node is a Alloc node, 0 otherwise"]
    pub fn is_Alloc(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of an Alloc node."]
    pub fn get_Alloc_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of an Alloc node."]
    pub fn set_Alloc_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns size input of an Alloc node."]
    pub fn get_Alloc_size(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets size input of an Alloc node."]
    pub fn set_Alloc_size(node: *mut ir_node, size: *mut ir_node);
}
extern "C" {
    #[doc = " Returns alignment attribute of an Alloc node."]
    pub fn get_Alloc_alignment(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets alignment attribute of an Alloc node."]
    pub fn set_Alloc_alignment(node: *mut ir_node, alignment: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Alloc opcode"]
    pub static mut op_Alloc: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Alloc nodes."]
    pub fn get_op_Alloc() -> *mut ir_op;
}
#[doc = "< block the end node belongs to"]
pub const n_Anchor_n_Anchor_end_block: n_Anchor = 0;
#[doc = "< block the start node belongs to"]
pub const n_Anchor_n_Anchor_start_block: n_Anchor = 1;
#[doc = "< end node of this ir_graph"]
pub const n_Anchor_n_Anchor_end: n_Anchor = 2;
#[doc = "< start node of this ir_graph"]
pub const n_Anchor_n_Anchor_start: n_Anchor = 3;
#[doc = "< frame of this ir_graph"]
pub const n_Anchor_n_Anchor_frame: n_Anchor = 4;
#[doc = "< initial memory of this ir_graph"]
pub const n_Anchor_n_Anchor_initial_mem: n_Anchor = 5;
#[doc = "< argument proj of the start node"]
pub const n_Anchor_n_Anchor_args: n_Anchor = 6;
#[doc = "< the only NoMem node of this ir_graph"]
pub const n_Anchor_n_Anchor_no_mem: n_Anchor = 7;
pub const n_Anchor_n_Anchor_max: n_Anchor = 7;
#[doc = " Input numbers for Anchor node"]
pub type n_Anchor = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Test if node is a Anchor\n @returns 1 if the node is a Anchor node, 0 otherwise"]
    pub fn is_Anchor(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns end_block input of an Anchor node."]
    pub fn get_Anchor_end_block(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets end_block input of an Anchor node."]
    pub fn set_Anchor_end_block(node: *mut ir_node, end_block: *mut ir_node);
}
extern "C" {
    #[doc = " Returns start_block input of an Anchor node."]
    pub fn get_Anchor_start_block(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets start_block input of an Anchor node."]
    pub fn set_Anchor_start_block(node: *mut ir_node, start_block: *mut ir_node);
}
extern "C" {
    #[doc = " Returns end input of an Anchor node."]
    pub fn get_Anchor_end(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets end input of an Anchor node."]
    pub fn set_Anchor_end(node: *mut ir_node, end: *mut ir_node);
}
extern "C" {
    #[doc = " Returns start input of an Anchor node."]
    pub fn get_Anchor_start(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets start input of an Anchor node."]
    pub fn set_Anchor_start(node: *mut ir_node, start: *mut ir_node);
}
extern "C" {
    #[doc = " Returns frame input of an Anchor node."]
    pub fn get_Anchor_frame(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets frame input of an Anchor node."]
    pub fn set_Anchor_frame(node: *mut ir_node, frame: *mut ir_node);
}
extern "C" {
    #[doc = " Returns initial_mem input of an Anchor node."]
    pub fn get_Anchor_initial_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets initial_mem input of an Anchor node."]
    pub fn set_Anchor_initial_mem(node: *mut ir_node, initial_mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns args input of an Anchor node."]
    pub fn get_Anchor_args(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets args input of an Anchor node."]
    pub fn set_Anchor_args(node: *mut ir_node, args: *mut ir_node);
}
extern "C" {
    #[doc = " Returns no_mem input of an Anchor node."]
    pub fn get_Anchor_no_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets no_mem input of an Anchor node."]
    pub fn set_Anchor_no_mem(node: *mut ir_node, no_mem: *mut ir_node);
}
extern "C" {
    #[doc = " Anchor opcode"]
    pub static mut op_Anchor: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Anchor nodes."]
    pub fn get_op_Anchor() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_And_n_And_left: n_And = 0;
#[doc = "< second operand"]
pub const n_And_n_And_right: n_And = 1;
pub const n_And_n_And_max: n_And = 1;
#[doc = " Input numbers for And node"]
pub type n_And = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct an And node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_And(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an And node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_And(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an And node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_And(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an And node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_And(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a And\n @returns 1 if the node is a And node, 0 otherwise"]
    pub fn is_And(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of an And node."]
    pub fn get_And_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of an And node."]
    pub fn set_And_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of an And node."]
    pub fn get_And_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of an And node."]
    pub fn set_And_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " And opcode"]
    pub static mut op_And: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for And nodes."]
    pub fn get_op_And() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Bad node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result"]
    pub fn new_rd_Bad(dbgi: *mut dbg_info, irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Bad node.\n\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result"]
    pub fn new_r_Bad(irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Bad node.\n\n @param dbgi      A pointer to debug information.\n @param mode      mode of the operations result"]
    pub fn new_d_Bad(dbgi: *mut dbg_info, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Bad node.\n\n @param mode      mode of the operations result"]
    pub fn new_Bad(mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Bad\n @returns 1 if the node is a Bad node, 0 otherwise"]
    pub fn is_Bad(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Bad opcode"]
    pub static mut op_Bad: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Bad nodes."]
    pub fn get_op_Bad() -> *mut ir_op;
}
#[doc = "< operand"]
pub const n_Bitcast_n_Bitcast_op: n_Bitcast = 0;
pub const n_Bitcast_n_Bitcast_max: n_Bitcast = 0;
#[doc = " Input numbers for Bitcast node"]
pub type n_Bitcast = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Bitcast node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_rd_Bitcast(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Bitcast node.\n\n @param block     The IR block the node belongs to.\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_r_Bitcast(
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Bitcast node.\n\n @param dbgi      A pointer to debug information.\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_d_Bitcast(
        dbgi: *mut dbg_info,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Bitcast node.\n\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_Bitcast(irn_op: *mut ir_node, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Bitcast\n @returns 1 if the node is a Bitcast node, 0 otherwise"]
    pub fn is_Bitcast(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns op input of a Bitcast node."]
    pub fn get_Bitcast_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets op input of a Bitcast node."]
    pub fn set_Bitcast_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[doc = " Bitcast opcode"]
    pub static mut op_Bitcast: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Bitcast nodes."]
    pub fn get_op_Bitcast() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Block node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_rd_Block(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Block node.\n\n @param irg       The IR graph the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_r_Block(
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Block node.\n\n @param dbgi      A pointer to debug information.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_d_Block(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Block node.\n\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_Block(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Block\n @returns 1 if the node is a Block node, 0 otherwise"]
    pub fn is_Block(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of Block cfgpreds."]
    pub fn get_Block_n_cfgpreds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the Block cfgpred with index @p pos."]
    pub fn get_Block_cfgpred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the Block cfgpred with index @p pos."]
    pub fn set_Block_cfgpred(node: *mut ir_node, pos: ::std::os::raw::c_int, cfgpred: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all Block cfgpreds."]
    pub fn get_Block_cfgpred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Returns entity attribute of a Block node."]
    pub fn get_Block_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets entity attribute of a Block node."]
    pub fn set_Block_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[doc = " Block opcode"]
    pub static mut op_Block: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Block nodes."]
    pub fn get_op_Block() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Builtin_n_Builtin_mem: n_Builtin = 0;
pub const n_Builtin_n_Builtin_max: n_Builtin = 0;
#[doc = " Input numbers for Builtin node"]
pub type n_Builtin = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Builtin_pn_Builtin_M: pn_Builtin = 0;
pub const pn_Builtin_pn_Builtin_max: pn_Builtin = 0;
#[doc = " Projection numbers for result of Builtin node (use for Proj nodes)"]
pub type pn_Builtin = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Builtin node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param kind      kind of builtin\n @param type      method type for the builtin call"]
    pub fn new_rd_Builtin(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Builtin node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param kind      kind of builtin\n @param type      method type for the builtin call"]
    pub fn new_r_Builtin(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Builtin node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param kind      kind of builtin\n @param type      method type for the builtin call"]
    pub fn new_d_Builtin(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Builtin node.\n\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param kind      kind of builtin\n @param type      method type for the builtin call"]
    pub fn new_Builtin(
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        kind: ir_builtin_kind,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Builtin\n @returns 1 if the node is a Builtin node, 0 otherwise"]
    pub fn is_Builtin(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Builtin node."]
    pub fn get_Builtin_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Builtin node."]
    pub fn set_Builtin_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Get the number of Builtin params."]
    pub fn get_Builtin_n_params(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the Builtin param with index @p pos."]
    pub fn get_Builtin_param(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the Builtin param with index @p pos."]
    pub fn set_Builtin_param(node: *mut ir_node, pos: ::std::os::raw::c_int, param: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all Builtin params."]
    pub fn get_Builtin_param_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Returns kind attribute of a Builtin node."]
    pub fn get_Builtin_kind(node: *const ir_node) -> ir_builtin_kind;
}
extern "C" {
    #[doc = " Sets kind attribute of a Builtin node."]
    pub fn set_Builtin_kind(node: *mut ir_node, kind: ir_builtin_kind);
}
extern "C" {
    #[doc = " Returns type attribute of a Builtin node."]
    pub fn get_Builtin_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a Builtin node."]
    pub fn set_Builtin_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Builtin opcode"]
    pub static mut op_Builtin: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Builtin nodes."]
    pub fn get_op_Builtin() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Call_n_Call_mem: n_Call = 0;
#[doc = "< pointer to called code"]
pub const n_Call_n_Call_ptr: n_Call = 1;
pub const n_Call_n_Call_max: n_Call = 1;
#[doc = " Input numbers for Call node"]
pub type n_Call = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Call_pn_Call_M: pn_Call = 0;
#[doc = "< tuple containing all results"]
pub const pn_Call_pn_Call_T_result: pn_Call = 1;
#[doc = "< control flow when no exception occurs"]
pub const pn_Call_pn_Call_X_regular: pn_Call = 2;
#[doc = "< control flow when exception occurred"]
pub const pn_Call_pn_Call_X_except: pn_Call = 3;
pub const pn_Call_pn_Call_max: pn_Call = 3;
#[doc = " Projection numbers for result of Call node (use for Proj nodes)"]
pub type pn_Call = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Call node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param type      type of the call (usually type of the called procedure)"]
    pub fn new_rd_Call(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Call node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param type      type of the call (usually type of the called procedure)"]
    pub fn new_r_Call(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Call node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param type      type of the call (usually type of the called procedure)"]
    pub fn new_d_Call(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Call node.\n\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param type      type of the call (usually type of the called procedure)"]
    pub fn new_Call(
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Call\n @returns 1 if the node is a Call node, 0 otherwise"]
    pub fn is_Call(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Call node."]
    pub fn get_Call_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Call node."]
    pub fn set_Call_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns ptr input of a Call node."]
    pub fn get_Call_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets ptr input of a Call node."]
    pub fn set_Call_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    #[doc = " Get the number of Call params."]
    pub fn get_Call_n_params(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the Call param with index @p pos."]
    pub fn get_Call_param(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the Call param with index @p pos."]
    pub fn set_Call_param(node: *mut ir_node, pos: ::std::os::raw::c_int, param: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all Call params."]
    pub fn get_Call_param_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Returns type attribute of a Call node."]
    pub fn get_Call_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a Call node."]
    pub fn set_Call_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Call opcode"]
    pub static mut op_Call: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Call nodes."]
    pub fn get_op_Call() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Cmp_n_Cmp_left: n_Cmp = 0;
#[doc = "< second operand"]
pub const n_Cmp_n_Cmp_right: n_Cmp = 1;
pub const n_Cmp_n_Cmp_max: n_Cmp = 1;
#[doc = " Input numbers for Cmp node"]
pub type n_Cmp = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Cmp node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right\n @param relation  Comparison relation"]
    pub fn new_rd_Cmp(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Cmp node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right\n @param relation  Comparison relation"]
    pub fn new_r_Cmp(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Cmp node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right\n @param relation  Comparison relation"]
    pub fn new_d_Cmp(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Cmp node.\n\n @param irn_left  left\n @param irn_right right\n @param relation  Comparison relation"]
    pub fn new_Cmp(
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Cmp\n @returns 1 if the node is a Cmp node, 0 otherwise"]
    pub fn is_Cmp(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of a Cmp node."]
    pub fn get_Cmp_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Cmp node."]
    pub fn set_Cmp_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Cmp node."]
    pub fn get_Cmp_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Cmp node."]
    pub fn set_Cmp_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Returns relation attribute of a Cmp node."]
    pub fn get_Cmp_relation(node: *const ir_node) -> ir_relation;
}
extern "C" {
    #[doc = " Sets relation attribute of a Cmp node."]
    pub fn set_Cmp_relation(node: *mut ir_node, relation: ir_relation);
}
extern "C" {
    #[doc = " Cmp opcode"]
    pub static mut op_Cmp: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Cmp nodes."]
    pub fn get_op_Cmp() -> *mut ir_op;
}
#[doc = "< condition parameter"]
pub const n_Cond_n_Cond_selector: n_Cond = 0;
pub const n_Cond_n_Cond_max: n_Cond = 0;
#[doc = " Input numbers for Cond node"]
pub type n_Cond = ::std::os::raw::c_uint;
#[doc = "< control flow if operand is \"false\""]
pub const pn_Cond_pn_Cond_false: pn_Cond = 0;
#[doc = "< control flow if operand is \"true\""]
pub const pn_Cond_pn_Cond_true: pn_Cond = 1;
pub const pn_Cond_pn_Cond_max: pn_Cond = 1;
#[doc = " Projection numbers for result of Cond node (use for Proj nodes)"]
pub type pn_Cond = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Cond node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_selector selector"]
    pub fn new_rd_Cond(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_selector: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Cond node.\n\n @param block     The IR block the node belongs to.\n @param irn_selector selector"]
    pub fn new_r_Cond(block: *mut ir_node, irn_selector: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Cond node.\n\n @param dbgi      A pointer to debug information.\n @param irn_selector selector"]
    pub fn new_d_Cond(dbgi: *mut dbg_info, irn_selector: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Cond node.\n\n @param irn_selector selector"]
    pub fn new_Cond(irn_selector: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Cond\n @returns 1 if the node is a Cond node, 0 otherwise"]
    pub fn is_Cond(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns selector input of a Cond node."]
    pub fn get_Cond_selector(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets selector input of a Cond node."]
    pub fn set_Cond_selector(node: *mut ir_node, selector: *mut ir_node);
}
extern "C" {
    #[doc = " Returns jmp_pred attribute of a Cond node."]
    pub fn get_Cond_jmp_pred(node: *const ir_node) -> cond_jmp_predicate;
}
extern "C" {
    #[doc = " Sets jmp_pred attribute of a Cond node."]
    pub fn set_Cond_jmp_pred(node: *mut ir_node, jmp_pred: cond_jmp_predicate);
}
extern "C" {
    #[doc = " Cond opcode"]
    pub static mut op_Cond: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Cond nodes."]
    pub fn get_op_Cond() -> *mut ir_op;
}
#[doc = "< value to express a constraint for"]
pub const n_Confirm_n_Confirm_value: n_Confirm = 0;
#[doc = "< value to compare against"]
pub const n_Confirm_n_Confirm_bound: n_Confirm = 1;
pub const n_Confirm_n_Confirm_max: n_Confirm = 1;
#[doc = " Input numbers for Confirm node"]
pub type n_Confirm = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Confirm node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_value value\n @param irn_bound bound\n @param relation  relation of value to bound"]
    pub fn new_rd_Confirm(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Confirm node.\n\n @param block     The IR block the node belongs to.\n @param irn_value value\n @param irn_bound bound\n @param relation  relation of value to bound"]
    pub fn new_r_Confirm(
        block: *mut ir_node,
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Confirm node.\n\n @param dbgi      A pointer to debug information.\n @param irn_value value\n @param irn_bound bound\n @param relation  relation of value to bound"]
    pub fn new_d_Confirm(
        dbgi: *mut dbg_info,
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Confirm node.\n\n @param irn_value value\n @param irn_bound bound\n @param relation  relation of value to bound"]
    pub fn new_Confirm(
        irn_value: *mut ir_node,
        irn_bound: *mut ir_node,
        relation: ir_relation,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Confirm\n @returns 1 if the node is a Confirm node, 0 otherwise"]
    pub fn is_Confirm(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns value input of a Confirm node."]
    pub fn get_Confirm_value(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets value input of a Confirm node."]
    pub fn set_Confirm_value(node: *mut ir_node, value: *mut ir_node);
}
extern "C" {
    #[doc = " Returns bound input of a Confirm node."]
    pub fn get_Confirm_bound(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets bound input of a Confirm node."]
    pub fn set_Confirm_bound(node: *mut ir_node, bound: *mut ir_node);
}
extern "C" {
    #[doc = " Returns relation attribute of a Confirm node."]
    pub fn get_Confirm_relation(node: *const ir_node) -> ir_relation;
}
extern "C" {
    #[doc = " Sets relation attribute of a Confirm node."]
    pub fn set_Confirm_relation(node: *mut ir_node, relation: ir_relation);
}
extern "C" {
    #[doc = " Confirm opcode"]
    pub static mut op_Confirm: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Confirm nodes."]
    pub fn get_op_Confirm() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Const node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param tarval    constant value (a tarval object)"]
    pub fn new_rd_Const(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        tarval: *mut ir_tarval,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Const node.\n\n @param irg       The IR graph the node belongs to.\n @param tarval    constant value (a tarval object)"]
    pub fn new_r_Const(irg: *mut ir_graph, tarval: *mut ir_tarval) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Const node.\n\n @param dbgi      A pointer to debug information.\n @param tarval    constant value (a tarval object)"]
    pub fn new_d_Const(dbgi: *mut dbg_info, tarval: *mut ir_tarval) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Const node.\n\n @param tarval    constant value (a tarval object)"]
    pub fn new_Const(tarval: *mut ir_tarval) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Const\n @returns 1 if the node is a Const node, 0 otherwise"]
    pub fn is_Const(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns tarval attribute of a Const node."]
    pub fn get_Const_tarval(node: *const ir_node) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Sets tarval attribute of a Const node."]
    pub fn set_Const_tarval(node: *mut ir_node, tarval: *mut ir_tarval);
}
extern "C" {
    #[doc = " Const opcode"]
    pub static mut op_Const: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Const nodes."]
    pub fn get_op_Const() -> *mut ir_op;
}
#[doc = "< operand"]
pub const n_Conv_n_Conv_op: n_Conv = 0;
pub const n_Conv_n_Conv_max: n_Conv = 0;
#[doc = " Input numbers for Conv node"]
pub type n_Conv = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Conv node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_rd_Conv(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Conv node.\n\n @param block     The IR block the node belongs to.\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_r_Conv(
        block: *mut ir_node,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Conv node.\n\n @param dbgi      A pointer to debug information.\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_d_Conv(
        dbgi: *mut dbg_info,
        irn_op: *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Conv node.\n\n @param irn_op    op\n @param mode      mode of the operations result"]
    pub fn new_Conv(irn_op: *mut ir_node, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Conv\n @returns 1 if the node is a Conv node, 0 otherwise"]
    pub fn is_Conv(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns op input of a Conv node."]
    pub fn get_Conv_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets op input of a Conv node."]
    pub fn set_Conv_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[doc = " Conv opcode"]
    pub static mut op_Conv: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Conv nodes."]
    pub fn get_op_Conv() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_CopyB_n_CopyB_mem: n_CopyB = 0;
#[doc = "< destination address"]
pub const n_CopyB_n_CopyB_dst: n_CopyB = 1;
#[doc = "< source address"]
pub const n_CopyB_n_CopyB_src: n_CopyB = 2;
pub const n_CopyB_n_CopyB_max: n_CopyB = 2;
#[doc = " Input numbers for CopyB node"]
pub type n_CopyB = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a CopyB node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_dst   dst\n @param irn_src   src\n @param type      type of copied data\n @param flags     specifies volatility"]
    pub fn new_rd_CopyB(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a CopyB node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_dst   dst\n @param irn_src   src\n @param type      type of copied data\n @param flags     specifies volatility"]
    pub fn new_r_CopyB(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a CopyB node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_dst   dst\n @param irn_src   src\n @param type      type of copied data\n @param flags     specifies volatility"]
    pub fn new_d_CopyB(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a CopyB node.\n\n @param irn_mem   mem\n @param irn_dst   dst\n @param irn_src   src\n @param type      type of copied data\n @param flags     specifies volatility"]
    pub fn new_CopyB(
        irn_mem: *mut ir_node,
        irn_dst: *mut ir_node,
        irn_src: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a CopyB\n @returns 1 if the node is a CopyB node, 0 otherwise"]
    pub fn is_CopyB(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a CopyB node."]
    pub fn get_CopyB_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a CopyB node."]
    pub fn set_CopyB_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns dst input of a CopyB node."]
    pub fn get_CopyB_dst(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets dst input of a CopyB node."]
    pub fn set_CopyB_dst(node: *mut ir_node, dst: *mut ir_node);
}
extern "C" {
    #[doc = " Returns src input of a CopyB node."]
    pub fn get_CopyB_src(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets src input of a CopyB node."]
    pub fn set_CopyB_src(node: *mut ir_node, src: *mut ir_node);
}
extern "C" {
    #[doc = " Returns type attribute of a CopyB node."]
    pub fn get_CopyB_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a CopyB node."]
    pub fn set_CopyB_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Returns volatility attribute of a CopyB node."]
    pub fn get_CopyB_volatility(node: *const ir_node) -> ir_volatility;
}
extern "C" {
    #[doc = " Sets volatility attribute of a CopyB node."]
    pub fn set_CopyB_volatility(node: *mut ir_node, volatility: ir_volatility);
}
extern "C" {
    #[doc = " CopyB opcode"]
    pub static mut op_CopyB: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for CopyB nodes."]
    pub fn get_op_CopyB() -> *mut ir_op;
}
extern "C" {
    #[doc = " Test if node is a Deleted\n @returns 1 if the node is a Deleted node, 0 otherwise"]
    pub fn is_Deleted(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deleted opcode"]
    pub static mut op_Deleted: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Deleted nodes."]
    pub fn get_op_Deleted() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Div_n_Div_mem: n_Div = 0;
#[doc = "< first operand"]
pub const n_Div_n_Div_left: n_Div = 1;
#[doc = "< second operand"]
pub const n_Div_n_Div_right: n_Div = 2;
pub const n_Div_n_Div_max: n_Div = 2;
#[doc = " Input numbers for Div node"]
pub type n_Div = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Div_pn_Div_M: pn_Div = 0;
#[doc = "< result of computation"]
pub const pn_Div_pn_Div_res: pn_Div = 1;
#[doc = "< control flow when no exception occurs"]
pub const pn_Div_pn_Div_X_regular: pn_Div = 2;
#[doc = "< control flow when exception occurred"]
pub const pn_Div_pn_Div_X_except: pn_Div = 3;
pub const pn_Div_pn_Div_max: pn_Div = 3;
#[doc = " Projection numbers for result of Div node (use for Proj nodes)"]
pub type pn_Div = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Div node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_rd_Div(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Div node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_r_Div(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Div node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_d_Div(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Div node.\n\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_Div(
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Div\n @returns 1 if the node is a Div node, 0 otherwise"]
    pub fn is_Div(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Div node."]
    pub fn get_Div_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Div node."]
    pub fn set_Div_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns left input of a Div node."]
    pub fn get_Div_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Div node."]
    pub fn set_Div_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Div node."]
    pub fn get_Div_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Div node."]
    pub fn set_Div_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Returns resmode attribute of a Div node."]
    pub fn get_Div_resmode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Sets resmode attribute of a Div node."]
    pub fn set_Div_resmode(node: *mut ir_node, resmode: *mut ir_mode);
}
extern "C" {
    #[doc = " Returns no_remainder attribute of a Div node."]
    pub fn get_Div_no_remainder(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets no_remainder attribute of a Div node."]
    pub fn set_Div_no_remainder(node: *mut ir_node, no_remainder: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Div opcode"]
    pub static mut op_Div: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Div nodes."]
    pub fn get_op_Div() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Dummy node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result"]
    pub fn new_rd_Dummy(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Dummy node.\n\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result"]
    pub fn new_r_Dummy(irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Dummy node.\n\n @param dbgi      A pointer to debug information.\n @param mode      mode of the operations result"]
    pub fn new_d_Dummy(dbgi: *mut dbg_info, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Dummy node.\n\n @param mode      mode of the operations result"]
    pub fn new_Dummy(mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Dummy\n @returns 1 if the node is a Dummy node, 0 otherwise"]
    pub fn is_Dummy(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dummy opcode"]
    pub static mut op_Dummy: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Dummy nodes."]
    pub fn get_op_Dummy() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct an End node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_rd_End(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an End node.\n\n @param irg       The IR graph the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_r_End(
        irg: *mut ir_graph,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an End node.\n\n @param dbgi      A pointer to debug information.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_d_End(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an End node.\n\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_End(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a End\n @returns 1 if the node is a End node, 0 otherwise"]
    pub fn is_End(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of End keepalives."]
    pub fn get_End_n_keepalives(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the End keepalive with index @p pos."]
    pub fn get_End_keepalive(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the End keepalive with index @p pos."]
    pub fn set_End_keepalive(
        node: *mut ir_node,
        pos: ::std::os::raw::c_int,
        keepalive: *mut ir_node,
    );
}
extern "C" {
    #[doc = " Get an array of all End keepalives."]
    pub fn get_End_keepalive_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " End opcode"]
    pub static mut op_End: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for End nodes."]
    pub fn get_op_End() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Eor_n_Eor_left: n_Eor = 0;
#[doc = "< second operand"]
pub const n_Eor_n_Eor_right: n_Eor = 1;
pub const n_Eor_n_Eor_max: n_Eor = 1;
#[doc = " Input numbers for Eor node"]
pub type n_Eor = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct an Eor node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Eor(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Eor node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Eor(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Eor node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Eor(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Eor node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Eor(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Eor\n @returns 1 if the node is a Eor node, 0 otherwise"]
    pub fn is_Eor(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of an Eor node."]
    pub fn get_Eor_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of an Eor node."]
    pub fn set_Eor_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of an Eor node."]
    pub fn get_Eor_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of an Eor node."]
    pub fn set_Eor_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Eor opcode"]
    pub static mut op_Eor: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Eor nodes."]
    pub fn get_op_Eor() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Free_n_Free_mem: n_Free = 0;
#[doc = "< pointer to the object to free"]
pub const n_Free_n_Free_ptr: n_Free = 1;
pub const n_Free_n_Free_max: n_Free = 1;
#[doc = " Input numbers for Free node"]
pub type n_Free = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Free node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr"]
    pub fn new_rd_Free(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Free node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr"]
    pub fn new_r_Free(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Free node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_ptr   ptr"]
    pub fn new_d_Free(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Free node.\n\n @param irn_mem   mem\n @param irn_ptr   ptr"]
    pub fn new_Free(irn_mem: *mut ir_node, irn_ptr: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Free\n @returns 1 if the node is a Free node, 0 otherwise"]
    pub fn is_Free(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Free node."]
    pub fn get_Free_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Free node."]
    pub fn set_Free_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns ptr input of a Free node."]
    pub fn get_Free_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets ptr input of a Free node."]
    pub fn set_Free_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    #[doc = " Free opcode"]
    pub static mut op_Free: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Free nodes."]
    pub fn get_op_Free() -> *mut ir_op;
}
#[doc = "< target address of the jump"]
pub const n_IJmp_n_IJmp_target: n_IJmp = 0;
pub const n_IJmp_n_IJmp_max: n_IJmp = 0;
#[doc = " Input numbers for IJmp node"]
pub type n_IJmp = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct an IJmp node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_target target"]
    pub fn new_rd_IJmp(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_target: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an IJmp node.\n\n @param block     The IR block the node belongs to.\n @param irn_target target"]
    pub fn new_r_IJmp(block: *mut ir_node, irn_target: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an IJmp node.\n\n @param dbgi      A pointer to debug information.\n @param irn_target target"]
    pub fn new_d_IJmp(dbgi: *mut dbg_info, irn_target: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an IJmp node.\n\n @param irn_target target"]
    pub fn new_IJmp(irn_target: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a IJmp\n @returns 1 if the node is a IJmp node, 0 otherwise"]
    pub fn is_IJmp(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns target input of an IJmp node."]
    pub fn get_IJmp_target(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets target input of an IJmp node."]
    pub fn set_IJmp_target(node: *mut ir_node, target: *mut ir_node);
}
extern "C" {
    #[doc = " IJmp opcode"]
    pub static mut op_IJmp: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for IJmp nodes."]
    pub fn get_op_IJmp() -> *mut ir_op;
}
#[doc = "< the value which is returned unchanged"]
pub const n_Id_n_Id_pred: n_Id = 0;
pub const n_Id_n_Id_max: n_Id = 0;
#[doc = " Input numbers for Id node"]
pub type n_Id = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Test if node is a Id\n @returns 1 if the node is a Id node, 0 otherwise"]
    pub fn is_Id(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns pred input of an Id node."]
    pub fn get_Id_pred(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets pred input of an Id node."]
    pub fn set_Id_pred(node: *mut ir_node, pred: *mut ir_node);
}
extern "C" {
    #[doc = " Id opcode"]
    pub static mut op_Id: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Id nodes."]
    pub fn get_op_Id() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Jmp node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to."]
    pub fn new_rd_Jmp(dbgi: *mut dbg_info, block: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Jmp node.\n\n @param block     The IR block the node belongs to."]
    pub fn new_r_Jmp(block: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Jmp node.\n\n @param dbgi      A pointer to debug information."]
    pub fn new_d_Jmp(dbgi: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Jmp node."]
    pub fn new_Jmp() -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Jmp\n @returns 1 if the node is a Jmp node, 0 otherwise"]
    pub fn is_Jmp(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Jmp opcode"]
    pub static mut op_Jmp: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Jmp nodes."]
    pub fn get_op_Jmp() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Load_n_Load_mem: n_Load = 0;
#[doc = "< address to load from"]
pub const n_Load_n_Load_ptr: n_Load = 1;
pub const n_Load_n_Load_max: n_Load = 1;
#[doc = " Input numbers for Load node"]
pub type n_Load = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Load_pn_Load_M: pn_Load = 0;
#[doc = "< result of load operation"]
pub const pn_Load_pn_Load_res: pn_Load = 1;
#[doc = "< control flow when no exception occurs"]
pub const pn_Load_pn_Load_X_regular: pn_Load = 2;
#[doc = "< control flow when exception occurred"]
pub const pn_Load_pn_Load_X_except: pn_Load = 3;
pub const pn_Load_pn_Load_max: pn_Load = 3;
#[doc = " Projection numbers for result of Load node (use for Proj nodes)"]
pub type pn_Load = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Load node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param mode      mode of the value to be loaded\n @param type      The type of the object which is stored at ptr (need not match with mode)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_rd_Load(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Load node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param mode      mode of the value to be loaded\n @param type      The type of the object which is stored at ptr (need not match with mode)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_r_Load(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Load node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param mode      mode of the value to be loaded\n @param type      The type of the object which is stored at ptr (need not match with mode)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_d_Load(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Load node.\n\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param mode      mode of the value to be loaded\n @param type      The type of the object which is stored at ptr (need not match with mode)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_Load(
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        mode: *mut ir_mode,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Load\n @returns 1 if the node is a Load node, 0 otherwise"]
    pub fn is_Load(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Load node."]
    pub fn get_Load_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Load node."]
    pub fn set_Load_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns ptr input of a Load node."]
    pub fn get_Load_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets ptr input of a Load node."]
    pub fn set_Load_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    #[doc = " Returns mode attribute of a Load node."]
    pub fn get_Load_mode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Sets mode attribute of a Load node."]
    pub fn set_Load_mode(node: *mut ir_node, mode: *mut ir_mode);
}
extern "C" {
    #[doc = " Returns type attribute of a Load node."]
    pub fn get_Load_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a Load node."]
    pub fn set_Load_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Returns volatility attribute of a Load node."]
    pub fn get_Load_volatility(node: *const ir_node) -> ir_volatility;
}
extern "C" {
    #[doc = " Sets volatility attribute of a Load node."]
    pub fn set_Load_volatility(node: *mut ir_node, volatility: ir_volatility);
}
extern "C" {
    #[doc = " Returns unaligned attribute of a Load node."]
    pub fn get_Load_unaligned(node: *const ir_node) -> ir_align;
}
extern "C" {
    #[doc = " Sets unaligned attribute of a Load node."]
    pub fn set_Load_unaligned(node: *mut ir_node, unaligned: ir_align);
}
extern "C" {
    #[doc = " Load opcode"]
    pub static mut op_Load: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Load nodes."]
    pub fn get_op_Load() -> *mut ir_op;
}
#[doc = "< pointer to object to select from"]
pub const n_Member_n_Member_ptr: n_Member = 0;
pub const n_Member_n_Member_max: n_Member = 0;
#[doc = " Input numbers for Member node"]
pub type n_Member = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Member node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_ptr   ptr\n @param entity    entity which is selected"]
    pub fn new_rd_Member(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Member node.\n\n @param block     The IR block the node belongs to.\n @param irn_ptr   ptr\n @param entity    entity which is selected"]
    pub fn new_r_Member(
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Member node.\n\n @param dbgi      A pointer to debug information.\n @param irn_ptr   ptr\n @param entity    entity which is selected"]
    pub fn new_d_Member(
        dbgi: *mut dbg_info,
        irn_ptr: *mut ir_node,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Member node.\n\n @param irn_ptr   ptr\n @param entity    entity which is selected"]
    pub fn new_Member(irn_ptr: *mut ir_node, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Member\n @returns 1 if the node is a Member node, 0 otherwise"]
    pub fn is_Member(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns ptr input of a Member node."]
    pub fn get_Member_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets ptr input of a Member node."]
    pub fn set_Member_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    #[doc = " Returns entity attribute of a Member node."]
    pub fn get_Member_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets entity attribute of a Member node."]
    pub fn set_Member_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[doc = " Member opcode"]
    pub static mut op_Member: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Member nodes."]
    pub fn get_op_Member() -> *mut ir_op;
}
#[doc = "< operand"]
pub const n_Minus_n_Minus_op: n_Minus = 0;
pub const n_Minus_n_Minus_max: n_Minus = 0;
#[doc = " Input numbers for Minus node"]
pub type n_Minus = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Minus node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_op    op"]
    pub fn new_rd_Minus(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Minus node.\n\n @param block     The IR block the node belongs to.\n @param irn_op    op"]
    pub fn new_r_Minus(block: *mut ir_node, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Minus node.\n\n @param dbgi      A pointer to debug information.\n @param irn_op    op"]
    pub fn new_d_Minus(dbgi: *mut dbg_info, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Minus node.\n\n @param irn_op    op"]
    pub fn new_Minus(irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Minus\n @returns 1 if the node is a Minus node, 0 otherwise"]
    pub fn is_Minus(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns op input of a Minus node."]
    pub fn get_Minus_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets op input of a Minus node."]
    pub fn set_Minus_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[doc = " Minus opcode"]
    pub static mut op_Minus: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Minus nodes."]
    pub fn get_op_Minus() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Mod_n_Mod_mem: n_Mod = 0;
#[doc = "< first operand"]
pub const n_Mod_n_Mod_left: n_Mod = 1;
#[doc = "< second operand"]
pub const n_Mod_n_Mod_right: n_Mod = 2;
pub const n_Mod_n_Mod_max: n_Mod = 2;
#[doc = " Input numbers for Mod node"]
pub type n_Mod = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Mod_pn_Mod_M: pn_Mod = 0;
#[doc = "< result of computation"]
pub const pn_Mod_pn_Mod_res: pn_Mod = 1;
#[doc = "< control flow when no exception occurs"]
pub const pn_Mod_pn_Mod_X_regular: pn_Mod = 2;
#[doc = "< control flow when exception occurred"]
pub const pn_Mod_pn_Mod_X_except: pn_Mod = 3;
pub const pn_Mod_pn_Mod_max: pn_Mod = 3;
#[doc = " Projection numbers for result of Mod node (use for Proj nodes)"]
pub type pn_Mod = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Mod node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_rd_Mod(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mod node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_r_Mod(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mod node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_d_Mod(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mod node.\n\n @param irn_mem   mem\n @param irn_left  left\n @param irn_right right\n @param pinned    pinned state"]
    pub fn new_Mod(
        irn_mem: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Mod\n @returns 1 if the node is a Mod node, 0 otherwise"]
    pub fn is_Mod(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Mod node."]
    pub fn get_Mod_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Mod node."]
    pub fn set_Mod_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns left input of a Mod node."]
    pub fn get_Mod_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Mod node."]
    pub fn set_Mod_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Mod node."]
    pub fn get_Mod_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Mod node."]
    pub fn set_Mod_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Returns resmode attribute of a Mod node."]
    pub fn get_Mod_resmode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Sets resmode attribute of a Mod node."]
    pub fn set_Mod_resmode(node: *mut ir_node, resmode: *mut ir_mode);
}
extern "C" {
    #[doc = " Mod opcode"]
    pub static mut op_Mod: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Mod nodes."]
    pub fn get_op_Mod() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Mul_n_Mul_left: n_Mul = 0;
#[doc = "< second operand"]
pub const n_Mul_n_Mul_right: n_Mul = 1;
pub const n_Mul_n_Mul_max: n_Mul = 1;
#[doc = " Input numbers for Mul node"]
pub type n_Mul = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Mul node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Mul(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mul node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Mul(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mul node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Mul(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mul node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Mul(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Mul\n @returns 1 if the node is a Mul node, 0 otherwise"]
    pub fn is_Mul(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of a Mul node."]
    pub fn get_Mul_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Mul node."]
    pub fn set_Mul_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Mul node."]
    pub fn get_Mul_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Mul node."]
    pub fn set_Mul_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Mul opcode"]
    pub static mut op_Mul: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Mul nodes."]
    pub fn get_op_Mul() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Mulh_n_Mulh_left: n_Mulh = 0;
#[doc = "< second operand"]
pub const n_Mulh_n_Mulh_right: n_Mulh = 1;
pub const n_Mulh_n_Mulh_max: n_Mulh = 1;
#[doc = " Input numbers for Mulh node"]
pub type n_Mulh = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Mulh node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Mulh(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mulh node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Mulh(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mulh node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Mulh(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mulh node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Mulh(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Mulh\n @returns 1 if the node is a Mulh node, 0 otherwise"]
    pub fn is_Mulh(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of a Mulh node."]
    pub fn get_Mulh_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Mulh node."]
    pub fn set_Mulh_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Mulh node."]
    pub fn get_Mulh_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Mulh node."]
    pub fn set_Mulh_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Mulh opcode"]
    pub static mut op_Mulh: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Mulh nodes."]
    pub fn get_op_Mulh() -> *mut ir_op;
}
#[doc = "< value making the output selection"]
pub const n_Mux_n_Mux_sel: n_Mux = 0;
#[doc = "< selected if sel input is false"]
pub const n_Mux_n_Mux_false: n_Mux = 1;
#[doc = "< selected if sel input is true"]
pub const n_Mux_n_Mux_true: n_Mux = 2;
pub const n_Mux_n_Mux_max: n_Mux = 2;
#[doc = " Input numbers for Mux node"]
pub type n_Mux = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Mux node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_sel   sel\n @param irn_false false\n @param irn_true  true"]
    pub fn new_rd_Mux(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mux node.\n\n @param block     The IR block the node belongs to.\n @param irn_sel   sel\n @param irn_false false\n @param irn_true  true"]
    pub fn new_r_Mux(
        block: *mut ir_node,
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mux node.\n\n @param dbgi      A pointer to debug information.\n @param irn_sel   sel\n @param irn_false false\n @param irn_true  true"]
    pub fn new_d_Mux(
        dbgi: *mut dbg_info,
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Mux node.\n\n @param irn_sel   sel\n @param irn_false false\n @param irn_true  true"]
    pub fn new_Mux(
        irn_sel: *mut ir_node,
        irn_false: *mut ir_node,
        irn_true: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Mux\n @returns 1 if the node is a Mux node, 0 otherwise"]
    pub fn is_Mux(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns sel input of a Mux node."]
    pub fn get_Mux_sel(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets sel input of a Mux node."]
    pub fn set_Mux_sel(node: *mut ir_node, sel: *mut ir_node);
}
extern "C" {
    #[doc = " Returns false input of a Mux node."]
    pub fn get_Mux_false(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets false input of a Mux node."]
    pub fn set_Mux_false(node: *mut ir_node, false_: *mut ir_node);
}
extern "C" {
    #[doc = " Returns true input of a Mux node."]
    pub fn get_Mux_true(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets true input of a Mux node."]
    pub fn set_Mux_true(node: *mut ir_node, true_: *mut ir_node);
}
extern "C" {
    #[doc = " Mux opcode"]
    pub static mut op_Mux: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Mux nodes."]
    pub fn get_op_Mux() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a NoMem node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to."]
    pub fn new_rd_NoMem(dbgi: *mut dbg_info, irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a NoMem node.\n\n @param irg       The IR graph the node belongs to."]
    pub fn new_r_NoMem(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a NoMem node.\n\n @param dbgi      A pointer to debug information."]
    pub fn new_d_NoMem(dbgi: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a NoMem node."]
    pub fn new_NoMem() -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a NoMem\n @returns 1 if the node is a NoMem node, 0 otherwise"]
    pub fn is_NoMem(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " NoMem opcode"]
    pub static mut op_NoMem: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for NoMem nodes."]
    pub fn get_op_NoMem() -> *mut ir_op;
}
#[doc = "< operand"]
pub const n_Not_n_Not_op: n_Not = 0;
pub const n_Not_n_Not_max: n_Not = 0;
#[doc = " Input numbers for Not node"]
pub type n_Not = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Not node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_op    op"]
    pub fn new_rd_Not(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Not node.\n\n @param block     The IR block the node belongs to.\n @param irn_op    op"]
    pub fn new_r_Not(block: *mut ir_node, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Not node.\n\n @param dbgi      A pointer to debug information.\n @param irn_op    op"]
    pub fn new_d_Not(dbgi: *mut dbg_info, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Not node.\n\n @param irn_op    op"]
    pub fn new_Not(irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Not\n @returns 1 if the node is a Not node, 0 otherwise"]
    pub fn is_Not(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns op input of a Not node."]
    pub fn get_Not_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets op input of a Not node."]
    pub fn set_Not_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[doc = " Not opcode"]
    pub static mut op_Not: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Not nodes."]
    pub fn get_op_Not() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct an Offset node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result\n @param entity    entity to operate on"]
    pub fn new_rd_Offset(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Offset node.\n\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result\n @param entity    entity to operate on"]
    pub fn new_r_Offset(
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Offset node.\n\n @param dbgi      A pointer to debug information.\n @param mode      mode of the operations result\n @param entity    entity to operate on"]
    pub fn new_d_Offset(
        dbgi: *mut dbg_info,
        mode: *mut ir_mode,
        entity: *mut ir_entity,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Offset node.\n\n @param mode      mode of the operations result\n @param entity    entity to operate on"]
    pub fn new_Offset(mode: *mut ir_mode, entity: *mut ir_entity) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Offset\n @returns 1 if the node is a Offset node, 0 otherwise"]
    pub fn is_Offset(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns entity attribute of an Offset node."]
    pub fn get_Offset_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets entity attribute of an Offset node."]
    pub fn set_Offset_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[doc = " Offset opcode"]
    pub static mut op_Offset: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Offset nodes."]
    pub fn get_op_Offset() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Or_n_Or_left: n_Or = 0;
#[doc = "< second operand"]
pub const n_Or_n_Or_right: n_Or = 1;
pub const n_Or_n_Or_max: n_Or = 1;
#[doc = " Input numbers for Or node"]
pub type n_Or = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct an Or node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Or(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Or node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Or(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Or node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Or(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Or node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Or(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Or\n @returns 1 if the node is a Or node, 0 otherwise"]
    pub fn is_Or(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of an Or node."]
    pub fn get_Or_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of an Or node."]
    pub fn set_Or_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of an Or node."]
    pub fn get_Or_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of an Or node."]
    pub fn set_Or_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Or opcode"]
    pub static mut op_Or: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Or nodes."]
    pub fn get_op_Or() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Phi node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param mode      mode of the operations result"]
    pub fn new_rd_Phi(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Phi node.\n\n @param block     The IR block the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param mode      mode of the operations result"]
    pub fn new_r_Phi(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Phi node.\n\n @param dbgi      A pointer to debug information.\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param mode      mode of the operations result"]
    pub fn new_d_Phi(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Phi node.\n\n @param arity     size of additional inputs array\n @param in        additional inputs\n @param mode      mode of the operations result"]
    pub fn new_Phi(
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Phi\n @returns 1 if the node is a Phi node, 0 otherwise"]
    pub fn is_Phi(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of Phi preds."]
    pub fn get_Phi_n_preds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the Phi pred with index @p pos."]
    pub fn get_Phi_pred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the Phi pred with index @p pos."]
    pub fn set_Phi_pred(node: *mut ir_node, pos: ::std::os::raw::c_int, pred: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all Phi preds."]
    pub fn get_Phi_pred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Returns loop attribute of a Phi node."]
    pub fn get_Phi_loop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets loop attribute of a Phi node."]
    pub fn set_Phi_loop(node: *mut ir_node, loop_: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Phi opcode"]
    pub static mut op_Phi: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Phi nodes."]
    pub fn get_op_Phi() -> *mut ir_op;
}
#[doc = "< value which is pinned"]
pub const n_Pin_n_Pin_op: n_Pin = 0;
pub const n_Pin_n_Pin_max: n_Pin = 0;
#[doc = " Input numbers for Pin node"]
pub type n_Pin = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Pin node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_op    op"]
    pub fn new_rd_Pin(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_op: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Pin node.\n\n @param block     The IR block the node belongs to.\n @param irn_op    op"]
    pub fn new_r_Pin(block: *mut ir_node, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Pin node.\n\n @param dbgi      A pointer to debug information.\n @param irn_op    op"]
    pub fn new_d_Pin(dbgi: *mut dbg_info, irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Pin node.\n\n @param irn_op    op"]
    pub fn new_Pin(irn_op: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Pin\n @returns 1 if the node is a Pin node, 0 otherwise"]
    pub fn is_Pin(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns op input of a Pin node."]
    pub fn get_Pin_op(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets op input of a Pin node."]
    pub fn set_Pin_op(node: *mut ir_node, op: *mut ir_node);
}
extern "C" {
    #[doc = " Pin opcode"]
    pub static mut op_Pin: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Pin nodes."]
    pub fn get_op_Pin() -> *mut ir_op;
}
#[doc = "< the tuple value from which a part is extracted"]
pub const n_Proj_n_Proj_pred: n_Proj = 0;
pub const n_Proj_n_Proj_max: n_Proj = 0;
#[doc = " Input numbers for Proj node"]
pub type n_Proj = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Proj node.\n\n @param dbgi      A pointer to debug information.\n @param irn_pred  pred\n @param mode      mode of the operations result\n @param num       number of tuple component to be extracted"]
    pub fn new_rd_Proj(
        dbgi: *mut dbg_info,
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Proj node.\n\n @param irn_pred  pred\n @param mode      mode of the operations result\n @param num       number of tuple component to be extracted"]
    pub fn new_r_Proj(
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Proj node.\n\n @param dbgi      A pointer to debug information.\n @param irn_pred  pred\n @param mode      mode of the operations result\n @param num       number of tuple component to be extracted"]
    pub fn new_d_Proj(
        dbgi: *mut dbg_info,
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Proj node.\n\n @param irn_pred  pred\n @param mode      mode of the operations result\n @param num       number of tuple component to be extracted"]
    pub fn new_Proj(
        irn_pred: *mut ir_node,
        mode: *mut ir_mode,
        num: ::std::os::raw::c_uint,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Proj\n @returns 1 if the node is a Proj node, 0 otherwise"]
    pub fn is_Proj(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns pred input of a Proj node."]
    pub fn get_Proj_pred(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets pred input of a Proj node."]
    pub fn set_Proj_pred(node: *mut ir_node, pred: *mut ir_node);
}
extern "C" {
    #[doc = " Returns num attribute of a Proj node."]
    pub fn get_Proj_num(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets num attribute of a Proj node."]
    pub fn set_Proj_num(node: *mut ir_node, num: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Proj opcode"]
    pub static mut op_Proj: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Proj nodes."]
    pub fn get_op_Proj() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Raise_n_Raise_mem: n_Raise = 0;
#[doc = "< pointer to exception object to be thrown"]
pub const n_Raise_n_Raise_exo_ptr: n_Raise = 1;
pub const n_Raise_n_Raise_max: n_Raise = 1;
#[doc = " Input numbers for Raise node"]
pub type n_Raise = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Raise_pn_Raise_M: pn_Raise = 0;
#[doc = "< control flow to exception handler"]
pub const pn_Raise_pn_Raise_X: pn_Raise = 1;
pub const pn_Raise_pn_Raise_max: pn_Raise = 1;
#[doc = " Projection numbers for result of Raise node (use for Proj nodes)"]
pub type pn_Raise = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Raise node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_exo_ptr exo_ptr"]
    pub fn new_rd_Raise(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_exo_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Raise node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_exo_ptr exo_ptr"]
    pub fn new_r_Raise(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_exo_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Raise node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_exo_ptr exo_ptr"]
    pub fn new_d_Raise(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_exo_ptr: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Raise node.\n\n @param irn_mem   mem\n @param irn_exo_ptr exo_ptr"]
    pub fn new_Raise(irn_mem: *mut ir_node, irn_exo_ptr: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Raise\n @returns 1 if the node is a Raise node, 0 otherwise"]
    pub fn is_Raise(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Raise node."]
    pub fn get_Raise_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Raise node."]
    pub fn set_Raise_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns exo_ptr input of a Raise node."]
    pub fn get_Raise_exo_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets exo_ptr input of a Raise node."]
    pub fn set_Raise_exo_ptr(node: *mut ir_node, exo_ptr: *mut ir_node);
}
extern "C" {
    #[doc = " Raise opcode"]
    pub static mut op_Raise: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Raise nodes."]
    pub fn get_op_Raise() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Return_n_Return_mem: n_Return = 0;
pub const n_Return_n_Return_max: n_Return = 0;
#[doc = " Input numbers for Return node"]
pub type n_Return = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Return node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_rd_Return(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Return node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_r_Return(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Return node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_d_Return(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Return node.\n\n @param irn_mem   mem\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_Return(
        irn_mem: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Return\n @returns 1 if the node is a Return node, 0 otherwise"]
    pub fn is_Return(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Return node."]
    pub fn get_Return_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Return node."]
    pub fn set_Return_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Get the number of Return ress."]
    pub fn get_Return_n_ress(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the Return res with index @p pos."]
    pub fn get_Return_res(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the Return res with index @p pos."]
    pub fn set_Return_res(node: *mut ir_node, pos: ::std::os::raw::c_int, res: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all Return ress."]
    pub fn get_Return_res_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Return opcode"]
    pub static mut op_Return: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Return nodes."]
    pub fn get_op_Return() -> *mut ir_op;
}
#[doc = "< pointer to array to select from"]
pub const n_Sel_n_Sel_ptr: n_Sel = 0;
#[doc = "< index to select"]
pub const n_Sel_n_Sel_index: n_Sel = 1;
pub const n_Sel_n_Sel_max: n_Sel = 1;
#[doc = " Input numbers for Sel node"]
pub type n_Sel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Sel node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_ptr   ptr\n @param irn_index index\n @param type      array type"]
    pub fn new_rd_Sel(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sel node.\n\n @param block     The IR block the node belongs to.\n @param irn_ptr   ptr\n @param irn_index index\n @param type      array type"]
    pub fn new_r_Sel(
        block: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sel node.\n\n @param dbgi      A pointer to debug information.\n @param irn_ptr   ptr\n @param irn_index index\n @param type      array type"]
    pub fn new_d_Sel(
        dbgi: *mut dbg_info,
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sel node.\n\n @param irn_ptr   ptr\n @param irn_index index\n @param type      array type"]
    pub fn new_Sel(
        irn_ptr: *mut ir_node,
        irn_index: *mut ir_node,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Sel\n @returns 1 if the node is a Sel node, 0 otherwise"]
    pub fn is_Sel(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns ptr input of a Sel node."]
    pub fn get_Sel_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets ptr input of a Sel node."]
    pub fn set_Sel_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    #[doc = " Returns index input of a Sel node."]
    pub fn get_Sel_index(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets index input of a Sel node."]
    pub fn set_Sel_index(node: *mut ir_node, index: *mut ir_node);
}
extern "C" {
    #[doc = " Returns type attribute of a Sel node."]
    pub fn get_Sel_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a Sel node."]
    pub fn set_Sel_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Sel opcode"]
    pub static mut op_Sel: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Sel nodes."]
    pub fn get_op_Sel() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Shl_n_Shl_left: n_Shl = 0;
#[doc = "< second operand"]
pub const n_Shl_n_Shl_right: n_Shl = 1;
pub const n_Shl_n_Shl_max: n_Shl = 1;
#[doc = " Input numbers for Shl node"]
pub type n_Shl = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Shl node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Shl(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shl node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Shl(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shl node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Shl(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shl node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Shl(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Shl\n @returns 1 if the node is a Shl node, 0 otherwise"]
    pub fn is_Shl(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of a Shl node."]
    pub fn get_Shl_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Shl node."]
    pub fn set_Shl_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Shl node."]
    pub fn get_Shl_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Shl node."]
    pub fn set_Shl_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Shl opcode"]
    pub static mut op_Shl: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Shl nodes."]
    pub fn get_op_Shl() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Shr_n_Shr_left: n_Shr = 0;
#[doc = "< second operand"]
pub const n_Shr_n_Shr_right: n_Shr = 1;
pub const n_Shr_n_Shr_max: n_Shr = 1;
#[doc = " Input numbers for Shr node"]
pub type n_Shr = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Shr node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Shr(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shr node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Shr(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shr node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Shr(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shr node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Shr(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Shr\n @returns 1 if the node is a Shr node, 0 otherwise"]
    pub fn is_Shr(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of a Shr node."]
    pub fn get_Shr_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Shr node."]
    pub fn set_Shr_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Shr node."]
    pub fn get_Shr_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Shr node."]
    pub fn set_Shr_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Shr opcode"]
    pub static mut op_Shr: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Shr nodes."]
    pub fn get_op_Shr() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Shrs_n_Shrs_left: n_Shrs = 0;
#[doc = "< second operand"]
pub const n_Shrs_n_Shrs_right: n_Shrs = 1;
pub const n_Shrs_n_Shrs_max: n_Shrs = 1;
#[doc = " Input numbers for Shrs node"]
pub type n_Shrs = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Shrs node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Shrs(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shrs node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Shrs(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shrs node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Shrs(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Shrs node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Shrs(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Shrs\n @returns 1 if the node is a Shrs node, 0 otherwise"]
    pub fn is_Shrs(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of a Shrs node."]
    pub fn get_Shrs_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Shrs node."]
    pub fn set_Shrs_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Shrs node."]
    pub fn get_Shrs_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Shrs node."]
    pub fn set_Shrs_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Shrs opcode"]
    pub static mut op_Shrs: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Shrs nodes."]
    pub fn get_op_Shrs() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Size node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_rd_Size(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        type_: *mut ir_type,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Size node.\n\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_r_Size(irg: *mut ir_graph, mode: *mut ir_mode, type_: *mut ir_type) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Size node.\n\n @param dbgi      A pointer to debug information.\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_d_Size(dbgi: *mut dbg_info, mode: *mut ir_mode, type_: *mut ir_type)
        -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Size node.\n\n @param mode      mode of the operations result\n @param type      type to operate on"]
    pub fn new_Size(mode: *mut ir_mode, type_: *mut ir_type) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Size\n @returns 1 if the node is a Size node, 0 otherwise"]
    pub fn is_Size(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns type attribute of a Size node."]
    pub fn get_Size_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a Size node."]
    pub fn set_Size_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Size opcode"]
    pub static mut op_Size: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Size nodes."]
    pub fn get_op_Size() -> *mut ir_op;
}
#[doc = "< initial memory"]
pub const pn_Start_pn_Start_M: pn_Start = 0;
#[doc = "< frame base pointer"]
pub const pn_Start_pn_Start_P_frame_base: pn_Start = 1;
#[doc = "< function arguments"]
pub const pn_Start_pn_Start_T_args: pn_Start = 2;
pub const pn_Start_pn_Start_max: pn_Start = 2;
#[doc = " Projection numbers for result of Start node (use for Proj nodes)"]
pub type pn_Start = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Start node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to."]
    pub fn new_rd_Start(dbgi: *mut dbg_info, irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Start node.\n\n @param irg       The IR graph the node belongs to."]
    pub fn new_r_Start(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Start node.\n\n @param dbgi      A pointer to debug information."]
    pub fn new_d_Start(dbgi: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Start node."]
    pub fn new_Start() -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Start\n @returns 1 if the node is a Start node, 0 otherwise"]
    pub fn is_Start(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start opcode"]
    pub static mut op_Start: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Start nodes."]
    pub fn get_op_Start() -> *mut ir_op;
}
#[doc = "< memory dependency"]
pub const n_Store_n_Store_mem: n_Store = 0;
#[doc = "< address to store to"]
pub const n_Store_n_Store_ptr: n_Store = 1;
#[doc = "< value to store"]
pub const n_Store_n_Store_value: n_Store = 2;
pub const n_Store_n_Store_max: n_Store = 2;
#[doc = " Input numbers for Store node"]
pub type n_Store = ::std::os::raw::c_uint;
#[doc = "< memory result"]
pub const pn_Store_pn_Store_M: pn_Store = 0;
#[doc = "< control flow when no exception occurs"]
pub const pn_Store_pn_Store_X_regular: pn_Store = 1;
#[doc = "< control flow when exception occurred"]
pub const pn_Store_pn_Store_X_except: pn_Store = 2;
pub const pn_Store_pn_Store_max: pn_Store = 2;
#[doc = " Projection numbers for result of Store node (use for Proj nodes)"]
pub type pn_Store = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Store node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param irn_value value\n @param type      The type of the object which is stored at ptr (need not match with value's type)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_rd_Store(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Store node.\n\n @param block     The IR block the node belongs to.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param irn_value value\n @param type      The type of the object which is stored at ptr (need not match with value's type)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_r_Store(
        block: *mut ir_node,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Store node.\n\n @param dbgi      A pointer to debug information.\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param irn_value value\n @param type      The type of the object which is stored at ptr (need not match with value's type)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_d_Store(
        dbgi: *mut dbg_info,
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Store node.\n\n @param irn_mem   mem\n @param irn_ptr   ptr\n @param irn_value value\n @param type      The type of the object which is stored at ptr (need not match with value's type)\n @param flags     specifies alignment, volatility and pin state"]
    pub fn new_Store(
        irn_mem: *mut ir_node,
        irn_ptr: *mut ir_node,
        irn_value: *mut ir_node,
        type_: *mut ir_type,
        flags: ir_cons_flags,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Store\n @returns 1 if the node is a Store node, 0 otherwise"]
    pub fn is_Store(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns mem input of a Store node."]
    pub fn get_Store_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets mem input of a Store node."]
    pub fn set_Store_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Returns ptr input of a Store node."]
    pub fn get_Store_ptr(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets ptr input of a Store node."]
    pub fn set_Store_ptr(node: *mut ir_node, ptr: *mut ir_node);
}
extern "C" {
    #[doc = " Returns value input of a Store node."]
    pub fn get_Store_value(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets value input of a Store node."]
    pub fn set_Store_value(node: *mut ir_node, value: *mut ir_node);
}
extern "C" {
    #[doc = " Returns type attribute of a Store node."]
    pub fn get_Store_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a Store node."]
    pub fn set_Store_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Returns volatility attribute of a Store node."]
    pub fn get_Store_volatility(node: *const ir_node) -> ir_volatility;
}
extern "C" {
    #[doc = " Sets volatility attribute of a Store node."]
    pub fn set_Store_volatility(node: *mut ir_node, volatility: ir_volatility);
}
extern "C" {
    #[doc = " Returns unaligned attribute of a Store node."]
    pub fn get_Store_unaligned(node: *const ir_node) -> ir_align;
}
extern "C" {
    #[doc = " Sets unaligned attribute of a Store node."]
    pub fn set_Store_unaligned(node: *mut ir_node, unaligned: ir_align);
}
extern "C" {
    #[doc = " Store opcode"]
    pub static mut op_Store: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Store nodes."]
    pub fn get_op_Store() -> *mut ir_op;
}
#[doc = "< first operand"]
pub const n_Sub_n_Sub_left: n_Sub = 0;
#[doc = "< second operand"]
pub const n_Sub_n_Sub_right: n_Sub = 1;
pub const n_Sub_n_Sub_max: n_Sub = 1;
#[doc = " Input numbers for Sub node"]
pub type n_Sub = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Sub node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_rd_Sub(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sub node.\n\n @param block     The IR block the node belongs to.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_r_Sub(
        block: *mut ir_node,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sub node.\n\n @param dbgi      A pointer to debug information.\n @param irn_left  left\n @param irn_right right"]
    pub fn new_d_Sub(
        dbgi: *mut dbg_info,
        irn_left: *mut ir_node,
        irn_right: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sub node.\n\n @param irn_left  left\n @param irn_right right"]
    pub fn new_Sub(irn_left: *mut ir_node, irn_right: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Sub\n @returns 1 if the node is a Sub node, 0 otherwise"]
    pub fn is_Sub(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns left input of a Sub node."]
    pub fn get_Sub_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left input of a Sub node."]
    pub fn set_Sub_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns right input of a Sub node."]
    pub fn get_Sub_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right input of a Sub node."]
    pub fn set_Sub_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Sub opcode"]
    pub static mut op_Sub: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Sub nodes."]
    pub fn get_op_Sub() -> *mut ir_op;
}
#[doc = "< input selector"]
pub const n_Switch_n_Switch_selector: n_Switch = 0;
pub const n_Switch_n_Switch_max: n_Switch = 0;
#[doc = " Input numbers for Switch node"]
pub type n_Switch = ::std::os::raw::c_uint;
#[doc = "< control flow if no other case matches"]
pub const pn_Switch_pn_Switch_default: pn_Switch = 0;
pub const pn_Switch_pn_Switch_max: pn_Switch = 0;
#[doc = " Projection numbers for result of Switch node (use for Proj nodes)"]
pub type pn_Switch = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Construct a Switch node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param irn_selector selector\n @param n_outs    number of outputs (including pn_Switch_default)\n @param table     table describing mapping from input values to Proj numbers"]
    pub fn new_rd_Switch(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Switch node.\n\n @param block     The IR block the node belongs to.\n @param irn_selector selector\n @param n_outs    number of outputs (including pn_Switch_default)\n @param table     table describing mapping from input values to Proj numbers"]
    pub fn new_r_Switch(
        block: *mut ir_node,
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Switch node.\n\n @param dbgi      A pointer to debug information.\n @param irn_selector selector\n @param n_outs    number of outputs (including pn_Switch_default)\n @param table     table describing mapping from input values to Proj numbers"]
    pub fn new_d_Switch(
        dbgi: *mut dbg_info,
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Switch node.\n\n @param irn_selector selector\n @param n_outs    number of outputs (including pn_Switch_default)\n @param table     table describing mapping from input values to Proj numbers"]
    pub fn new_Switch(
        irn_selector: *mut ir_node,
        n_outs: ::std::os::raw::c_uint,
        table: *mut ir_switch_table,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Switch\n @returns 1 if the node is a Switch node, 0 otherwise"]
    pub fn is_Switch(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns selector input of a Switch node."]
    pub fn get_Switch_selector(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets selector input of a Switch node."]
    pub fn set_Switch_selector(node: *mut ir_node, selector: *mut ir_node);
}
extern "C" {
    #[doc = " Returns n_outs attribute of a Switch node."]
    pub fn get_Switch_n_outs(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets n_outs attribute of a Switch node."]
    pub fn set_Switch_n_outs(node: *mut ir_node, n_outs: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Returns table attribute of a Switch node."]
    pub fn get_Switch_table(node: *const ir_node) -> *mut ir_switch_table;
}
extern "C" {
    #[doc = " Sets table attribute of a Switch node."]
    pub fn set_Switch_table(node: *mut ir_node, table: *mut ir_switch_table);
}
extern "C" {
    #[doc = " Switch opcode"]
    pub static mut op_Switch: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Switch nodes."]
    pub fn get_op_Switch() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Sync node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_rd_Sync(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sync node.\n\n @param block     The IR block the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_r_Sync(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sync node.\n\n @param dbgi      A pointer to debug information.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_d_Sync(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Sync node.\n\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_Sync(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Sync\n @returns 1 if the node is a Sync node, 0 otherwise"]
    pub fn is_Sync(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of Sync preds."]
    pub fn get_Sync_n_preds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the Sync pred with index @p pos."]
    pub fn get_Sync_pred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the Sync pred with index @p pos."]
    pub fn set_Sync_pred(node: *mut ir_node, pos: ::std::os::raw::c_int, pred: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all Sync preds."]
    pub fn get_Sync_pred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Sync opcode"]
    pub static mut op_Sync: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Sync nodes."]
    pub fn get_op_Sync() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct a Tuple node.\n\n @param dbgi      A pointer to debug information.\n @param block     The IR block the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_rd_Tuple(
        dbgi: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Tuple node.\n\n @param block     The IR block the node belongs to.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_r_Tuple(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Tuple node.\n\n @param dbgi      A pointer to debug information.\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_d_Tuple(
        dbgi: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct a Tuple node.\n\n @param arity     size of additional inputs array\n @param in        additional inputs"]
    pub fn new_Tuple(arity: ::std::os::raw::c_int, in_: *const *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Tuple\n @returns 1 if the node is a Tuple node, 0 otherwise"]
    pub fn is_Tuple(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of Tuple preds."]
    pub fn get_Tuple_n_preds(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the Tuple pred with index @p pos."]
    pub fn get_Tuple_pred(node: *const ir_node, pos: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Set the Tuple pred with index @p pos."]
    pub fn set_Tuple_pred(node: *mut ir_node, pos: ::std::os::raw::c_int, pred: *mut ir_node);
}
extern "C" {
    #[doc = " Get an array of all Tuple preds."]
    pub fn get_Tuple_pred_arr(node: *mut ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Tuple opcode"]
    pub static mut op_Tuple: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Tuple nodes."]
    pub fn get_op_Tuple() -> *mut ir_op;
}
extern "C" {
    #[doc = " Construct an Unknown node.\n\n @param dbgi      A pointer to debug information.\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result"]
    pub fn new_rd_Unknown(
        dbgi: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Unknown node.\n\n @param irg       The IR graph the node belongs to.\n @param mode      mode of the operations result"]
    pub fn new_r_Unknown(irg: *mut ir_graph, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Unknown node.\n\n @param dbgi      A pointer to debug information.\n @param mode      mode of the operations result"]
    pub fn new_d_Unknown(dbgi: *mut dbg_info, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Construct an Unknown node.\n\n @param mode      mode of the operations result"]
    pub fn new_Unknown(mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Test if node is a Unknown\n @returns 1 if the node is a Unknown node, 0 otherwise"]
    pub fn is_Unknown(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unknown opcode"]
    pub static mut op_Unknown: *mut ir_op;
}
extern "C" {
    #[doc = " Returns opcode for Unknown nodes."]
    pub fn get_op_Unknown() -> *mut ir_op;
}
extern "C" {
    #[doc = " Test if node is a binop\n @returns 1 if the node is a binop node, 0 otherwise"]
    pub fn is_binop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if node is a entconst\n @returns 1 if the node is a entconst node, 0 otherwise"]
    pub fn is_entconst(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns entity attribute of an entconst node."]
    pub fn get_entconst_entity(node: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets entity attribute of an entconst node."]
    pub fn set_entconst_entity(node: *mut ir_node, entity: *mut ir_entity);
}
extern "C" {
    #[doc = " Test if node is a typeconst\n @returns 1 if the node is a typeconst node, 0 otherwise"]
    pub fn is_typeconst(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns type attribute of a typeconst node."]
    pub fn get_typeconst_type(node: *const ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets type attribute of a typeconst node."]
    pub fn set_typeconst_type(node: *mut ir_node, type_: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the number of predecessors without the block predecessor.\n\n @param node   the IR-node"]
    pub fn get_irn_arity(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the n-th predecessor of a node.\n This function removes Id predecessors."]
    pub fn get_irn_n(node: *const ir_node, n: ::std::os::raw::c_int) -> *mut ir_node;
}
extern "C" {
    #[doc = " Replaces the old in array by a new one that will contain the ins given in\n the parameters. Conserves the block predecessor. It copies the array passed.\n This function is necessary to adjust in arrays of blocks, calls and phis.\n \"in\" must contain all predecessors except the block that are required for\n the nodes opcode."]
    pub fn set_irn_in(node: *mut ir_node, arity: ::std::os::raw::c_int, in_: *const *mut ir_node);
}
extern "C" {
    #[doc = " Replaces the n-th predecessor of a node with a new one."]
    pub fn set_irn_n(node: *mut ir_node, n: ::std::os::raw::c_int, in_: *mut ir_node);
}
extern "C" {
    #[doc = " Appends a new predecessor to a node. This only works for nodes with\n dynamic arity!\n @returns   the number of the new input"]
    pub fn add_irn_n(node: *mut ir_node, in_: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the mode struct of node."]
    pub fn set_irn_mode(node: *mut ir_node, mode: *mut ir_mode);
}
extern "C" {
    #[doc = " Returns the mode struct of a node."]
    pub fn get_irn_mode(node: *const ir_node) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns the opcode struct of the node."]
    pub fn get_irn_op(node: *const ir_node) -> *mut ir_op;
}
extern "C" {
    #[doc = " Returns the opcode-enum of the node."]
    pub fn get_irn_opcode(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the string representation of the opcode."]
    pub fn get_irn_opname(node: *const ir_node) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the ident for a string representation of the opcode."]
    pub fn get_irn_opident(node: *const ir_node) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the visited counter of a node."]
    pub fn get_irn_visited(node: *const ir_node) -> ir_visited_t;
}
extern "C" {
    #[doc = " Sets the visited counter of a node."]
    pub fn set_irn_visited(node: *mut ir_node, visited: ir_visited_t);
}
extern "C" {
    #[doc = " Sets visited to get_irg_visited(get_irn_irg(node))."]
    pub fn mark_irn_visited(node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns 1 if visited >= get_irg_visited(get_irn_irg(node))."]
    pub fn irn_visited(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if visited >= get_irg_visited(get_irn_irg(node)). Marks the node\n visited, if it was not."]
    pub fn irn_visited_else_mark(node: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the link of a node.\n Only allowed if the graph is NOT in phase_building."]
    pub fn set_irn_link(node: *mut ir_node, link: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Returns the link of a node."]
    pub fn get_irn_link(node: *const ir_node) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns the ir_graph this node belongs to."]
    pub fn get_irn_irg(node: *const ir_node) -> *mut ir_graph;
}
extern "C" {
    #[doc = " Outputs a unique number for this node if libFIRM is compiled for\ndebugging, (configure with --enable-debug) else returns address\nof node cast to long."]
    pub fn get_irn_node_nr(node: *const ir_node) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Returns whether a node is pinned.\n A pinned node must not be moved to a different block even if the operands\n would allow this.\n Returns 1 if node is pinned, 0 otherwise."]
    pub fn get_irn_pinned(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets pin state for nodes with op pin state op_pin_state_exc_pinned.\n @p pinned should be 0 or 1, @see get_irn_pinned()"]
    pub fn set_irn_pinned(node: *mut ir_node, pinned: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " IR node constructor.\n Create a new IR node in irg, with an op, mode, arity and\n some incoming IR nodes.\n Normally you should not use this constructor directly unless you registered\n custom opcodes. For the default opcodes firm provides specific constructors.\n\n @param db    Debug info.\n @param irg   IR-graph on with this new node should be constructed.\n @param block The block the new node belongs to\n @param op    The opcode of the new node.\n @param mode  The mode of the new node.\n @param arity The arity of the new node, <0 if can be changed dynamically.\n @param in    An array of arity predecessor nodes."]
    pub fn new_ir_node(
        db: *mut dbg_info,
        irg: *mut ir_graph,
        block: *mut ir_node,
        op: *mut ir_op,
        mode: *mut ir_mode,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Creates an exact copy of @p node with same inputs and attributes in the\n same block. The copied node will not be optimized (so no CSE is performed).\n\n @param node the node to copy"]
    pub fn exact_copy(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Create an exact copy of @p node with same inputs and attributes in\n the same block but stored in the graph @p irg. The copied node will\n still point to inputs and a block in the graph of the original\n node. You must fix up these pointers after copying the node.\n\n @param node the node to copy\n @param irg the graph in which to store the copied node"]
    pub fn irn_copy_into_irg(node: *const ir_node, irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the block the node belongs to.  This is only\n possible for pinned nodes or if the graph is in pinned state.\n Otherwise the block may be incorrect.  This condition is\n now checked by an assertion.\n\n This works for all except Block.  It can return Blocks or the Bad node.\n\n To express the difference to access routines that work for all\n nodes we use infix \"nodes\" and do not name this function\n get_irn_block()."]
    pub fn get_nodes_block(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the Block of a node."]
    pub fn set_nodes_block(node: *mut ir_node, block: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the predecessor block.\n\n Returns the block corresponding to the predecessor pos of block.\n\n If we encounter the Bad node as controlflow predecessor NULL is returned."]
    pub fn get_Block_cfgpred_block(
        node: *const ir_node,
        pos: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the matured flag of a block"]
    pub fn get_Block_matured(block: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set the matured flag of a block."]
    pub fn set_Block_matured(block: *mut ir_node, matured: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " A visited flag only for block nodes.\n  @see also: get_irn_visited() inc_irg_visited() inc_irg_block_visited()"]
    pub fn get_Block_block_visited(block: *const ir_node) -> ir_visited_t;
}
extern "C" {
    #[doc = " set block visited flag"]
    pub fn set_Block_block_visited(block: *mut ir_node, visit: ir_visited_t);
}
extern "C" {
    #[doc = " Marks a block as visited by setting its visited counter"]
    pub fn mark_Block_block_visited(node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns 1 if a block is marked as visited"]
    pub fn Block_block_visited(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the entity for a Block (creating it if necessary)"]
    pub fn create_Block_entity(block: *mut ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns the head of the Phi list for this block."]
    pub fn get_Block_phis(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the head of the Phi list for this block."]
    pub fn set_Block_phis(block: *mut ir_node, phi: *mut ir_node);
}
extern "C" {
    #[doc = " Add a Phi node to the list of Block Phi's."]
    pub fn add_Block_phi(block: *mut ir_node, phi: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the Block mark (single bit)."]
    pub fn get_Block_mark(block: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the Block mark (single bit)."]
    pub fn set_Block_mark(block: *mut ir_node, mark: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Keep alive dedicated nodes.  These must be either PhiM or Block nodes."]
    pub fn add_End_keepalive(end: *mut ir_node, ka: *mut ir_node);
}
extern "C" {
    #[doc = " Sets new keep-alives.\n Beware: This might be an expensive operation if dynamic edges are enabled,\n so avoid it in the backend."]
    pub fn set_End_keepalives(end: *mut ir_node, n: ::std::os::raw::c_int, in_: *mut *mut ir_node);
}
extern "C" {
    #[doc = " Removes irn from the keep-alive set."]
    pub fn remove_End_keepalive(end: *mut ir_node, irn: *const ir_node);
}
extern "C" {
    #[doc = " Removes predecessor (a keepalive) at index @p idx from End node @p end."]
    pub fn remove_End_n(end: *mut ir_node, idx: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Removes Bads, NoMem and doublets from the keep-alive set."]
    pub fn remove_End_Bads_and_doublets(end: *mut ir_node);
}
extern "C" {
    #[doc = " Some parts of the End node are allocated separately -- their memory\n is not recovered by dead_node_elimination if a End node is dead.\n free_End() frees these data structures."]
    pub fn free_End(end: *mut ir_node);
}
extern "C" {
    #[doc = " Returns non-zero if the given Const node represents the 0 constant."]
    pub fn is_Const_null(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the given Const node represents the 1 constant."]
    pub fn is_Const_one(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the given Const node represents the constant with all bits set."]
    pub fn is_Const_all_one(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function: Return method that will be called by a call.\n\n This matches for an address at the Call ptr input, return\n the referenced entity if it has a method type."]
    pub fn get_Call_callee(call: *const ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns a human readable string for the ir_builtin_kind."]
    pub fn get_builtin_kind_name(kind: ir_builtin_kind) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns left operand of binary operation @p node."]
    pub fn get_binop_left(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets left operand of binary operation @p node."]
    pub fn set_binop_left(node: *mut ir_node, left: *mut ir_node);
}
extern "C" {
    #[doc = " Returns rights operand of binary operation @p node."]
    pub fn get_binop_right(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets right operand of binary operation @p node."]
    pub fn set_binop_right(node: *mut ir_node, right: *mut ir_node);
}
extern "C" {
    #[doc = " Tests whether a node is the X_except Proj of a fragile operation"]
    pub fn is_x_except_Proj(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tests whether a node is the X_regular Proj of a fragile operation"]
    pub fn is_x_regular_Proj(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets throws exception attribute of a fragile node\n @p throws_exception must be 0 or 1"]
    pub fn ir_set_throws_exception(node: *mut ir_node, throws_exception: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns throws_exception attribute of a fragile node"]
    pub fn ir_throws_exception(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the name of an ir_relation"]
    pub fn get_relation_string(relation: ir_relation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Calculates the negated (Complement(R)) relation, i.e. \"<\" --> \">=\""]
    pub fn get_negated_relation(relation: ir_relation) -> ir_relation;
}
extern "C" {
    #[doc = " Calculates the inversed (R^-1) relation, i.e., \"<\" --> \">\""]
    pub fn get_inversed_relation(relation: ir_relation) -> ir_relation;
}
extern "C" {
    #[doc = " Returns the next element of a block phi list."]
    pub fn get_Phi_next(phi: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the next link of a block Phi list."]
    pub fn set_Phi_next(phi: *mut ir_node, next: *mut ir_node);
}
extern "C" {
    #[doc = " Returns true if @p node is a memory operation.\n\n A memory operation is a node with an opcode that has irop_flag_uses_memory\n set. It is guaranteed to have (exactly) one memory input."]
    pub fn is_memop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the memory input of a memory operation."]
    pub fn get_memop_mem(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the memory input of a memory operation."]
    pub fn set_memop_mem(node: *mut ir_node, mem: *mut ir_node);
}
extern "C" {
    #[doc = " Adds @p pred to predecessor list of Sync node @p node."]
    pub fn add_Sync_pred(node: *mut ir_node, pred: *mut ir_node);
}
extern "C" {
    #[doc = " Removes predecessor @p i from Sync @p n"]
    pub fn remove_Sync_n(n: *mut ir_node, i: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns the number of output constraints for an ASM node."]
    pub fn get_ASM_n_constraints(node: *const ir_node) -> usize;
}
extern "C" {
    #[doc = " Returns the number of clobbered registers for an ASM node."]
    pub fn get_ASM_n_clobbers(node: *const ir_node) -> usize;
}
extern "C" {
    #[doc = " Returns operand of node if node is a Proj."]
    pub fn skip_Proj(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns operand of node if node is a Proj."]
    pub fn skip_Proj_const(node: *const ir_node) -> *const ir_node;
}
extern "C" {
    #[doc = " Returns operand of node if node is a Id."]
    pub fn skip_Id(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns corresponding operand of Tuple if node is a Proj from a Tuple."]
    pub fn skip_Tuple(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns operand of node if node is a Pin."]
    pub fn skip_Pin(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns operand of node if node is a Confirm"]
    pub fn skip_Confirm(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns true if the operation manipulates control flow"]
    pub fn is_cfop(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the operation jumps to an unknown destination.\n See irop_flag_unknown_jump for a detailed explanation"]
    pub fn is_unknown_jump(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the operation can change the control flow because\n of an exception: Call, Div, Mod, Load, Store, Alloc,\n Bad. Raise is not fragile, but a unconditional jump."]
    pub fn is_fragile_op(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the operation is a forking control flow\n  operation: Cond."]
    pub fn is_irn_forking(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the operation does not change anymemory contents although\n it has a memory input/output."]
    pub fn is_irn_const_memory(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies attributes stored in the old node to a new node.\n Assumes both have the same opcode and sufficient size.\n\n @param irg       The irg of the new_node (get_irn_irg on it might not work\n                  yet)\n @param old_node  the node where the attributes are copied from\n @param new_node  node the attributes get copies to.\n\n This copies all essential information to the new node. It does not copy\n temporary or calculated information like visited flags or results of\n dominance or loop calculations."]
    pub fn copy_node_attr(irg: *mut ir_graph, old_node: *const ir_node, new_node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the type attribute of a node n (TypeConst, Call, Alloc, Free)\n  or NULL."]
    pub fn get_irn_type_attr(n: *mut ir_node) -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the entity attribute of a node n (Address, Offset, Sel) or NULL."]
    pub fn get_irn_entity_attr(n: *mut ir_node) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns non-zero for constant-like nodes."]
    pub fn is_irn_constlike(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero for nodes that are allowed to have keep-alives and\n are neither Block nor PhiM."]
    pub fn is_irn_keep(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero for nodes that are always placed in the start block."]
    pub fn is_irn_start_block_placed(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the string representation of the jump prediction."]
    pub fn get_cond_jmp_predicate_name(pred: cond_jmp_predicate) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a pointer to the node attributes.\n Used for accessing attributes of user-defined nodes."]
    pub fn get_irn_generic_attr(node: *mut ir_node) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns a pointer to the node attributes.\n Used for accessing attributes of user-defined nodes."]
    pub fn get_irn_generic_attr_const(node: *const ir_node) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns the unique node index for the node in its graph.\n This index is used to access phase information for this node.\n @see get_idx_irn()"]
    pub fn get_irn_idx(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Sets the debug information of a node.\n\n @param n   The node.\n @param db  The debug info."]
    pub fn set_irn_dbg_info(n: *mut ir_node, db: *mut dbg_info);
}
extern "C" {
    #[doc = " Returns the debug information of an node.\n\n @param n   The node."]
    pub fn get_irn_dbg_info(n: *const ir_node) -> *mut dbg_info;
}
extern "C" {
    #[doc = " Returns a descriptive name of a node (containing type+number)"]
    pub fn gdb_node_helper(
        firm_object: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a new switch_table data structure with @p n_entries entries.\n The data structure is allocated on the obstack of @p irg."]
    pub fn ir_new_switch_table(irg: *mut ir_graph, n_entries: usize) -> *mut ir_switch_table;
}
extern "C" {
    #[doc = " Returns number of entries available in switch table @p table."]
    pub fn ir_switch_table_get_n_entries(table: *const ir_switch_table) -> usize;
}
extern "C" {
    #[doc = " Sets entry number @p entry in the switch table @p table.\n @param table  the switch table\n @param entry  entry number to set\n @param min    The minimum tarval that matches this entry\n @param max    The maximum tarval that matches this entry\n @param pn     Proj number taken on match"]
    pub fn ir_switch_table_set(
        table: *mut ir_switch_table,
        entry: usize,
        min: *mut ir_tarval,
        max: *mut ir_tarval,
        pn: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Returns maximum tarval value of switch table entry @p entry"]
    pub fn ir_switch_table_get_max(table: *const ir_switch_table, entry: usize) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns minimum tarval value of switch table entry @p entry"]
    pub fn ir_switch_table_get_min(table: *const ir_switch_table, entry: usize) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns proj number taken if switch table entry @p entry matches"]
    pub fn ir_switch_table_get_pn(
        table: *const ir_switch_table,
        entry: usize,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Duplicates switch table @p table on obstack of @p irg"]
    pub fn ir_switch_table_duplicate(
        irg: *mut ir_graph,
        table: *const ir_switch_table,
    ) -> *mut ir_switch_table;
}
extern "C" {
    #[doc = " Constructor for a Const node.\n\n Adds the node to the start block.\n\n The constant represents a target value.\n\n @param db     A pointer for debug information.\n @param irg    The IR graph the node  belongs to.\n @param mode   The mode of the operands and results.\n @param value  A value from which the tarval is made."]
    pub fn new_rd_Const_long(
        db: *mut dbg_info,
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        value: ::std::os::raw::c_long,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for a Const node.\n\n Adds the node to the start block.\n\n The constant represents a target value.\n\n @param irg    The IR graph the node  belongs to.\n @param mode   The mode of the operands and the results.\n @param value  A value from which the tarval is made."]
    pub fn new_r_Const_long(
        irg: *mut ir_graph,
        mode: *mut ir_mode,
        value: ::std::os::raw::c_long,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " @see new_rd_Const_long()\n\n @param db     A pointer for debug information.\n @param mode   The mode of the operands and results.\n @param value  A value from which the tarval is made."]
    pub fn new_d_Const_long(
        db: *mut dbg_info,
        mode: *mut ir_mode,
        value: ::std::os::raw::c_long,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Make a const from a long.\n This is just convenience for the usual\n <code>\n new_Const(mode, tarval_from_long(mode, ...))\n </code>\n pain.\n @param mode The mode for the const.\n @param value The value of the constant.\n @return A new const node."]
    pub fn new_Const_long(mode: *mut ir_mode, value: ::std::os::raw::c_long) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for memory Phi with keep-alive edge."]
    pub fn new_rd_Phi_loop(
        db: *mut dbg_info,
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for memory Phi with keep-alive edge."]
    pub fn new_r_Phi_loop(
        block: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for memory Phi with keep-alive edge."]
    pub fn new_d_Phi_loop(
        db: *mut dbg_info,
        arity: ::std::os::raw::c_int,
        in_: *mut *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for memory Phi with keep-alive edge."]
    pub fn new_Phi_loop(arity: ::std::os::raw::c_int, in_: *mut *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for a remainderless Div node.\n\n @param db      A pointer for debug information.\n @param block   The IR block the node belongs to.\n @param memop   The store needed to model exceptions\n @param op1     The first operand.\n @param op2     The second operand.\n @param pinned  Whether the node is pinned in its block."]
    pub fn new_rd_DivRL(
        db: *mut dbg_info,
        block: *mut ir_node,
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for a remainderless Div node.\n\n @param block   The IR block the node belongs to.\n @param memop   The store needed to model exceptions\n @param op1     The first operand.\n @param op2     The second operand.\n @param pinned  Whether the node is pinned in its block."]
    pub fn new_r_DivRL(
        block: *mut ir_node,
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for a remainderless Div node.\n\n Adds the node to the block in current_ir_block.\n\n @param db      A pointer for debug information.\n @param memop   The store needed to model exceptions\n @param op1     The first operand.\n @param op2     The second operand.\n @param pinned  Whether the node is pinned in its block."]
    pub fn new_d_DivRL(
        db: *mut dbg_info,
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Constructor for a remainderless Div node.\n\n Adds the node to the block in current_ir_block.\n\n @param memop   The store needed to model exceptions\n @param op1     The first operand.\n @param op2     The second operand.\n @param pinned  Whether the node is pinned in its block."]
    pub fn new_DivRL(
        memop: *mut ir_node,
        op1: *mut ir_node,
        op2: *mut ir_node,
        pinned: ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Global variable holding the graph which is currently constructed."]
    pub static mut current_ir_graph: *mut ir_graph;
}
extern "C" {
    #[doc = " Returns graph which is currently constructed"]
    pub fn get_current_ir_graph() -> *mut ir_graph;
}
extern "C" {
    #[doc = " Sets graph which is currently constructed"]
    pub fn set_current_ir_graph(graph: *mut ir_graph);
}
extern "C" {
    #[doc = " Create an immature Block.\n\n An immature Block has an unknown number of predecessors.  Predecessors\n can be added with add_immBlock_pred().  Once all predecessors are\n added the block must be matured.\n\n Adds the block to the graph in current_ir_graph.\n This constructor can only be used if the graph is in state_building."]
    pub fn new_d_immBlock(db: *mut dbg_info) -> *mut ir_node;
}
extern "C" {
    #[doc = " Create an immature Block.\n\n An immature Block has an unknown number of predecessors.  Predecessors\n can be added with add_immBlock_pred().  Once all predecessors are\n added the block must be matured.\n\n Adds the block to the graph in current_ir_graph.\n This constructor can only be used if the graph is in state_building."]
    pub fn new_immBlock() -> *mut ir_node;
}
extern "C" {
    #[doc = " Create an immature Block.\n\n An immature Block has an unknown number of predecessors.  Predecessors\n can be added with add_immBlock_pred().  Once all predecessors are\n added the block must be matured.\n\n This constructor can only be used if the graph is in state_building."]
    pub fn new_r_immBlock(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Create an immature Block.\n\n An immature Block has an unknown number of predecessors.  Predecessors\n can be added with add_immBlock_pred().  Once all predecessors are\n added the block must be matured.\n\n This constructor can only be used if the graph is in state_building."]
    pub fn new_rd_immBlock(db: *mut dbg_info, irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Add a control flow edge to an immature block."]
    pub fn add_immBlock_pred(immblock: *mut ir_node, jmp: *mut ir_node);
}
extern "C" {
    #[doc = " Finalize a Block node, when all control flows are known."]
    pub fn mature_immBlock(block: *mut ir_node);
}
extern "C" {
    #[doc = " Sets the current block in which the following constructors place the\n nodes they construct.\n\n @param target  The new current block."]
    pub fn set_cur_block(target: *mut ir_node);
}
extern "C" {
    #[doc = " Sets current block of a given graph.\n @see set_cur_block()"]
    pub fn set_r_cur_block(irg: *mut ir_graph, target: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the current block of the current graph."]
    pub fn get_cur_block() -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns current block of a given graph"]
    pub fn get_r_cur_block(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the current value of a local variable.\n\n Use this function to obtain the last definition of the local variable\n associated with pos.  pos must be less than the value passed as n_loc\n to new_ir_graph.  This call automatically inserts Phi nodes.\n\n @param pos   The position/id of the local variable.\n @param mode  The mode of the value to get."]
    pub fn get_value(pos: ::std::os::raw::c_int, mode: *mut ir_mode) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the current value of a local variable in given graph\n @see get_value()"]
    pub fn get_r_value(
        irg: *mut ir_graph,
        pos: ::std::os::raw::c_int,
        mode: *mut ir_mode,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Try to guess the mode of a local variable.\n This is done by recursively going up the control flow graph until\n we find a definition for the variable. The mode of the first found\n definition is returned. NULL in case no definition is found.\n\n @param  pos   The position/id of the local variable."]
    pub fn ir_guess_mode(pos: ::std::os::raw::c_int) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Try to guess the mode of a local variable in a given graph."]
    pub fn ir_r_guess_mode(irg: *mut ir_graph, pos: ::std::os::raw::c_int) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Memorize a new definition of a variable.\n\n Use this function to remember a new definition of the value\n associated with pos.  pos must be less than the value passed as n_loc\n to new_ir_graph.  This call is needed to automatically inserts Phi\n nodes.\n\n @param pos    The position/id of the local variable.\n @param value  The new value written to the local variable."]
    pub fn set_value(pos: ::std::os::raw::c_int, value: *mut ir_node);
}
extern "C" {
    #[doc = " Sets current value of a variable in a given graph"]
    pub fn set_r_value(irg: *mut ir_graph, pos: ::std::os::raw::c_int, value: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the current memory state.\n\n Use this function to obtain the last definition of the memory\n state.  This call automatically inserts Phi nodes for the memory\n state value."]
    pub fn get_store() -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns current memory state for a given graph\n @see get_store()"]
    pub fn get_r_store(irg: *mut ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Memorize a new definition of the memory state.\n\n Use this function to remember a new definition of the memory state.\n This call is needed to automatically inserts Phi nodes.\n\n @param store  The new memory state."]
    pub fn set_store(store: *mut ir_node);
}
extern "C" {
    #[doc = " Sets current memory state for a given graph\n @see set_store()"]
    pub fn set_r_store(irg: *mut ir_graph, store: *mut ir_node);
}
extern "C" {
    #[doc = " keep this node alive even if End is not control-reachable from it\n\n @param ka The node to keep alive."]
    pub fn keep_alive(ka: *mut ir_node);
}
extern "C" {
    #[doc = " Puts the graph into state \"phase_high\""]
    pub fn irg_finalize_cons(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " If firm is built in debug mode, verify that a newly created node is fine.\n The normal node constructors already call this function, you only need to\n call this yourself if you create new node constructors on your own."]
    pub fn verify_new_node(node: *mut ir_node);
}
extern "C" {
    #[doc = " Register a new callback for the case that the value of an uninitialized\n variable is requested."]
    pub fn ir_set_uninitialized_local_variable_func(func: uninitialized_local_variable_func_t);
}
extern "C" {
    #[doc = " Inject Confirm nodes into a graph and perform Confirm-related\n optimizations.\n\n @param irg  the graph\n\n Confirm nodes carry confirmation information, such as\n a relation between a value a and another value (or a constant)\n b.\n\n These allows to do some range dependent optimizations for Cmp,\n Abs, Min, Max nodes as well as bounds checking deletion.\n\n The heap analysis might profit also. On the other side, Confirm\n nodes disturb local optimizations, because patterns are destroyed.\n\n It is possible to avoid this by skipping Confirm nodes, but this\n is not implemented and is not cheap. The same happens with Casts\n nodes too. The current solution is to remove Confirms at a later\n pass."]
    pub fn construct_confirms(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Inject Confirm nodes into a graph.\n\n @param irg  the graph\n\n Confirm nodes carry confirmation information, such as\n a relation between a value a and another value (or a constant)\n b.\n\n These allows to do some range dependent optimizations for Cmp,\n Abs, Min, Max nodes as well as bounds checking deletion.\n\n The heap analysis might profit also. On the other side, Confirm\n nodes disturb local optimizations, because patterns are destroyed.\n\n It is possible to avoid this by skipping Confirm nodes, but this\n is not implemented and is not cheap. The same happens with Casts\n nodes too. The current solution is to remove Confirms at a later\n pass."]
    pub fn construct_confirms_only(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Remove all Confirm nodes from a graph.\n\n Note that local_optimize() can handle this if\n the remove Confirm node setting is on (set_opt_remove_Confirm(1))."]
    pub fn remove_confirms(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " return immediate dominator of block"]
    pub fn get_Block_idom(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " return immediate postdominator of a block"]
    pub fn get_Block_ipostdom(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " @return Depth of the given block in the dominator tree."]
    pub fn get_Block_dom_depth(bl: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return Depth of the given block in the postdominator tree."]
    pub fn get_Block_postdom_depth(bl: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check, if a block dominates another block.\n\n @param a   The potential dominator block.\n @param b   The potentially dominated block.\n\n @return 1, if @p a dominates @p b, else 0."]
    pub fn block_dominates(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check, if a block post dominates another block.\n\n @param a The potential post dominator block.\n @param b The potentially post dominated block.\n\n @return 1, if @p a post dominates @p b, else 0."]
    pub fn block_postdominates(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check, if a block strictly post dominates another block, i.e. a != b.\n\n @param a The potential post dominator block.\n @param b The potentially post dominated block.\n\n @return 1, if @p a strictly post dominates @p b, else 0."]
    pub fn block_strictly_postdominates(
        a: *const ir_node,
        b: *const ir_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the first node in the list of nodes dominated by a given block.\n\n Each node keeps a list of nodes which it immediately dominates. The\n nodes are queued using the @c next pointer in the @c dom_info struct.\n Each node keeps a head of this list using the pointer @c first in the\n same structure.\n\n @param block The block for which to get the first node dominated by @c bl.\n @return The first node dominated by @p bl."]
    pub fn get_Block_dominated_first(block: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the first node in the list of nodes postdominated by a given blcok."]
    pub fn get_Block_postdominated_first(bl: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the next node in a list of nodes which are dominated by some\n other node.\n @see get_Block_dominated_first().\n @param node The previous node.\n @return The next node in this list or NULL if it was the last."]
    pub fn get_Block_dominated_next(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the next node in a list of nodes which are postdominated by another node"]
    pub fn get_Block_postdominated_next(node: *const ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the deepest common dominator of two blocks.\n @param block0  A block.\n @param block1  Another block.\n @return The deepest block dominating @p block0 and @p block1."]
    pub fn ir_deepest_common_dominator(block0: *mut ir_node, block1: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Visit all nodes in the dominator subtree of a given node.\n Call a pre-visitor before descending to the children and call a\n post-visitor after returning from them.\n @param n The node to start walking from.\n @param pre The pre-visitor callback.\n @param post The post-visitor callback.\n @param env Some custom data passed to the visitors."]
    pub fn dom_tree_walk(
        n: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Visit all nodes in the post dominator subtree of a given node.\n Call a pre-visitor before descending to the children and call a\n post-visitor after returning from them.\n @param n The node to start walking from.\n @param pre The pre-visitor callback.\n @param post The post-visitor callback.\n @param env Some custom data passed to the visitors."]
    pub fn postdom_tree_walk(
        n: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walk over the dominator tree of an irg starting at the root.\n @param irg The graph.\n @param pre A pre-visitor to call.\n @param post A post-visitor to call.\n @param env Some private data to give to the visitors."]
    pub fn dom_tree_walk_irg(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walk over the post dominator tree of an irg starting at the root.\n @param irg The graph.\n @param pre A pre-visitor to call.\n @param post A post-visitor to call.\n @param env Some private data to give to the visitors."]
    pub fn postdom_tree_walk_irg(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Computes the dominance relation for all basic blocks of a given graph.\n\n Sets a flag in irg to \"dom_consistent\".\n If the control flow of the graph is changed this flag must be set to\n \"dom_inconsistent\".\n Does not compute dominator information for control dead code.  Blocks\n not reachable from Start contain the following information:\n @code\n   idom = NULL;\n   dom_depth = -1;\n   pre_num = -1;\n @endcode\n Also constructs outs information.  As this information is correct after\n the run does not free the outs information."]
    pub fn compute_doms(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Computes the post dominance relation for all basic blocks of a given graph.\n\n Sets a flag in irg to \"dom_consistent\".\n If the control flow of the graph is changed this flag must be set to\n \"dom_inconsistent\".\n Does not compute post dominator information for endless lops.  Blocks\n not reachable from End contain the following information:\n @code\n   idom = NULL;\n   dom_depth = -1;\n   pre_num = -1;\n @endcode\n Also constructs outs information.  As this information is correct after\n the run does not free the outs information."]
    pub fn compute_postdoms(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Compute the dominance frontiers for a given graph.\n The information is freed automatically when dominance info is freed."]
    pub fn ir_compute_dominance_frontiers(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Get the dominance frontier of a block.\n @param block   The block whose dominance frontier you want.\n @return        A list containing all blocks in the dominance frontier of\n                @p block (as array, use ARR_LEN() to determine the size)"]
    pub fn ir_get_dominance_frontier(block: *const ir_node) -> *mut *mut ir_node;
}
extern "C" {
    #[doc = " Convenience interface for dumping a graph as vcg file.\n\n For details on how the filename is constructed see #dump_ir_graph_ext"]
    pub fn dump_ir_graph(graph: *mut ir_graph, suffix: *const ::std::os::raw::c_char);
}
#[doc = " type for dumpers that dump information about the whole program"]
pub type ir_prog_dump_func = ::std::option::Option<unsafe extern "C" fn(out: *mut FILE)>;
extern "C" {
    #[doc = " Convenience interface for dumping the whole compilation-unit/program.\n\n The filename is constructed by combining a counter, the name of the current\n ir_prog and the given @p suffix. The file-extensions is determined by looking\n at @p mime_type.\n The file is stored into the directory specified by #ir_set_dump_path\n\n @param func       Dumper. Usually one of #dump_callgraph, #dump_typegraph,\n                   #dump_class_hierarchy, #dump_types_as_text,\n                   #dump_globals_as_text\n @param suffix     Suffix to append to the name"]
    pub fn dump_ir_prog_ext(func: ir_prog_dump_func, suffix: *const ::std::os::raw::c_char);
}
#[doc = " type for graph dumpers"]
pub type ir_graph_dump_func =
    ::std::option::Option<unsafe extern "C" fn(out: *mut FILE, graph: *mut ir_graph)>;
extern "C" {
    #[doc = " Convenience interface for dumping graphs.\n The filename is constructed by combining a counter, the name of the graphs\n entity and the given @p suffix. The file-extensions is determined by looking\n at @p mime_type.\n The file is stored into the directory specified by #ir_set_dump_path\n\n @param func      Dumper. Usually one of #dump_cfg, #dump_loop_tree,\n                  #dump_ir_graph_file\n @param graph     the graph to dump\n @param suffix    suffix"]
    pub fn dump_ir_graph_ext(
        func: ir_graph_dump_func,
        graph: *mut ir_graph,
        suffix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " A walker that calls a dumper for each graph in the program\n\n @param suffix        A suffix for the file name."]
    pub fn dump_all_ir_graphs(suffix: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Specifies output path for the dump_ir_graph function"]
    pub fn ir_set_dump_path(path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Sets a prefix filter for output functions.\n\n All graph dumpers check this name.  If the name is != \"\" and\n not a substring of the graph to be dumped, the dumper does not\n dump the graph.\n\n @param name The prefix of the name of the method entity to be dumped."]
    pub fn ir_set_dump_filter(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns the substring filter set with #ir_set_dump_filter"]
    pub fn ir_get_dump_filter() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dumps all Firm nodes of a single graph for a single procedure in\n standard xvcg format.\n\n @param graph  The firm graph to be dumped.\n @param out    Output stream the graph is written to"]
    pub fn dump_ir_graph_file(out: *mut FILE, graph: *mut ir_graph);
}
extern "C" {
    #[doc = " Dump the control flow graph of a procedure.\n\n @param graph   The firm graph whose CFG shall be dumped.\n @param out     Output stream the CFG is written to\n\n Dumps the control flow graph of a procedure in standard xvcg format."]
    pub fn dump_cfg(out: *mut FILE, graph: *mut ir_graph);
}
extern "C" {
    #[doc = " Dump the call graph.\n\n @param out    Output stream the callgraph is written to"]
    pub fn dump_callgraph(out: *mut FILE);
}
extern "C" {
    #[doc = " Dumps all type information.\n\n @param out     Output stream the typegraph is written to\n\n Dumps all type information that is somehow reachable in standard vcg\n format."]
    pub fn dump_typegraph(out: *mut FILE);
}
extern "C" {
    #[doc = " Dumps the class hierarchy with or without entities.\n\n @param out         Output stream\n\n Does not dump the global type.\n Dumps a node for all classes and the sub/supertype relations.  If\n entities is set to true also dumps the entities of classes, but without\n any additional information as the entities type.  The overwrites relation\n is dumped along with the entities."]
    pub fn dump_class_hierarchy(out: *mut FILE);
}
extern "C" {
    #[doc = " Dump a standalone loop tree, which contains the loop nodes and the firm nodes\n belonging to one loop packed together in one subgraph.\n\n @param out     Output stream\n @param graph   Dump the loop tree for this graph."]
    pub fn dump_loop_tree(out: *mut FILE, graph: *mut ir_graph);
}
extern "C" {
    #[doc = " Dumps the loop tree over the call graph.\n\n @param out   Output stream"]
    pub fn dump_callgraph_loop_tree(out: *mut FILE);
}
extern "C" {
    #[doc = " Dump type information as text.\n\n Often type graphs are unhandy in their vcg representation.  The text dumper\n represents the information for a single type more compact, but the relations\n between the types only implicitly. Dumps only 'real' types, i.e., those in\n the type list.  Does not dump the global type nor frame types or the like."]
    pub fn dump_types_as_text(out: *mut FILE);
}
extern "C" {
    #[doc = " Dumps all global variables as text.\n\n @param out         Output stream\n\n Dumps a text representation of the entities in the global type."]
    pub fn dump_globals_as_text(out: *mut FILE);
}
extern "C" {
    #[doc = " Dumps the firm nodes in the sub-loop-tree of loop to a vcg file.\n\n @param out     Output stream\n @param loop    Dump the loop tree for this loop."]
    pub fn dump_loop(out: *mut FILE, loop_: *mut ir_loop);
}
extern "C" {
    #[doc = " Write the graph and all its attributes to the file passed.\n  Does not write the nodes."]
    pub fn dump_graph_as_text(out: *mut FILE, graph: *const ir_graph);
}
extern "C" {
    #[doc = " Write the entity and all its attributes to the passed file."]
    pub fn dump_entity_to_file(out: *mut FILE, entity: *const ir_entity);
}
extern "C" {
    #[doc = " Write the type and all its attributes to the file passed."]
    pub fn dump_type_to_file(out: *mut FILE, type_: *const ir_type);
}
#[doc = "< Only dump names. Turns off all other\nflags up to 0x00010000."]
pub const ir_dump_verbosity_t_dump_verbosity_onlynames: ir_dump_verbosity_t = 1;
#[doc = "< Dump types and fields (like a type declaration)."]
pub const ir_dump_verbosity_t_dump_verbosity_fields: ir_dump_verbosity_t = 2;
#[doc = "< Dump types and methods (like a type declaration)."]
pub const ir_dump_verbosity_t_dump_verbosity_methods: ir_dump_verbosity_t = 4;
#[doc = "< Dump types and dynamic allocated fields (like a\ntype declaration). This excludes methods and\nstatic, polymorphic fields."]
pub const ir_dump_verbosity_t_dump_verbosity_nostatic: ir_dump_verbosity_t = 64;
#[doc = "< Dump all type attributes."]
pub const ir_dump_verbosity_t_dump_verbosity_typeattrs: ir_dump_verbosity_t = 8;
#[doc = "< Dump all entity attributes."]
pub const ir_dump_verbosity_t_dump_verbosity_entattrs: ir_dump_verbosity_t = 16;
#[doc = "< Dump entity constants."]
pub const ir_dump_verbosity_t_dump_verbosity_entconsts: ir_dump_verbosity_t = 32;
#[doc = "< Dump entity access statistics."]
pub const ir_dump_verbosity_t_dump_verbosity_accessStats: ir_dump_verbosity_t = 256;
#[doc = "< Turn everything on"]
pub const ir_dump_verbosity_t_dump_verbosity_max: ir_dump_verbosity_t = 1341132734;
#[doc = " Verbosity for text dumpers"]
pub type ir_dump_verbosity_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " override currently set text dump flags with new ones"]
    pub fn ir_set_dump_verbosity(verbosity: ir_dump_verbosity_t);
}
extern "C" {
    #[doc = " return currently set text dump flags"]
    pub fn ir_get_dump_verbosity() -> ir_dump_verbosity_t;
}
#[doc = " dump basic blocks as subgraphs which contain the nodes in the block"]
pub const ir_dump_flags_t_ir_dump_flag_blocks_as_subgraphs: ir_dump_flags_t = 1;
#[doc = " dump (parts of) typegraph along with nodes"]
pub const ir_dump_flags_t_ir_dump_flag_with_typegraph: ir_dump_flags_t = 2;
#[doc = " Sets the vcg flag \"display_edge_labels\" to no.\n This is necessary as xvcg fails to display graphs\n with self-edges if these edges have labels."]
pub const ir_dump_flags_t_ir_dump_flag_disable_edge_labels: ir_dump_flags_t = 4;
#[doc = " If set constants will be replicated for every use. In non blocked view\n edges from constant to block are skipped.  Vcg then layouts the graphs\n more compact, this makes them better readable."]
pub const ir_dump_flags_t_ir_dump_flag_consts_local: ir_dump_flags_t = 8;
#[doc = " if set node idx will be added to node labels"]
pub const ir_dump_flags_t_ir_dump_flag_idx_label: ir_dump_flags_t = 16;
#[doc = " if set node number will be added to node labels"]
pub const ir_dump_flags_t_ir_dump_flag_number_label: ir_dump_flags_t = 32;
#[doc = " show keepalive edges from the end node"]
pub const ir_dump_flags_t_ir_dump_flag_keepalive_edges: ir_dump_flags_t = 64;
#[doc = " dump out edges"]
pub const ir_dump_flags_t_ir_dump_flag_out_edges: ir_dump_flags_t = 128;
#[doc = " if set dumps edges from blocks to their immediate dominator"]
pub const ir_dump_flags_t_ir_dump_flag_dominance: ir_dump_flags_t = 256;
#[doc = " If set the dumper dumps loop nodes and edges from these nodes to the\n contained ir nodes."]
pub const ir_dump_flags_t_ir_dump_flag_loops: ir_dump_flags_t = 512;
#[doc = " if set (and backedge info is computed) dump backedges"]
pub const ir_dump_flags_t_ir_dump_flag_back_edges: ir_dump_flags_t = 1024;
#[doc = " dump backedges from iredges.h"]
pub const ir_dump_flags_t_ir_dump_flag_iredges: ir_dump_flags_t = 2048;
#[doc = " dump all anchor nodes, even the unused ones"]
pub const ir_dump_flags_t_ir_dump_flag_all_anchors: ir_dump_flags_t = 4096;
#[doc = " dumps marked blocks with an asterisk in the label"]
pub const ir_dump_flags_t_ir_dump_flag_show_marks: ir_dump_flags_t = 8192;
#[doc = " turns of dumping of constant entity values in typegraphs"]
pub const ir_dump_flags_t_ir_dump_flag_no_entity_values: ir_dump_flags_t = 16384;
#[doc = " dumps ld_names of entities instead of their names"]
pub const ir_dump_flags_t_ir_dump_flag_ld_names: ir_dump_flags_t = 32768;
#[doc = " dump entities in class hierarchies"]
pub const ir_dump_flags_t_ir_dump_flag_entities_in_hierarchy: ir_dump_flags_t = 65536;
#[doc = " A bitset indicating various options that affect what information is dumped\n and how exactly it is dumped. This affects the dumpers that produce vcg\n graphs."]
pub type ir_dump_flags_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " override currently set dump flags with new ones"]
    pub fn ir_set_dump_flags(flags: ir_dump_flags_t);
}
extern "C" {
    #[doc = " add flags to the currently set dump flags"]
    pub fn ir_add_dump_flags(flags: ir_dump_flags_t);
}
extern "C" {
    #[doc = " disable certain dump flags"]
    pub fn ir_remove_dump_flags(flags: ir_dump_flags_t);
}
extern "C" {
    #[doc = " return currently set dump flags"]
    pub fn ir_get_dump_flags() -> ir_dump_flags_t;
}
#[doc = " This hook is called to dump the vcg attributes of a node to a file.\n If this function returns zero, the default attributes are added, else\n removed."]
pub type dump_node_vcgattr_func = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut FILE,
        node: *const ir_node,
        local: *const ir_node,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " This hook is called to dump the vcg attributes of an edge to a file.\n If this function returns zero, the default attributes are added, else\n removed."]
pub type dump_edge_vcgattr_func = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut FILE,
        node: *const ir_node,
        to: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " This hook allows dumping of additional edges (it is called outside a node: {}\n environment)"]
pub type dump_node_edge_func =
    ::std::option::Option<unsafe extern "C" fn(out: *mut FILE, node: *const ir_node)>;
extern "C" {
    #[doc = " Sets the node_vcgattr hook."]
    pub fn set_dump_node_vcgattr_hook(hook: dump_node_vcgattr_func);
}
extern "C" {
    #[doc = " Sets the edge_vcgattr hook."]
    pub fn set_dump_edge_vcgattr_hook(hook: dump_edge_vcgattr_func);
}
extern "C" {
    #[doc = " Sets the hook to be called to dump additional edges to a node.\n @param func The hook to be called."]
    pub fn set_dump_node_edge_hook(func: dump_node_edge_func);
}
extern "C" {
    #[doc = " Returns the additional edge dump hook.\n @return The current additional edge dump hook.]"]
    pub fn get_dump_node_edge_hook() -> dump_node_edge_func;
}
extern "C" {
    #[doc = " Sets the hook to be called to dump additional edges to a block.\n @param func The hook to be called."]
    pub fn set_dump_block_edge_hook(func: dump_node_edge_func);
}
extern "C" {
    #[doc = " Returns the additional block edge dump hook.\n @return The current additional block edge dump hook."]
    pub fn get_dump_block_edge_hook() -> dump_node_edge_func;
}
#[doc = " A node info dumper callback."]
pub type dump_node_info_cb_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, out: *mut FILE, n: *const ir_node),
>;
extern "C" {
    #[doc = " Adds a new node info dumper callback. It is possible to add an unlimited\n number of callbacks. The callbacks are called at the end of the default\n info dumper.\n\n @param cb    the callback function to be called\n @param data  a context parameter\n\n @return A callback handle.\n\n @note This functionality is only available, if Firm hooks are enabled."]
    pub fn dump_add_node_info_callback(
        cb: dump_node_info_cb_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut hook_entry_t;
}
extern "C" {
    #[doc = " Removes a previously added info dumper callback.\n\n @param handle  the callback handle returned from\n                dump_add_node_info_callback()"]
    pub fn dump_remove_node_info_callback(handle: *mut hook_entry_t);
}
extern "C" {
    #[doc = " Prints the typical header used in libfirm .vcg files to file \\p out."]
    pub fn dump_vcg_header(
        out: *mut FILE,
        name: *const ::std::os::raw::c_char,
        layout: *const ::std::os::raw::c_char,
        orientation: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Prints the typical footer used in libfirm .vcg files to file \\p out."]
    pub fn dump_vcg_footer(out: *mut FILE);
}
extern "C" {
    #[doc = " Prints vcg node for a single firm graph node \\p node to \\p out."]
    pub fn dump_node(out: *mut FILE, node: *const ir_node);
}
extern "C" {
    #[doc = " Prints vcg edges for firm graph node \\p node to \\p out."]
    pub fn dump_ir_data_edges(out: *mut FILE, node: *const ir_node);
}
extern "C" {
    #[doc = " Prints the vcg identifier for firm graph node \\p node to \\p out."]
    pub fn print_nodeid(out: *mut FILE, node: *const ir_node);
}
extern "C" {
    #[doc = " Prints the commands to begin of a new vcg subgraph intended for firm block\n \\p block to \\p out."]
    pub fn dump_begin_block_subgraph(out: *mut FILE, block: *const ir_node);
}
extern "C" {
    #[doc = " Prints the commands to end a vcg subgraph of firm block \\p block to \\p out."]
    pub fn dump_end_block_subgraph(out: *mut FILE, block: *const ir_node);
}
extern "C" {
    #[doc = " Prints vcg edges for predecessors of firm block \\p block to \\p out."]
    pub fn dump_block_edges(out: *mut FILE, block: *const ir_node);
}
extern "C" {
    #[doc = " Prints vcg nodes+edges for all node in firm graph \\p irg to \\p out.\n Block nodes are turned into subgraphs containing all nodes using them as a\n parent."]
    pub fn dump_blocks_as_subgraphs(out: *mut FILE, irg: *mut ir_graph);
}
#[doc = "< Normal data flow edges."]
pub const ir_edge_kind_t_EDGE_KIND_NORMAL: ir_edge_kind_t = 0;
pub const ir_edge_kind_t_EDGE_KIND_FIRST: ir_edge_kind_t = 0;
#[doc = "< Block to Block control flow edges."]
pub const ir_edge_kind_t_EDGE_KIND_BLOCK: ir_edge_kind_t = 1;
pub const ir_edge_kind_t_EDGE_KIND_LAST: ir_edge_kind_t = 1;
#[doc = " Supported Edge kinds.\n @ingroup iredges"]
pub type ir_edge_kind_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the first edge pointing to some node.\n @note There is no order on out edges. First in this context only\n means, that you get some starting point into the list of edges.\n @param irn The node.\n @param kind The kind of the edge.\n @return The first out edge that points to this node."]
    pub fn get_irn_out_edge_first_kind(
        irn: *const ir_node,
        kind: ir_edge_kind_t,
    ) -> *const ir_edge_t;
}
extern "C" {
    #[doc = " Returns the first edge pointing to some node.\n @note There is no order on out edges. First in this context only\n means, that you get some starting point into the list of edges.\n @param irn The node.\n @return The first out edge that points to this node."]
    pub fn get_irn_out_edge_first(irn: *const ir_node) -> *const ir_edge_t;
}
extern "C" {
    #[doc = " Returns the first edge pointing to a successor block.\n\n You can navigate the list with the usual get_irn_out_edge_next().\n @param block  the Block\n @return first block successor edge"]
    pub fn get_block_succ_first(block: *const ir_node) -> *const ir_edge_t;
}
extern "C" {
    #[doc = " Returns the next edge in the out list of some node.\n @param irn The node.\n @param last The last out edge you have seen.\n @param kind the kind of edge that are iterated\n @return The next out edge in @p irn 's out list after @p last."]
    pub fn get_irn_out_edge_next(
        irn: *const ir_node,
        last: *const ir_edge_t,
        kind: ir_edge_kind_t,
    ) -> *const ir_edge_t;
}
extern "C" {
    #[doc = " Returns the source node of an edge.\n @param edge The edge.\n @return The source node of that edge."]
    pub fn get_edge_src_irn(edge: *const ir_edge_t) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the position of an edge.\n @param edge The edge.\n @return The position in the in array of that edges source."]
    pub fn get_edge_src_pos(edge: *const ir_edge_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of registered out edges for a specific kind.\n @param irn The node.\n @param kind The kind."]
    pub fn get_irn_n_edges_kind(irn: *const ir_node, kind: ir_edge_kind_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of registered out edges with EDGE_KIND_NORMAL\n @param irn The node."]
    pub fn get_irn_n_edges(irn: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks if the out edges are activated.\n\n @param irg   The graph.\n @param kind  The edge kind.\n\n @return 1, if the edges are present for the given irg, 0 if not."]
    pub fn edges_activated_kind(
        irg: *const ir_graph,
        kind: ir_edge_kind_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks if out edges with EDG_KIND_NORMAL and EDGE_KIND_BLOCK are activated.\n @param irg   The graph.\n @return 1, if the edges are present for the given irg, 0 if not."]
    pub fn edges_activated(irg: *const ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Activates the edges for an irg.\n\n @param irg   The graph to activate the edges for.\n @param kind  The edge kind."]
    pub fn edges_activate_kind(irg: *mut ir_graph, kind: ir_edge_kind_t);
}
extern "C" {
    #[doc = " Deactivates the edges for an irg.\n\n @param irg   The graph.\n @param kind  The edge kind."]
    pub fn edges_deactivate_kind(irg: *mut ir_graph, kind: ir_edge_kind_t);
}
extern "C" {
    #[doc = " Reroutes edges of a specified kind from an old node to a new one.\n\n @param old   the old node\n @param nw    the new node\n @param kind  the edge kind"]
    pub fn edges_reroute_kind(old: *mut ir_node, nw: *mut ir_node, kind: ir_edge_kind_t);
}
extern "C" {
    #[doc = " Reroutes edges of EDGE_KIND_NORMAL from an old node to a new one.\n\n @param old   the old node\n @param nw    the new node"]
    pub fn edges_reroute(old: *mut ir_node, nw: *mut ir_node);
}
extern "C" {
    #[doc = " reroutes (normal) edges from an old node to a new node, except for the\n @p exception node which keeps its input even if it is @p old."]
    pub fn edges_reroute_except(old: *mut ir_node, nw: *mut ir_node, exception: *mut ir_node);
}
extern "C" {
    #[doc = " Verifies the out edges of graph @p irg.\n @return 0 if a problem was found"]
    pub fn edges_verify(irg: *mut ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verifies a certrain kind of out edges of graph @p irg.\n @returns 0 if a problem was found"]
    pub fn edges_verify_kind(irg: *mut ir_graph, kind: ir_edge_kind_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets edge verification flag."]
    pub fn edges_init_dbg(do_dbg: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Activates data and block edges for an irg.\n If the irg phase is phase_backend, Dependence edges are\n additionally activated.\n\n @param irg  The graph to activate the edges for."]
    pub fn edges_activate(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Deactivates data and block edges for an irg.\n If the irg phase is phase_backend, Dependence edges are\n additionally deactivated.\n @param irg  The graph."]
    pub fn edges_deactivate(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Ensures that edges are activated.\n\n @param irg  the IR graph"]
    pub fn assure_edges(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Ensures that edges of a given kind are activated.\n\n @param irg   the IR graph\n @param kind  the edge kind"]
    pub fn assure_edges_kind(irg: *mut ir_graph, kind: ir_edge_kind_t);
}
extern "C" {
    #[doc = " Walks only over Block nodes in the graph. Uses the block visited\n flag, so that it can be interleaved with another walker.\n\n @param block  the start block\n @param pre    the pre visit function\n @param post   the post visit function\n @param env    the environment for the walker"]
    pub fn irg_block_edges_walk(
        block: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Graph walker following #EDGE_KIND_NORMAL edges."]
    pub fn irg_walk_edges(
        start: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
#[doc = " A container type to load/restore all optimizations"]
pub type optimization_state_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function enables/disables optimizations globally.\n\n If optimize == 0 no optimizations are performed at all.\n Default: optimize == 1."]
    pub fn set_optimize(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns global optimizations flag.\n @see set_optimize()"]
    pub fn get_optimize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables/Disables constant folding optimization.\n\n  If opt_constant_folding == 1 perform\n  constant expression evaluation (2 + 5 ==> 7, 3 < 2 ==> false)\n Default: opt_constant_folding == 1."]
    pub fn set_opt_constant_folding(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " returns 0 if constant_folding is disabled, !=0 otherwise"]
    pub fn get_opt_constant_folding() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables/Disables algebraic simplifications.\n\n  If opt_algebraic_simplification == 1 perform\n  - algebraic simplification  (a * 0 ==> 0, a or a ==> a)\n  - simplification of tests   ( !(a < b) ==> (a >= b))\n Default: opt_algebraic_simplification == 1."]
    pub fn set_opt_algebraic_simplification(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns algebraic simplification setting."]
    pub fn get_opt_algebraic_simplification() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables/Disables common subexpression elimination.\n\n If opt_cse == 1 perform common subexpression elimination.\n Default: opt_cse == 1."]
    pub fn set_opt_cse(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns constant folding optimization setting."]
    pub fn get_opt_cse() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables/Disables global constant subexpression elimination.\n\n If opt_global_cse == 1 and opt_cse == 1 perform intra procedure\n constant subexpression elimination for floating nodes.  Intra\n procedure cse gets the graph into state \"floating\".  It is necessary\n to run pre/code motion to get the graph back into state \"op_pin_state_pinned\".\n right after a call to local_optimize with global cse turned on.\n Default: opt_global_cse == 0."]
    pub fn set_opt_global_cse(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns global constant subexpression elimination setting."]
    pub fn get_opt_global_cse() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable Global Null Pointer Test Elimination.\n\n In languages where it is illegal to dereference NULL pointer, doing\n so makes the pointer \"valid non-null\", else the program will stop\n anyway by a fault.\n\n This flag should be set for C style languages."]
    pub fn set_opt_global_null_ptr_elimination(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns global null pointer test elimination setting."]
    pub fn get_opt_global_null_ptr_elimination() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save the current optimization state."]
    pub fn save_optimization_state(state: *mut optimization_state_t);
}
extern "C" {
    #[doc = " Restore the current optimization state."]
    pub fn restore_optimization_state(state: *const optimization_state_t);
}
extern "C" {
    #[doc = " Switches ALL optimizations off."]
    pub fn all_optimizations_off();
}
extern "C" {
    #[doc = " Exchanges two nodes by conserving edges leaving old (i.e.,\n pointers pointing to old).\n The nodes op will be changed to op_Deleted and you must not do anything with\n the node anymore except testing its op."]
    pub fn exchange(old: *mut ir_node, nw: *mut ir_node);
}
extern "C" {
    #[doc = " Turns a node into a \"useless\" Tuple.\n\n  Turns a node into a \"useless\" Tuple.  The Tuple node just forms a tuple\n  from several inputs. All predecessors of the tuple are set to bad and\n  should be replaced if necssary. The block predecessor remains the same.\n  This is useful if a node returning a tuple is removed, but the Projs\n  extracting values from the tuple are not available.\n\n  @param node The node to be turned into a tuple.\n  @param arity The number of values formed into a Tuple."]
    pub fn turn_into_tuple(
        node: *mut ir_node,
        arity: ::std::os::raw::c_int,
        in_: *const *mut ir_node,
    );
}
extern "C" {
    #[doc = " Walks over the passed IR graph and collects all Phi nodes as a\n list in their corresponding block (using get_Block_phis() API).\n Further it collects all Proj nodes in a list of the node producing\n the tuple. In case of nested tuples the Projs are collected in the\n node producing the outermost Tuple.\n All other link fields are cleared afterwards."]
    pub fn collect_phiprojs_and_start_block_nodes(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Introduce a new node with \"start_block_placed\" attribute. It is necesary\n to call this function so the next part_block() works without running\n collect_phiprojs_and_start_block_nodes() again."]
    pub fn collect_new_start_block_node(node: *mut ir_node);
}
extern "C" {
    #[doc = " Introduce a new phi node. It is necessary to call this function so the next\n part_block() works without running collect_phiprojs_and_start_block_nodes()\n again."]
    pub fn collect_new_phi_node(node: *mut ir_node);
}
extern "C" {
    #[doc = " Parts a block into two.  This is useful to insert other blocks within a\n  given block.\n\n Adds a new block (new_block) in the control flow before the block\n (old_block) of node. Moves node and its predecessors from old_block\n to new_block. Moves all Projs that depend on moved nodes and are in\n old_block to new_block. Moves all Phi nodes from old_block to\n new_block. Adds a Jmp node to new_block that jumps to old_block.\n\n To achieve this the routine assumes that all Phi nodes are in the\n Phi list (see get_Block_phis()) of old_block. Further it assumes\n that all Proj nodes are accessible by the link field of the nodes\n producing the Tuple. This can be established by\n collect_phiprojs_and_start_block_nodes(). part_block() conserves\n this property.\n\n @param node   The node were to break the block"]
    pub fn part_block(node: *mut ir_node);
}
extern "C" {
    #[doc = " Same as part_block() but works with out-edges so you don't have to call\n collect_phiprojs.\n This variant also removes all predecessors of the old block and returns\n it. You are responsible to add control flow predecessors to it."]
    pub fn part_block_edges(node: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Kill a node.  No other node may have this node as operand."]
    pub fn kill_node(node: *mut ir_node);
}
extern "C" {
    #[doc = " Creates a copy of the subgraph starting at node @p n.\n This currently only works for subgraphs containing only arithmetic nodes\n (= enough for everything that can be found on the const code irg).\n\n @param dbg       debug info for all newly created nodes\n @param n         the node\n @param to_block  block to copy to"]
    pub fn duplicate_subgraph(
        dbg: *mut dbg_info,
        n: *mut ir_node,
        to_block: *mut ir_node,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Applies local optimizations (see iropt.h) to all nodes reachable from node\n @p n.\n\n @param n The node to be optimized."]
    pub fn local_optimize_node(n: *mut ir_node);
}
extern "C" {
    #[doc = " Applies local optimizations to a single node.\n\n Node constructors call this function, so you should not need to call this\n manually."]
    pub fn optimize_node(n: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " Applies local optimizations (see iropt.h) to all nodes in the graph.\n\n @param irg  The graph to be optimized.\n\n After applying local_optimize_graph() to a IR-graph, Bad nodes\n only occur as predecessor of Block and Phi nodes."]
    pub fn local_optimize_graph(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Applies local optimizations (see iropt.h) to all nodes in the graph.\n\n After applying optimize_graph_df() to a IR-graph, Bad nodes\n only occur as predecessor of Block and Phi nodes.\n\n This version uses fixpoint iteration.\n\n @param irg  The graph to be optimized."]
    pub fn optimize_graph_df(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Perform local optimizations on nodes on const code irg"]
    pub fn local_opts_const_code();
}
extern "C" {
    #[doc = " Eliminates (obviously) unreachable code"]
    pub fn remove_unreachable_code(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Removes all Bad nodes from a graph.\n\n @param irg  The graph to be optimized."]
    pub fn remove_bads(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Removes all Tuple nodes from a graph.\n\n @param irg  The graph to be optimized."]
    pub fn remove_tuples(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Places an empty basic block on critical control flow edges thereby\n removing them.\n\n A critical control flow edge is an edge from a block with several\n control exits to a block with several control entries (See Muchnic\n p. 407). Exception edges are always ignored.\n\n @param irg  IR Graph"]
    pub fn remove_critical_cf_edges(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Places an empty basic block on critical control flow edges thereby\n removing them.\n\n A critical control flow edge is an edge from a block with several\n control exits to a block with several control entries (See Muchnic\n p. 407).\n\n @param irg                     IR Graph\n @param ignore_exception_edges  if non-zero, exception edges will be ignored"]
    pub fn remove_critical_cf_edges_ex(
        irg: *mut ir_graph,
        ignore_exception_edges: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Create a new ir graph to build ir for a procedure.\n\n @param ent    A pointer to an entity representing the procedure,\n               i.e., the type of the entity must be of a method type.\n\n @param n_loc  The number of local variables in this procedure including\n               the procedure parameters.\n\n This constructor generates the basic infrastructure needed to\n represent a procedure in FIRM.\n\n It allocates an ir_graph and sets the field irg of the entity ent\n to point to this graph. Further it allocates the following nodes needed\n for every procedure:\n\n - The start block containing a start node and Proj nodes for its results.\n - The end block containing an end node. This block is not matured\n   after executing new_ir_graph() as predecessors need to be added to it.\n   (Maturing a block means fixing its number of predecessors.)\n - The current block, which is empty and matured.\n\n Further it enters the global store into the data structure of the start\n block that contains all valid values in this block (set_store()).  This\n data structure is used to build the Phi nodes and removed after\n completion of the graph.  There is no path from end to start in the\n graph after calling new_ir_graph().\n\n The op_pin_state of the graph is set to \"op_pin_state_pinned\"\n if no global cse was performed on the graph.\n It is set to \"op_pin_state_floats\" if global cse was performed\n (and during construction: did actually change something).\n Code placement is necessary."]
    pub fn new_ir_graph(ent: *mut ir_entity, n_loc: ::std::os::raw::c_int) -> *mut ir_graph;
}
extern "C" {
    #[doc = " Frees the passed irgraph.\n Deallocates all nodes in this graph and the ir_graph structure.\n Sets the field irgraph in the corresponding entity to NULL.\n Removes the irgraph from the list in irprog.\n Does not free types, entities or modes that are used only by this\n graph, nor the entity standing for this graph."]
    pub fn free_ir_graph(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns the entity of an IR graph."]
    pub fn get_irg_entity(irg: *const ir_graph) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Sets the entity of an IR graph."]
    pub fn set_irg_entity(irg: *mut ir_graph, ent: *mut ir_entity);
}
extern "C" {
    #[doc = " Returns the frame type of an IR graph."]
    pub fn get_irg_frame_type(irg: *mut ir_graph) -> *mut ir_type;
}
extern "C" {
    #[doc = " Sets the frame type of an IR graph."]
    pub fn set_irg_frame_type(irg: *mut ir_graph, ftp: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the start block of an IR graph."]
    pub fn get_irg_start_block(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the start block of an IR graph."]
    pub fn set_irg_start_block(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the Start node of an IR graph."]
    pub fn get_irg_start(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the Start node of an IR graph."]
    pub fn set_irg_start(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the end block of an IR graph."]
    pub fn get_irg_end_block(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the end block of an IR graph."]
    pub fn set_irg_end_block(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the End node of an IR graph."]
    pub fn get_irg_end(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the End node of an IR graph."]
    pub fn set_irg_end(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the node that represents the frame pointer of the given IR graph."]
    pub fn get_irg_frame(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the node that represents the frame pointer of the given IR graph."]
    pub fn set_irg_frame(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the node that represents the initial memory of the given IR graph."]
    pub fn get_irg_initial_mem(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the node that represents the initial memory of the given IR graph."]
    pub fn set_irg_initial_mem(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the node that represents the argument pointer of the given IR graph."]
    pub fn get_irg_args(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the node that represents the argument pointer of the given IR graph."]
    pub fn set_irg_args(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the NoMem node of the given IR graph."]
    pub fn get_irg_no_mem(irg: *const ir_graph) -> *mut ir_node;
}
extern "C" {
    #[doc = " Sets the NoMem node of graph @p irg."]
    pub fn set_irg_no_mem(irg: *mut ir_graph, node: *mut ir_node);
}
extern "C" {
    #[doc = " Returns the number of value numbers of an IR graph."]
    pub fn get_irg_n_locs(irg: *mut ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the graph number."]
    pub fn get_irg_graph_nr(irg: *const ir_graph) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Returns the graph number. This is a unique number for the graph and is\n smaller than get_irp_last_idx()\n Note: you cannot use this number for get_irp_irg()"]
    pub fn get_irg_idx(irg: *const ir_graph) -> usize;
}
extern "C" {
    #[doc = " Returns the node for an index.\n @param irg The graph.\n @param idx The index you want the node for.\n @return    The node with that index or NULL, if there is no node with that\n            index.\n @note      The node you got might be dead.\n @see get_irn_idx()"]
    pub fn get_idx_irn(irg: *const ir_graph, idx: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    #[doc = " state: op_pin_state_pinned\nThe graph is \"op_pin_state_pinned\" if all nodes are associated with a basic block.\nIt is in state \"op_pin_state_floats\" if nodes are in arbitrary blocks.  In state\n\"op_pin_state_floats\" the block predecessor is set in all nodes, but this can be an\ninvalid block, i.e., the block is not a dominator of all the uses of\nthe node.\nThe enum op_pin_state is defined in irop.h."]
    pub fn get_irg_pinned(irg: *const ir_graph) -> op_pin_state;
}
pub const irg_callee_info_state_irg_callee_info_none: irg_callee_info_state = 0;
pub const irg_callee_info_state_irg_callee_info_consistent: irg_callee_info_state = 1;
pub const irg_callee_info_state_irg_callee_info_inconsistent: irg_callee_info_state = 2;
#[doc = " state: callee_information_state\n  Call nodes contain a list of possible callees.  This list must be\n  computed by an analysis.\n\n  It's strange that this state is administered on irg basis, as the\n  information must be computed for the whole program, or not?"]
pub type irg_callee_info_state = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the callee_info_state of an IR graph."]
    pub fn get_irg_callee_info_state(irg: *const ir_graph) -> irg_callee_info_state;
}
extern "C" {
    #[doc = " Sets the callee_info_state of an IR graph."]
    pub fn set_irg_callee_info_state(irg: *mut ir_graph, s: irg_callee_info_state);
}
extern "C" {
    #[doc = " A void * field to link arbitrary information to the node."]
    pub fn set_irg_link(irg: *mut ir_graph, thing: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Return void* field previously set by set_irg_link()"]
    pub fn get_irg_link(irg: *const ir_graph) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Increments node visited counter by one.\n  @see @ref visited_counters, irn_visited(), mark_irn_visited()"]
    pub fn inc_irg_visited(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns node visited counter.\n @see @ref visited_counters"]
    pub fn get_irg_visited(irg: *const ir_graph) -> ir_visited_t;
}
extern "C" {
    #[doc = " Sets node visited counter.\n @see @ref visited_counters"]
    pub fn set_irg_visited(irg: *mut ir_graph, i: ir_visited_t);
}
extern "C" {
    #[doc = " Returns interprocedural node visited counter.\n @see @ref visited_counters"]
    pub fn get_max_irg_visited() -> ir_visited_t;
}
extern "C" {
    #[doc = " Sets interprocedural node visited counter.\n @see @ref visited_counters"]
    pub fn set_max_irg_visited(val: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Increment interprocedural node visited counter by one.\n @see @ref visited_counters"]
    pub fn inc_max_irg_visited() -> ir_visited_t;
}
extern "C" {
    #[doc = " Increments block visited counter by one.\n  @see @ref visited_counters, Block_block_visited(), mark_Block_block_visited()"]
    pub fn inc_irg_block_visited(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns block visited counter.\n @see @ref visited_counters"]
    pub fn get_irg_block_visited(irg: *const ir_graph) -> ir_visited_t;
}
extern "C" {
    #[doc = " Sets block visited counter.\n @see @ref visited_counters"]
    pub fn set_irg_block_visited(irg: *mut ir_graph, i: ir_visited_t);
}
#[doc = "< no resource"]
pub const ir_resources_t_IR_RESOURCE_NONE: ir_resources_t = 0;
#[doc = "< Block visited flags are used."]
pub const ir_resources_t_IR_RESOURCE_BLOCK_VISITED: ir_resources_t = 1;
#[doc = "< Block mark bits are used."]
pub const ir_resources_t_IR_RESOURCE_BLOCK_MARK: ir_resources_t = 2;
#[doc = "< IR-node visited flags are used."]
pub const ir_resources_t_IR_RESOURCE_IRN_VISITED: ir_resources_t = 4;
#[doc = "< IR-node link fields are used."]
pub const ir_resources_t_IR_RESOURCE_IRN_LINK: ir_resources_t = 8;
#[doc = "< IR-loop link fields are used."]
pub const ir_resources_t_IR_RESOURCE_LOOP_LINK: ir_resources_t = 16;
#[doc = "< Block Phi lists are used."]
pub const ir_resources_t_IR_RESOURCE_PHI_LIST: ir_resources_t = 32;
#[doc = " Debug helpers: You can indicate whether you are currently using visited or\n block_visited flags. If NDEBUG is not defined, then the compiler will abort\n if 2 parties try to use the flags."]
pub type ir_resources_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Reserves resources of a graph.\n\n This is a debug tool: All code should properly allocate the resources it uses\n so if two interlocked algorithms use the same resources that bug will get\n detected."]
    pub fn ir_reserve_resources(irg: *mut ir_graph, resources: ir_resources_t);
}
extern "C" {
    #[doc = " Frees previously reserved resources."]
    pub fn ir_free_resources(irg: *mut ir_graph, resources: ir_resources_t);
}
extern "C" {
    #[doc = " Returns currently reserved resources."]
    pub fn ir_resources_reserved(irg: *const ir_graph) -> ir_resources_t;
}
#[doc = " Should not construct more nodes which irarch potentially breaks down"]
pub const ir_graph_constraints_t_IR_GRAPH_CONSTRAINT_ARCH_DEP: ir_graph_constraints_t = 1;
#[doc = " mode_b nodes have been lowered so you should not create any new nodes\n with mode_b (except for Cmp)"]
pub const ir_graph_constraints_t_IR_GRAPH_CONSTRAINT_MODEB_LOWERED: ir_graph_constraints_t = 2;
#[doc = " There are normalisations where there is no \"best\" representative.\n In this case we first normalise into 1 direction (!NORMALISATION2) and\n later in the other (NORMALISATION2)."]
pub const ir_graph_constraints_t_IR_GRAPH_CONSTRAINT_NORMALISATION2: ir_graph_constraints_t = 4;
#[doc = " Allows localopts to remove edges to unreachable code.\n Warning: It is only safe to enable this when you are sure that you\n apply all localopts to the fixpoint. (=in optimize_graph_df)"]
pub const ir_graph_constraints_t_IR_GRAPH_CONSTRAINT_OPTIMIZE_UNREACHABLE_CODE:
    ir_graph_constraints_t = 8;
#[doc = " The graph is being constructed: We have a current_block set,\n and blocks contain mapping of variable numbers to current\n values."]
pub const ir_graph_constraints_t_IR_GRAPH_CONSTRAINT_CONSTRUCTION: ir_graph_constraints_t = 16;
#[doc = " Intermediate language constructs not supported by the backend have\n been lowered."]
pub const ir_graph_constraints_t_IR_GRAPH_CONSTRAINT_TARGET_LOWERED: ir_graph_constraints_t = 32;
#[doc = " We have a backend graph: all data values have register constraints\n annotated."]
pub const ir_graph_constraints_t_IR_GRAPH_CONSTRAINT_BACKEND: ir_graph_constraints_t = 64;
#[doc = " graph constraints:\n These are typically used when lowering a graph for a target machine,\n typically you get stricter constraints the closer you get to a real\n machine."]
pub type ir_graph_constraints_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " sets @p constraints on the graph @p irg"]
    pub fn add_irg_constraints(irg: *mut ir_graph, constraints: ir_graph_constraints_t);
}
extern "C" {
    #[doc = " clears some graph constraints"]
    pub fn clear_irg_constraints(irg: *mut ir_graph, constraints: ir_graph_constraints_t);
}
extern "C" {
    #[doc = " queries whether @p irg is at least as constrained as @p constraints."]
    pub fn irg_is_constrained(
        irg: *const ir_graph,
        constraints: ir_graph_constraints_t,
    ) -> ::std::os::raw::c_int;
}
pub const ir_graph_properties_t_IR_GRAPH_PROPERTIES_NONE: ir_graph_properties_t = 0;
#[doc = " graph contains no critical edges"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_NO_CRITICAL_EDGES: ir_graph_properties_t = 1;
#[doc = " graph contains no Bad nodes"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_NO_BADS: ir_graph_properties_t = 2;
#[doc = " No tuple nodes exist in the graph"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_NO_TUPLES: ir_graph_properties_t = 4;
#[doc = " there exists no (obviously) unreachable code in the graph.\n Unreachable in this context is code that you can't reach by following\n execution flow from the start block."]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_NO_UNREACHABLE_CODE: ir_graph_properties_t = 8;
#[doc = " graph contains at most one return"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_ONE_RETURN: ir_graph_properties_t = 16;
#[doc = " dominance information about the graph is valid"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_CONSISTENT_DOMINANCE: ir_graph_properties_t = 32;
#[doc = " postdominance information about the graph is valid"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_CONSISTENT_POSTDOMINANCE: ir_graph_properties_t =
    64;
#[doc = " dominance frontiers information is calculated"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_CONSISTENT_DOMINANCE_FRONTIERS:
    ir_graph_properties_t = 128;
#[doc = " out edges (=iredges) are enable and there are no unused nodes that can be\n reached by following them"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_CONSISTENT_OUT_EDGES: ir_graph_properties_t = 256;
#[doc = " outs (irouts) are computed and up to date"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_CONSISTENT_OUTS: ir_graph_properties_t = 512;
#[doc = " loopinfo is computed and up to date"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_CONSISTENT_LOOPINFO: ir_graph_properties_t = 1024;
#[doc = " entity usage information is computed and up to date"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_CONSISTENT_ENTITY_USAGE: ir_graph_properties_t =
    2048;
#[doc = " graph contains as many returns as possible"]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTY_MANY_RETURNS: ir_graph_properties_t = 4096;
#[doc = " List of all graph properties that are only affected by control flow\n changes."]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTIES_CONTROL_FLOW: ir_graph_properties_t = 1273;
#[doc = " List of all graph properties."]
pub const ir_graph_properties_t_IR_GRAPH_PROPERTIES_ALL: ir_graph_properties_t = 8191;
#[doc = " graph state. The properties about a graph.\n Graph transformations may destroy these properties and have to explicitely\n state when they did not affect some properties and want to keep them."]
pub type ir_graph_properties_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sets the graph properties in @p props on @p irg.\n Just sets the flags, use assure_irg_properties() to also perform the analyses required."]
    pub fn add_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t);
}
extern "C" {
    #[doc = " Clears the graph properties in @p props on @p irg.\n Just sets the flags, use confirm_irg_properties() with inverted @p props to also invalidate the analysis state."]
    pub fn clear_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t);
}
extern "C" {
    #[doc = " queries whether @p irg has all properties in  @p props set."]
    pub fn irg_has_properties(
        irg: *const ir_graph,
        props: ir_graph_properties_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensures that a graph fulfills all properties stated in @p state.\n Performs graph transformations if necessary."]
    pub fn assure_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t);
}
extern "C" {
    #[doc = " Invalidates all graph properties/analysis data except the ones specified\n in @p props.\n This should be called after a transformation phase."]
    pub fn confirm_irg_properties(irg: *mut ir_graph, props: ir_graph_properties_t);
}
extern "C" {
    #[doc = " Sets a description for local value n."]
    pub fn set_irg_loc_description(
        irg: *mut ir_graph,
        n: ::std::os::raw::c_int,
        description: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns the description for local value n."]
    pub fn get_irg_loc_description(
        irg: *mut ir_graph,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns the last irn index for this graph."]
    pub fn get_irg_last_idx(irg: *const ir_graph) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Walks over the ir graph.\n\n Walks over the ir graph, starting at the node given as first argument.\n Executes pre before visiting the predecessor of a node, post after.\n irg_walk uses the visited flag in irg and the nodes to determine visited\n nodes.  It executes inc_irg_visited() to generate a new flag.\n It marks the node as visited before executing pre.\n The void* env can be used to pass status information between the\n pre and post functions.  Does not use the link fields.\n\n @param node  the start node\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n"]
    pub fn irg_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " core walker function. Does NOT call inc_irg_visited before walking."]
    pub fn irg_walk_core(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks over all reachable nodes in the ir graph.\n\n @param irg   the irg graph\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n\n Like irg_walk(), but walks over all reachable nodes in the ir\n graph, starting at the end operation.  Does not use the link field."]
    pub fn irg_walk_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks over the ir graph.\n\n Walks over the ir graph, starting at the node given as first argument.\n Executes pre before visiting the predecessor of a node, post after.\n irg_walk uses the visited flag in irg and the nodes to determine visited\n nodes.  It executes inc_irg_visited() to generate a new flag.\n It marks the node as visited before executing pre.\n The void* env can be used to pass status information between the\n pre and post functions.  Does not use the link fields.\n This walker also follows additional dependency egdes.\n\n @param node  the start node\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n"]
    pub fn irg_walk_in_or_dep(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks over all reachable nodes in the ir graph.\n\n @param irg   the irg graph\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n\n Like irg_walk(), but walks over all reachable nodes in the ir\n graph, starting at the end operation.  Does not use the link field.\n This walker also follows additional dependency egdes."]
    pub fn irg_walk_in_or_dep_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks over all reachable nodes in the graph, ensuring that nodes inside\n a basic block are visited in topological order. Nodes in different blocks\n might get visited in an interleaved order.\n\n @param irg     the irg graph\n @param walker  walker function\n @param env     environment, passed to walker\n\n Does not use the link field."]
    pub fn irg_walk_topological(
        irg: *mut ir_graph,
        walker: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Executes irg_walk(end, pre, post, env) for all irgraphs in irprog.\n\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n\n This function executes irg_walk(end, pre, post, env) for all irgraphs in irprog.\n Does not use the link field."]
    pub fn all_irg_walk(pre: irg_walk_func, post: irg_walk_func, env: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Walks only over Block nodes in the graph.\n\n @param node  the start node\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n\n This function Walks only over Block nodes in the graph. Has its own visited\n flag, so that it can be interleaved with the other walker.\n If a non-block is passed, starts at the block this node belongs to.\n If end is passed also visits kept alive blocks. Does not use the link field."]
    pub fn irg_block_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks only over reachable Block nodes in the graph.\n\n @param irg   the irg graph\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n\n Like irg_block_walk(), but walks over all reachable blocks in the\n ir graph, starting at the end block. Does not use the link field."]
    pub fn irg_block_walk_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks over all code in const_code_irg.\n\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post\n\n This function walks over all code in const_code_irg.\n Uses visited flag in const_code_irg.  Does not use the link field."]
    pub fn walk_const_code(
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks over reachable nodes in block-wise topological order, i.e. visit\n all nodes in a block before going to another block, starting at the end operation.\n Executes pre before visiting the predecessor of a node, post after.\n irg_walk_blkwise_graph() uses the visited flag in irg and the nodes to\n determine visited nodes.\n It executes inc_irg_visited() to generate a new flag. It marks the node as\n visited before executing pre.\n The void *env can be used to pass status information between the\n pre and post functions.  Does not use the link fields.\n\n @param irg   the irg graph\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post"]
    pub fn irg_walk_blkwise_graph(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks over reachable nodes in block-wise topological order, i.e. visit\n all nodes in a block before going to another block, starting at the end operation.\n Visit the blocks in dominator tree top-down order.\n Executes pre before visiting the predecessor of a node, post after.\n irg_walk_blkwise_graph() uses the visited flag in irg and the nodes to\n determine visited nodes.\n It executes inc_irg_visited() to generate a new flag. It marks the node as\n visited before executing pre.\n The void *env can be used to pass status information between the\n pre and post functions.  Does not use the link fields.\n\n @param irg   the irg graph\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post"]
    pub fn irg_walk_blkwise_dom_top_down(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Additionally walk over all anchors.\n This function visits all anchor nodes that otherwise might not been visited in a\n walk, for instance the Bad() node.\n\n @param irg   the irg graph\n @param pre   walker function, executed before the predecessor of a node are visited\n @param post  walker function, executed after the predecessor of a node are visited\n @param env   environment, passed to pre and post"]
    pub fn irg_walk_anchors(
        irg: *mut ir_graph,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walker function which does not increase the visited flag before walking.\n Do not use this unless you know what you are doing."]
    pub fn irg_walk_2(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Exports the whole irp to the given file in a textual form.\n Exports all types, all ir graphs, and the constant graph.\n\n @param filename  the name of the resulting file\n @return  0 if no errors occured, other values in case of errors"]
    pub fn ir_export(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " same as ir_export but writes to a FILE*\n @note As with any FILE* errors are indicated by ferror(output)"]
    pub fn ir_export_file(output: *mut FILE);
}
extern "C" {
    #[doc = " Imports the data stored in the given file.\n Imports any type graphs and ir graphs contained in the file.\n\n @param filename  the name of the file\n @returns 0 if no errors occured, other values in case of errors"]
    pub fn ir_import(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " same as ir_import but imports from a FILE*"]
    pub fn ir_import_file(
        input: *mut FILE,
        inputname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the predecessor pos is a backedge."]
    pub fn is_backedge(n: *const ir_node, pos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Marks edge pos as a backedge."]
    pub fn set_backedge(n: *mut ir_node, pos: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns non-zero if n has backedges."]
    pub fn has_backedges(n: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clears all backedge information."]
    pub fn clear_backedges(n: *mut ir_node);
}
#[doc = " Loop elements: loop nodes and ir nodes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union loop_element {
    #[doc = "< is either k_ir_node or k_ir_loop"]
    pub kind: *mut firm_kind,
    #[doc = "< Pointer to an ir_node element"]
    pub node: *mut ir_node,
    #[doc = "< Pointer to an ir_loop element"]
    pub son: *mut ir_loop,
    #[doc = "< Pointer to an ir_graph element (only callgraph loop trees)"]
    pub irg: *mut ir_graph,
}
#[test]
fn bindgen_test_layout_loop_element() {
    const UNINIT: ::std::mem::MaybeUninit<loop_element> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<loop_element>(),
        8usize,
        concat!("Size of: ", stringify!(loop_element))
    );
    assert_eq!(
        ::std::mem::align_of::<loop_element>(),
        8usize,
        concat!("Alignment of ", stringify!(loop_element))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).son) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(son)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).irg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loop_element),
            "::",
            stringify!(irg)
        )
    );
}
extern "C" {
    #[doc = " Sets the outermost loop in ir graph as basic access to loop tree."]
    pub fn set_irg_loop(irg: *mut ir_graph, l: *mut ir_loop);
}
extern "C" {
    #[doc = " Returns the root loop info (if exists) for an irg."]
    pub fn get_irg_loop(irg: *const ir_graph) -> *mut ir_loop;
}
extern "C" {
    #[doc = " Returns the loop n is contained in.  NULL if node is in no loop."]
    pub fn get_irn_loop(n: *const ir_node) -> *mut ir_loop;
}
extern "C" {
    #[doc = " Returns outer loop, itself if outermost."]
    pub fn get_loop_outer_loop(loop_: *const ir_loop) -> *mut ir_loop;
}
extern "C" {
    #[doc = " Returns nesting depth of this loop"]
    pub fn get_loop_depth(loop_: *const ir_loop) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the number of elements contained in loop."]
    pub fn get_loop_n_elements(loop_: *const ir_loop) -> usize;
}
extern "C" {
    #[doc = " Returns a loop element. A loop element can be interpreted as a\n kind pointer, an ir_node* or an ir_loop*."]
    pub fn get_loop_element(loop_: *const ir_loop, pos: usize) -> loop_element;
}
extern "C" {
    #[doc = " Returns a unique node number for the loop node to make output\nreadable. If libfirm_debug is not set it returns the loop cast to\nint."]
    pub fn get_loop_loop_nr(loop_: *const ir_loop) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " A field to connect additional information to a loop."]
    pub fn set_loop_link(loop_: *mut ir_loop, link: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Returns field with additional loop information.\n @see set_loop_link()"]
    pub fn get_loop_link(loop_: *const ir_loop) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Construct Intra-procedural control flow loop tree for a IR-graph.\n\n This constructs loop information resembling the program structure.\n It is useful for loop optimizations and analyses, as, e.g., finding\n iteration variables or loop invariant code motion.\n\n This algorithm computes only back edge information for Block nodes, not\n for Phi nodes.\n\n This algorithm destroyes the link field of block nodes.\n\n @param irg  the graph"]
    pub fn construct_cf_backedges(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Computes Intra-procedural control flow loop tree on demand.\n\n @param irg  the graph"]
    pub fn assure_loopinfo(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Removes all loop information.\n Resets all backedges.  Works for any construction algorithm."]
    pub fn free_loop_information(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Tests whether a value is loop invariant.\n\n @param n      The node to be tested.\n @param block  A block node.\n\n Returns non-zero, if the node n is not changed in the loop block\n belongs to or in inner loops of this block."]
    pub fn is_loop_invariant(n: *const ir_node, block: *const ir_node) -> ::std::os::raw::c_int;
}
#[doc = "< No alias."]
pub const ir_alias_relation_ir_no_alias: ir_alias_relation = 0;
#[doc = "< Unknown state, may alias."]
pub const ir_alias_relation_ir_may_alias: ir_alias_relation = 1;
#[doc = "< Sure alias."]
pub const ir_alias_relation_ir_sure_alias: ir_alias_relation = 2;
#[doc = " The alias relation of two memory addresses."]
pub type ir_alias_relation = ::std::os::raw::c_uint;
pub const ir_entity_usage_computed_state_ir_entity_usage_not_computed:
    ir_entity_usage_computed_state = 0;
pub const ir_entity_usage_computed_state_ir_entity_usage_computed: ir_entity_usage_computed_state =
    1;
#[doc = " The state of the entity usage flags."]
pub type ir_entity_usage_computed_state = ::std::os::raw::c_uint;
#[doc = "< no options, use defaults"]
pub const ir_disambiguator_options_aa_opt_none: ir_disambiguator_options = 0;
#[doc = "< always assume aliasing */\n/**< use type based alias analysis: strictly typed source language"]
pub const ir_disambiguator_options_aa_opt_always_alias: ir_disambiguator_options = 1;
pub const ir_disambiguator_options_aa_opt_type_based: ir_disambiguator_options = 2;
pub const ir_disambiguator_options_aa_opt_byte_type_may_alias: ir_disambiguator_options = 4;
#[doc = "< different addresses NEVER alias */\n/**< internal flag: options from a graph are inherited from global"]
pub const ir_disambiguator_options_aa_opt_no_alias: ir_disambiguator_options = 8;
pub const ir_disambiguator_options_aa_opt_inherited: ir_disambiguator_options = 16;
#[doc = " Possible options for the memory disambiguator."]
pub type ir_disambiguator_options = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns a human readable name for an alias relation."]
    pub fn get_ir_alias_relation_name(rel: ir_alias_relation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Determine if two memory addresses may point to the same memory location.\n This is determined by looking at the structure of the values or language\n rules determined by looking at the object types accessed.\n\n @param addr1   The first address.\n @param type1   The type of the object found at @p addr1 (\"object type\").\n @param size1   The size in bytes of the first memory access.\n @param addr2   The second address.\n @param type2   The type of the object found at @p addr2 (\"object type\").\n @param size2   The size in bytes of the second memory access."]
    pub fn get_alias_relation(
        addr1: *const ir_node,
        type1: *const ir_type,
        size1: ::std::os::raw::c_uint,
        addr2: *const ir_node,
        type2: *const ir_type,
        size2: ::std::os::raw::c_uint,
    ) -> ir_alias_relation;
}
extern "C" {
    #[doc = " Assure that the entity usage flags have been computed for the given graph.\n\n This analysis computes the entity usage state for all local variables.\n\n Even then the information is not cleaned from the variables, call\n assure_irg_entity_usage_computed() again for recomputation."]
    pub fn assure_irg_entity_usage_computed(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns the current address taken state of the globals."]
    pub fn get_irp_globals_entity_usage_state() -> ir_entity_usage_computed_state;
}
extern "C" {
    #[doc = " Sets the current address taken state of the globals.\n\n @param state  the new state"]
    pub fn set_irp_globals_entity_usage_state(state: ir_entity_usage_computed_state);
}
extern "C" {
    #[doc = " Assure that the address taken flag is computed for the global and TLS entities (variables).\n\n This is an interprocedural analysis that computes the address_taken state\n for all global and TLS variables.\n\n Note that this is a conservative estimation that by no Firm transformation\n can be invalidated, so it's only recomputed if manually triggered by calling\n set_irp_globals_entity_usage_state(ir_entity_usage_not_computed).\n Even then the information is not cleaned from the variables, call\n assure_irp_globals_entity_usage_computed() again for recomputation."]
    pub fn assure_irp_globals_entity_usage_computed();
}
extern "C" {
    #[doc = " Returns the memory disambiguator options for a graph.\n\n @param irg  the graph"]
    pub fn get_irg_memory_disambiguator_options(irg: *const ir_graph) -> ir_disambiguator_options;
}
extern "C" {
    #[doc = " Sets the memory disambiguator options for a graph.\n\n @param irg      the graph\n @param options  a set of options"]
    pub fn set_irg_memory_disambiguator_options(
        irg: *mut ir_graph,
        options: ir_disambiguator_options,
    );
}
extern "C" {
    #[doc = " Sets the global disambiguator options for all graphs not having local\n options.\n\n @param options  a set of options"]
    pub fn set_irp_memory_disambiguator_options(options: ir_disambiguator_options);
}
extern "C" {
    #[doc = " Mark all private methods, i.e. those of which all call sites are known.\n We use a very conservative estimation yet: If the address of a method is\n never taken AND its visibility is visibility_local, then it's private."]
    pub fn mark_private_methods();
}
extern "C" {
    #[doc = " If the expression referenced can be evaluated statically\n  computed_value returns a tarval representing the result,\n  tarval_bad if operation will throw an exception/produce undefined\n  behaviour, otherwise tarval_unknown."]
    pub fn computed_value(n: *const ir_node) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Applies all optimizations to n that are expressible as a pattern\n  in Firm, i.e., they need not a walk of the graph.\n  Returns a better node for n.  Does not free n -- other nodes could\n  reference n.\n\n  An equivalent optimization is applied in the constructors defined in\n  ircons.ch.  There n is freed if a better node could be found."]
    pub fn optimize_in_place(n: *mut ir_node) -> *mut ir_node;
}
extern "C" {
    #[doc = " checks whether 1 value is the negated other value"]
    pub fn ir_is_negated_value(a: *const ir_node, b: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " (conservatively) approximates all possible relations when comparing\n the value @p left and @p right"]
    pub fn ir_get_possible_cmp_relations(
        left: *const ir_node,
        right: *const ir_node,
    ) -> ir_relation;
}
extern "C" {
    #[doc = " enable/disable imprecise floatingpoint optimizations. These include rules\n like (a - x) + x = a, or a-0=a. They are wrong in several corner cases but\n may still be fine for some applications."]
    pub fn ir_allow_imprecise_float_transforms(enable: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " return 1 if imprecise float transformations are allowed."]
    pub fn ir_imprecise_float_transforms_allowed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of successors of the node:"]
    pub fn get_irn_n_outs(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the User of a node from the Def-Use edge at position pos."]
    pub fn get_irn_out(def: *const ir_node, pos: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the User and its input position from the Def-Use edge of def\n at position pos."]
    pub fn get_irn_out_ex(
        def: *const ir_node,
        pos: ::std::os::raw::c_uint,
        in_pos: *mut ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Returns the number of control flow successors, ignore keep-alives."]
    pub fn get_Block_n_cfg_outs(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the number of control flow successors, honor keep-alives."]
    pub fn get_Block_n_cfg_outs_ka(node: *const ir_node) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Access predecessor n, ignore keep-alives."]
    pub fn get_Block_cfg_out(node: *const ir_node, pos: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    #[doc = " Access predecessor n, ignore keep-alives also return its input position."]
    pub fn get_Block_cfg_out_ex(
        node: *const ir_node,
        pos: ::std::os::raw::c_uint,
        in_pos: *mut ::std::os::raw::c_int,
    ) -> *mut ir_node;
}
extern "C" {
    #[doc = " Access predecessor n, honor keep-alives."]
    pub fn get_Block_cfg_out_ka(node: *const ir_node, pos: ::std::os::raw::c_uint) -> *mut ir_node;
}
extern "C" {
    #[doc = " Walks over the graph starting at node.  Walks also if graph is in state\n \"outs_inconsistent\"."]
    pub fn irg_out_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Walks only over Block nodes in the graph.  Has its own visited\n flag, so that it can be interleaved with the other walker.\n node must be either op_Block or mode_X."]
    pub fn irg_out_block_walk(
        node: *mut ir_node,
        pre: irg_walk_func,
        post: irg_walk_func,
        env: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Computes the out edges.  Sets a flag in irg to \"outs_consistent\".  If the\n graph is changed this flag must be set to \"outs_inconsistent\".  Computes\n out edges from block to floating nodes even if graph is in state\n \"op_pin_state_floats\"."]
    pub fn compute_irg_outs(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Recomputes out edges if necessary"]
    pub fn assure_irg_outs(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Frees memory occupied by out edges data structures"]
    pub fn free_irg_outs(irg: *mut ir_graph);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " A string formatting routine for ir objects.\n\n @param fmt  The format string.\n\n This function rudimentary implements a kind of printf(3) for ir\n nodes and adds the following additional conversion specifiers.\n - @%t A type name.\n - @%e An entity name.\n - @%E An entity ld name.\n - @%T A tarval.\n - @%n A full description of a node.\n - @%O The opcode name of an ir node.\n - @%N The node number of an ir node.\n - @%m The mode name of an ir mode.\n - @%B The block node number of the nodes block.\n - @%I An ident.\n - @%D Print as many white spaces as given in the parameter.\n - @%G A debug info (if available) from the given ir node.\n - @%B A bitset.\n - @%F A Firm object (automatically detected)."]
    pub fn ir_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see ir_printf."]
    pub fn ir_fprintf(
        f: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see ir_printf."]
    pub fn ir_snprintf(
        buf: *mut ::std::os::raw::c_char,
        n: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see ir_printf."]
    pub fn ir_vprintf(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see ir_printf."]
    pub fn ir_vfprintf(
        f: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see ir_printf."]
    pub fn ir_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see ir_printf."]
    pub fn ir_obst_vprintf(
        obst: *mut obstack,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Output a tarval in human readable format to a string buffer.\n\n This function is meant for debugging purposes, the string is formated in a\n way easily understandable for humans. You should not use this for storage or\n output for other tools (like assemblers), use get_tarval_sub_bits() for these\n cases.\n\n The final string in \"buf\" is guaranteed to be zero-terminated (if buflen is\n at least 1).\n\n @param buf     the output buffer\n @param buflen  the length of the buffer\n @param tv      the tarval"]
    pub fn tarval_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        tv: *const ir_tarval,
    ) -> ::std::os::raw::c_int;
}
pub const ir_segment_t_IR_SEGMENT_FIRST: ir_segment_t = 0;
#[doc = " \"normal\" global data"]
pub const ir_segment_t_IR_SEGMENT_GLOBAL: ir_segment_t = 0;
#[doc = " thread local storage segment"]
pub const ir_segment_t_IR_SEGMENT_THREAD_LOCAL: ir_segment_t = 1;
#[doc = " the constructors segment. Contains pointers to functions which are\n executed on module initialization (program start or when a library is\n dynamically loaded)"]
pub const ir_segment_t_IR_SEGMENT_CONSTRUCTORS: ir_segment_t = 2;
#[doc = " like constructors, but functions are executed on module exit"]
pub const ir_segment_t_IR_SEGMENT_DESTRUCTORS: ir_segment_t = 3;
#[doc = " java class registry"]
pub const ir_segment_t_IR_SEGMENT_JCR: ir_segment_t = 4;
#[doc = " java class registry"]
pub const ir_segment_t_IR_SEGMENT_LAST: ir_segment_t = 4;
#[doc = " Segment\n\n A progrom has a number of special segments at the toplevel which modify\n the behaviour of the entities in them."]
pub type ir_segment_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " A variable pointing to the current irp (program or module).\n This variable should be considered constant. Moreover, one should use get_irp()\n to get access the the irp.\n\n @note Think of the irp as the \"handle\" of a program."]
    pub static mut irp: *mut ir_prog;
}
#[doc = "< no resource"]
pub const irp_resources_t_IRP_RESOURCE_NONE: irp_resources_t = 0;
#[doc = " irg link field @see set_irg_link(), get_irg_link()"]
pub const irp_resources_t_IRP_RESOURCE_IRG_LINK: irp_resources_t = 1;
#[doc = " entity link field @see set_entity_link(), get_entity_link()"]
pub const irp_resources_t_IRP_RESOURCE_ENTITY_LINK: irp_resources_t = 2;
#[doc = " type visited field @see type_visited(), mark_type_visited(),\n  inc_master_type_visited()"]
pub const irp_resources_t_IRP_RESOURCE_TYPE_VISITED: irp_resources_t = 4;
#[doc = " type link field @see set_type_link(), get_type_link()"]
pub const irp_resources_t_IRP_RESOURCE_TYPE_LINK: irp_resources_t = 8;
#[doc = " Resources usable by algorithms modifying the program"]
pub type irp_resources_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Reserve resources available for a whole program.\n\n This is a debug tool: All code should properly allocate the resources it uses\n so if two interlocked algorithms use the same resources that bug will get\n detected."]
    pub fn irp_reserve_resources(irp: *mut ir_prog, resources: irp_resources_t);
}
extern "C" {
    #[doc = " Frees resources available for a whole program."]
    pub fn irp_free_resources(irp: *mut ir_prog, resources: irp_resources_t);
}
extern "C" {
    #[doc = " Returns currently reserved whole program resources."]
    pub fn irp_resources_reserved(irp: *const ir_prog) -> irp_resources_t;
}
extern "C" {
    #[doc = " Returns the current irp from where everything in the current module\n can be accessed.\n\n @see irp"]
    pub fn get_irp() -> *mut ir_prog;
}
extern "C" {
    #[doc = " Sets current irp"]
    pub fn set_irp(irp: *mut ir_prog);
}
extern "C" {
    #[doc = " Creates a new ir_prog (a module or compilation unit).\n Note: This does not set irp to the newly created ir_prog\n\n @param name  the name of this irp (module)"]
    pub fn new_ir_prog(name: *const ::std::os::raw::c_char) -> *mut ir_prog;
}
extern "C" {
    #[doc = " Frees all memory used by irp.  Types in type list and irgs in irg\n  list must be freed by hand before."]
    pub fn free_ir_prog();
}
extern "C" {
    #[doc = " Sets the file name / executable name or the like. Initially the\nident 'no_name_set'."]
    pub fn set_irp_prog_name(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns true if the user ever set a program name"]
    pub fn irp_prog_name_is_set() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the name of the current irp."]
    pub fn get_irp_ident() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the name of the current irp."]
    pub fn get_irp_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the main routine of the compiled program."]
    pub fn get_irp_main_irg() -> *mut ir_graph;
}
extern "C" {
    #[doc = " Sets the main routine of the compiled program."]
    pub fn set_irp_main_irg(main_irg: *mut ir_graph);
}
extern "C" {
    #[doc = " returns the biggest not used irg index number"]
    pub fn get_irp_last_idx() -> usize;
}
extern "C" {
    #[doc = " Returns the number of ir graphs in the irp."]
    pub fn get_irp_n_irgs() -> usize;
}
extern "C" {
    #[doc = " Returns the ir graph at position pos in the irp."]
    pub fn get_irp_irg(pos: usize) -> *mut ir_graph;
}
extern "C" {
    #[doc = " Sets the ir graph at position pos."]
    pub fn set_irp_irg(pos: usize, irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Returns the type containing the entities for a segment.\n\n @param segment  the segment"]
    pub fn get_segment_type(segment: ir_segment_t) -> *mut ir_type;
}
extern "C" {
    #[doc = " @brief Changes a segment segment type for the program.\n (use with care)"]
    pub fn set_segment_type(segment: ir_segment_t, new_type: *mut ir_type);
}
extern "C" {
    #[doc = " Returns the \"global\" type of the irp.\n Upon creation this is an empty class type.\n This is a convenience function for get_segment_type(IR_SEGMENT_GLOBAL)"]
    pub fn get_glob_type() -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the \"thread local storage\" type of the irp.\n Upon creation this is an empty struct type.\n This is a convenience function for get_segment_type(IR_SEGMENT_THREAD_LOCAL)"]
    pub fn get_tls_type() -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns global entity with name \\p name.\n A global entity is an entity in one of the segment types.\n \\see get_glob_type(), \\see get_segment_type()"]
    pub fn ir_get_global(name: *const ::std::os::raw::c_char) -> *mut ir_entity;
}
extern "C" {
    #[doc = " Returns the number of all types in the irp.\n @deprecated"]
    pub fn get_irp_n_types() -> usize;
}
extern "C" {
    #[doc = " Returns the type at position pos in the irp.\n @deprecated"]
    pub fn get_irp_type(pos: usize) -> *mut ir_type;
}
extern "C" {
    #[doc = " Overwrites the type at position pos with another type.\n @deprecated"]
    pub fn set_irp_type(pos: usize, typ: *mut ir_type);
}
extern "C" {
    #[doc = "  Returns the graph for global constants of the current irp.\n\n   Returns an irgraph that only contains constant expressions for\n   constant entities.  Do not use any access function for this\n   graph, do not generate code for this graph.  This graph contains\n   only one block.  The constant expressions may not contain control\n   flow.\n   Walking the graph starting from any node will not reach the block\n   or any controlflow.\n   See also copy_const_code() in entity.h."]
    pub fn get_const_code_irg() -> *mut ir_graph;
}
extern "C" {
    #[doc = " Returns callee info state for the whole program.\n @see get_irg_callee_info_state()"]
    pub fn get_irp_callee_info_state() -> irg_callee_info_state;
}
extern "C" {
    #[doc = " Sets callee info state for the whole program.\n @see set_irg_callee_info_state()"]
    pub fn set_irp_callee_info_state(s: irg_callee_info_state);
}
extern "C" {
    #[doc = " Returns a new, unique label number."]
    pub fn get_irp_next_label_nr() -> ir_label_t;
}
extern "C" {
    #[doc = " Add a new global asm include."]
    pub fn add_irp_asm(asm_string: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Returns the number of global asm includes."]
    pub fn get_irp_n_asms() -> usize;
}
extern "C" {
    #[doc = " Returns the global asm include at position pos."]
    pub fn get_irp_asm(pos: usize) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Tests @p node for well-formedness.\n This mostly tests modes of inputs/outputs. Only local properties are tested\n global properties are only checked by irg_verify().\n @return NON-zero if no problems were found"]
    pub fn irn_verify(node: *const ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls irn_verify() for each node in irg. Also checks some global properties\n like all (non-phi) operands dominating their points of usage; Also checks\n if the control flow parts of a graph are valid.\n\n @param irg  the IR-graph to check\n @return NON-zero if no problems were found"]
    pub fn irg_verify(irg: *mut ir_graph) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function: Checks graph for errors, in case of error the graph\n is dumped to a file with \"-assert\" suffix and the program aborted."]
    pub fn irg_assert_verify(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Lower small CopyB nodes to Load/Store nodes, preserve medium-sized CopyB\n nodes and replace large CopyBs by a call to memcpy, depending on the given\n parameters.\n\n Every CopyB is assigned a size category as follows:\n  - 'small'  iff                  size <= max_small_size,\n  - 'medium' iff max_small_size < size <  min_large_size,\n  - 'large'  iff                  size >= min_large_size.\n\n The idea is that each backend can apply different optimizations in each\n of the three categories.\n\n For small CopyBs, the x86 backend could, e.g., emit a single SSE\n instruction to copy 16 bytes.  Other backends might just go with a series\n of Load/Stores.  Therefore, x86 would like to keep the small CopyB nodes\n around whereas other backends would not.\n For medium-sized CopyBs, the x86 backend might generate a rep-prefixed mov\n instruction.  Hence, it also wants to keep the CopyBs in these cases.  Other\n backends might handle this differently.\n For large CopyBs, a call to memcpy is worth the call overhead, so large\n CopyBs should always be lowered to memcpy calls.\n\n The lowerer performs the following actions if the CopyB is\n - 'small':  Replace it with a series of Loads/Stores\n - 'medium': Nothing.\n - 'large':  Replace it with a call to memcpy.\n\n max_small_size and min_large_size allow for a flexible configuration.\n For example, one backend could specify max_small_size == 0 and\n min_large_size == 8192 to keep all CopyB nodes smaller than 8192 and get\n memcpy Calls for all others.  Here, the set of small CopyBs is empty.\n Another backend could specify max_small_size == 63 and min_large_size == 64\n to lower all small CopyBs to Loads/Stores and all big CopyBs to memcpy.\n Hence, the set of medium-sized CopyBs is empty and this backend never\n sees a CopyB node at all.\n If memcpy is not available, min_large_size can be set to UINT_MAX to prevent\n the creation of calls to memcpy.  Note that CopyBs whose size is UINT_MAX\n will still be lowered to memcpy calls because we check if the size is greater\n *or equal* to min_large_size.  However, this should never occur in practice.\n\n @param irg                 The graph to be lowered.\n @param max_small_size      The maximum number of bytes for a CopyB node so\n                            that it is still considered 'small'.\n @param min_large_size      The minimum number of bytes for a CopyB node so\n                            that it is regarded as 'large'.\n @param allow_misalignments Backend can handle misaligned loads and stores."]
    pub fn lower_CopyB(
        irg: *mut ir_graph,
        max_small_size: ::std::os::raw::c_uint,
        min_large_size: ::std::os::raw::c_uint,
        allow_misalignments: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Lowers all Switches (Cond nodes with non-boolean mode) depending on spare_size.\n They will either remain the same or be converted into if-cascades.\n\n @param irg        The ir graph to be lowered.\n @param small_switch  If switch has <= cases then change it to an if-cascade.\n @param spare_size Allowed spare size for table switches in machine words.\n                   (Default in edgfe: 128)\n @param selector_mode mode which must be used for Switch selector"]
    pub fn lower_switch(
        irg: *mut ir_graph,
        small_switch: ::std::os::raw::c_uint,
        spare_size: ::std::os::raw::c_uint,
        selector_mode: *mut ir_mode,
    );
}
extern "C" {
    #[doc = " Replaces Offsets and TypeConsts by a real constant if possible.\n Replaces Member and Sel nodes by address computation.\n\n @param irg  the graph to lower"]
    pub fn lower_highlevel_graph(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Performs lowering on all graphs. \\see lower_highlevel_graph()."]
    pub fn lower_highlevel();
}
extern "C" {
    #[doc = " Performs lowering on all nodes of the const code irg.\n \\see lower_highlevel_graph()\n This is a separate function because the nodes of the const code irg will not\n be found with a lower_highlevel_graph(get_const_code_irg())."]
    pub fn lower_const_code();
}
#[doc = " Used as callback, whenever a lowerable mux is found. The return value\n indicates, whether the mux should be lowered. This may be used, to lower\n floating point muxes, while keeping mux nodes for integers, for example.\n\n @param mux  The mux node that may be lowered.\n @return     A non-zero value indicates that the mux should be lowered."]
pub type lower_mux_callback =
    ::std::option::Option<unsafe extern "C" fn(mux: *mut ir_node) -> ::std::os::raw::c_int>;
extern "C" {
    #[doc = " Lowers all mux nodes in the given graph. A callback function may be\n given, to select the mux nodes to lower.\n\n @param irg      The graph to lower mux nodes in.\n @param cb_func  The callback function for mux selection. Can be NULL,\n                 to lower all mux nodes."]
    pub fn lower_mux(irg: *mut ir_graph, cb_func: lower_mux_callback);
}
#[doc = " An intrinsic mapper function.\n\n @param node   the IR-node that will be mapped\n @return  non-zero if the call was mapped"]
pub type i_mapper_func =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ir_node) -> ::std::os::raw::c_int>;
#[doc = "< the record represents an intrinsic call"]
pub const ikind_INTRINSIC_CALL: ikind = 0;
#[doc = "< the record represents an intrinsic instruction"]
pub const ikind_INTRINSIC_INSTR: ikind = 1;
#[doc = " kind of an instruction record\n @see #i_record"]
pub type ikind = ::std::os::raw::c_uint;
#[doc = " An intrinsic call record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i_call_record {
    #[doc = "< must be INTRINSIC_CALL"]
    pub kind: ikind,
    #[doc = "< the entity representing an intrinsic call"]
    pub i_ent: *mut ir_entity,
    #[doc = "< the mapper function to call"]
    pub i_mapper: i_mapper_func,
}
#[test]
fn bindgen_test_layout_i_call_record() {
    const UNINIT: ::std::mem::MaybeUninit<i_call_record> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i_call_record>(),
        24usize,
        concat!("Size of: ", stringify!(i_call_record))
    );
    assert_eq!(
        ::std::mem::align_of::<i_call_record>(),
        8usize,
        concat!("Alignment of ", stringify!(i_call_record))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_call_record),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_ent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i_call_record),
            "::",
            stringify!(i_ent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_mapper) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i_call_record),
            "::",
            stringify!(i_mapper)
        )
    );
}
#[doc = " An intrinsic instruction record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i_instr_record {
    #[doc = "< must be INTRINSIC_INSTR"]
    pub kind: ikind,
    #[doc = "< the opcode that must be mapped."]
    pub op: *mut ir_op,
    #[doc = "< the mapper function to call"]
    pub i_mapper: i_mapper_func,
}
#[test]
fn bindgen_test_layout_i_instr_record() {
    const UNINIT: ::std::mem::MaybeUninit<i_instr_record> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i_instr_record>(),
        24usize,
        concat!("Size of: ", stringify!(i_instr_record))
    );
    assert_eq!(
        ::std::mem::align_of::<i_instr_record>(),
        8usize,
        concat!("Alignment of ", stringify!(i_instr_record))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_instr_record),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i_instr_record),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_mapper) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i_instr_record),
            "::",
            stringify!(i_mapper)
        )
    );
}
#[doc = " An intrinsic record."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union i_record {
    #[doc = "< kind of record"]
    pub kind: ikind,
    #[doc = "< used for call records"]
    pub i_call: i_call_record,
    #[doc = "< used for isnstruction records"]
    pub i_instr: i_instr_record,
}
#[test]
fn bindgen_test_layout_i_record() {
    const UNINIT: ::std::mem::MaybeUninit<i_record> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i_record>(),
        24usize,
        concat!("Size of: ", stringify!(i_record))
    );
    assert_eq!(
        ::std::mem::align_of::<i_record>(),
        8usize,
        concat!("Alignment of ", stringify!(i_record))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_record),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_call) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_record),
            "::",
            stringify!(i_call)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_instr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i_record),
            "::",
            stringify!(i_instr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_intrinsics_map {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new intrinsic lowering map which can be used by ir_lower_intrinsics.\n\n @param list             an array of intrinsic map records\n @param length           the length of the array\n @param part_block_used  set to 1 if part_block() is used by one of the\n                         lowering functions."]
    pub fn ir_create_intrinsics_map(
        list: *mut i_record,
        length: usize,
        part_block_used: ::std::os::raw::c_int,
    ) -> *mut ir_intrinsics_map;
}
extern "C" {
    #[doc = " Frees resources occupied by an intrisics_map created by\n ir_create_intrinsics_map()."]
    pub fn ir_free_intrinsics_map(map: *mut ir_intrinsics_map);
}
extern "C" {
    #[doc = " Go through all graphs and map calls to intrinsic functions and instructions.\n\n Every call or instruction is reported to its mapper function,\n which is responsible for rebuilding the graph."]
    pub fn ir_lower_intrinsics(irg: *mut ir_graph, map: *mut ir_intrinsics_map);
}
extern "C" {
    #[doc = " A mapper for the integer/float absolute value: type abs(type v).\n Replaces the call by a Abs node.\n\n @return always 1"]
    pub fn i_mapper_abs(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point sqrt(v): floattype sqrt(floattype v);\n\n @return 1 if the sqrt call was removed, 0 else."]
    pub fn i_mapper_sqrt(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point cbrt(v): floattype sqrt(floattype v);\n\n @return 1 if the cbrt call was removed, 0 else."]
    pub fn i_mapper_cbrt(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point pow(a, b): floattype pow(floattype a, floattype b);\n\n @return 1 if the pow call was removed, 0 else."]
    pub fn i_mapper_pow(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point exp(a): floattype exp(floattype a);\n\n @return 1 if the exp call was removed, 0 else."]
    pub fn i_mapper_exp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point exp2(a): floattype exp2(floattype a);\n\n @return 1 if the exp call was removed, 0 else."]
    pub fn i_mapper_exp2(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point exp10(a): floattype exp10(floattype a);\n\n @return 1 if the exp call was removed, 0 else."]
    pub fn i_mapper_exp10(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point log(a): floattype log(floattype a);\n\n @return 1 if the log call was removed, 0 else."]
    pub fn i_mapper_log(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point log(a): floattype log(floattype a);\n\n @return 1 if the log call was removed, 0 else."]
    pub fn i_mapper_log2(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point log(a): floattype log(floattype a);\n\n @return 1 if the log call was removed, 0 else."]
    pub fn i_mapper_log10(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point sin(a): floattype sin(floattype a);\n\n @return 1 if the sin call was removed, 0 else."]
    pub fn i_mapper_sin(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point sin(a): floattype cos(floattype a);\n\n @return 1 if the cos call was removed, 0 else."]
    pub fn i_mapper_cos(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point tan(a): floattype tan(floattype a);\n\n @return 1 if the tan call was removed, 0 else."]
    pub fn i_mapper_tan(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point asin(a): floattype asin(floattype a);\n\n @return 1 if the asin call was removed, 0 else."]
    pub fn i_mapper_asin(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point acos(a): floattype acos(floattype a);\n\n @return 1 if the tan call was removed, 0 else."]
    pub fn i_mapper_acos(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point atan(a): floattype atan(floattype a);\n\n @return 1 if the atan call was removed, 0 else."]
    pub fn i_mapper_atan(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point sinh(a): floattype sinh(floattype a);\n\n @return 1 if the sinh call was removed, 0 else."]
    pub fn i_mapper_sinh(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point cosh(a): floattype cosh(floattype a);\n\n @return 1 if the cosh call was removed, 0 else."]
    pub fn i_mapper_cosh(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the floating point tanh(a): floattype tanh(floattype a);\n\n @return 1 if the tanh call was removed, 0 else."]
    pub fn i_mapper_tanh(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the strcmp-Function: inttype strcmp(char pointer a, char pointer b);\n\n @return 1 if the strcmp call was removed, 0 else."]
    pub fn i_mapper_strcmp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the strncmp-Function: inttype strncmp(char pointer a, char pointer b, inttype len);\n\n @return 1 if the strncmp call was removed, 0 else."]
    pub fn i_mapper_strncmp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the strcpy-Function: char pointer strcpy(char pointer a, char pointer b);\n\n @return 1 if the strcpy call was removed, 0 else."]
    pub fn i_mapper_strcpy(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the strlen-Function: inttype strlen(char pointer a);\n\n @return 1 if the strlen call was removed, 0 else."]
    pub fn i_mapper_strlen(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the memcpy-Function: void pointer memcpy(void pointer d, void pointer s, inttype c);\n\n @return 1 if the memcpy call was removed, 0 else."]
    pub fn i_mapper_memcpy(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the memmove-Function: void pointer memmove(void pointer d, void pointer s, inttype c);\n\n @return 1 if the memmove call was removed, 0 else."]
    pub fn i_mapper_memmove(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the memset-Function: void pointer memset(void pointer d, inttype C, inttype len);\n\n @return 1 if the memset call was removed, 0 else."]
    pub fn i_mapper_memset(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A mapper for the strncmp-Function: inttype memcmp(void pointer a, void pointer b, inttype len);\n\n @return 1 if the strncmp call was removed, 0 else."]
    pub fn i_mapper_memcmp(call: *mut ir_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prepares code generation for the target specifiy by @p target_triple.\n \\see machine_triple describes the format of @p target_triple.\n Note that preparation isn't finished until ir_target_init() is called.\n\n @returns 1 if successfull, 0 if @p target_triple is malformed or unsupported."]
    pub fn ir_target_set(target_triple: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prepares code generation for the target specified by @p machine.\n Note that preparation isn't finished until ir_target_init() is called.\n\n @returns 1 if successfull, 0 if @p machine is malformed or unsupported."]
    pub fn ir_target_set_triple(machine: *const ir_machine_triple_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the current target.\n\n Passes an option to furhter configure the currently selected target. This is\n allowed after calling ir_target_set() or ir_target_set_triple() but not after\n calling ir_target_init().\n\n Some available options:\n\n - omitfp[=0/1]     Try to produce code without using a frame pointer.\n - pic[=0/1]        Produce position independent code.\n - noplt[=0/1]      Avoid using a PLT in position independent code.\n - verboseasm[=0/1] Annotate assembler with verbose comments\n - help             Print a list of available options.\n\n The exact set of options is target and platform specific.\n\n @returns -1 if 'help' was found, 0 if the argument could not be parsed,\n 1 if the option could be set."]
    pub fn ir_target_option(option: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes the code generation target.\n This must be called after using ir_target_set() or ir_target_set_triple()\n and possibly ir_target_option(). This defines mode_P and finalizes target and\n platform information which may be queried after."]
    pub fn ir_target_init();
}
extern "C" {
    #[doc = " Returns a message if the current target is considered experimental."]
    pub fn ir_target_experimental() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns 1 if target uses big endian byte order, 0 if little endian."]
    pub fn ir_target_big_endian() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the biggest alignment required for any target data access."]
    pub fn ir_target_biggest_alignment() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the size of a pointer in bytes for the target."]
    pub fn ir_target_pointer_size() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns 1 if target supports position independent code, 0 otherwise."]
    pub fn ir_target_supports_pic() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if unaligned memory accesses are (nearly) as fast as aligned\n ones, 0 otherwise."]
    pub fn ir_target_fast_unaligned_memaccess() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns supported float arithmetic mode or NULL if mode_D and mode_F\n are supported natively.\n Some backends like x87 can only do arithmetic in a specific float\n mode (load/store are still done in the \"normal\" float/double modes)."]
    pub fn ir_target_float_arithmetic_mode() -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns a \\see float_int_conversion_overflow_style_t that specifies\n what happens when a float value is converted to an integer and\n overflow occurs."]
    pub fn ir_target_float_int_overflow_style() -> float_int_conversion_overflow_style_t;
}
pub const ir_platform_type_t_IR_TYPE_BOOL: ir_platform_type_t = 0;
pub const ir_platform_type_t_IR_TYPE_CHAR: ir_platform_type_t = 1;
pub const ir_platform_type_t_IR_TYPE_SHORT: ir_platform_type_t = 2;
pub const ir_platform_type_t_IR_TYPE_INT: ir_platform_type_t = 3;
pub const ir_platform_type_t_IR_TYPE_LONG: ir_platform_type_t = 4;
pub const ir_platform_type_t_IR_TYPE_LONG_LONG: ir_platform_type_t = 5;
pub const ir_platform_type_t_IR_TYPE_FLOAT: ir_platform_type_t = 6;
pub const ir_platform_type_t_IR_TYPE_DOUBLE: ir_platform_type_t = 7;
pub const ir_platform_type_t_IR_TYPE_LONG_DOUBLE: ir_platform_type_t = 8;
#[doc = " Object types from the C programming language.\n This is a simplified list that does not differentiate between signed and\n unsigned types."]
pub type ir_platform_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_platform_define_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " May return an override to long long and double alignment in structs.\n\n This is a special case: Old C compilers had a bug where long long and double\n where aligned differently inside structs. Some ABIs explicitely stay\n compatible to this."]
    pub fn ir_platform_long_long_and_double_struct_align_override() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns 1 if target should compile position independent code by default."]
    pub fn ir_platform_pic_is_default() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if target and platform support thread local storage, 0 otherwise."]
    pub fn ir_platform_supports_thread_local_storage() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the value that the proprocessor define @p define should be defined\n to."]
    pub fn ir_platform_define_value(
        define: *const ir_platform_define_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the C type corresponding to wchar_t.\n Note that technically in C++ wchar_t is an own type; this function will\n return a type with the same characteristics anyway."]
    pub fn ir_platform_wchar_type() -> ir_platform_type_t;
}
extern "C" {
    #[doc = " Returns true if the wchar_t type is signed."]
    pub fn ir_platform_wchar_is_signed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns C type used for pointer sized integer like intptr_t or size_t."]
    pub fn ir_platform_intptr_type() -> ir_platform_type_t;
}
extern "C" {
    #[doc = " Returns the size of the C type @p type in bytes."]
    pub fn ir_platform_type_size(type_: ir_platform_type_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the alignment of the C type @p type in bytes."]
    pub fn ir_platform_type_align(type_: ir_platform_type_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns an ir_mode matching for the type @p type."]
    pub fn ir_platform_type_mode(
        type_: ir_platform_type_t,
        is_signed: ::std::os::raw::c_int,
    ) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns type used for va_list values. May be a pointer type, a struct type\n or NULL if the backend does not support variadic functions."]
    pub fn ir_platform_va_list_type() -> *mut ir_type;
}
extern "C" {
    #[doc = " Returns the character \"normal\" linker identifiers are prefixed with."]
    pub fn ir_platform_user_label_prefix() -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the default executable name for the target (a.out or a.exe)."]
    pub fn ir_platform_default_exe_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns name mangled for platform. This usually adds the user_label_prefix\n ('_' on win32, macOS, \"\" on ELF based systems) in front of the identifier."]
    pub fn ir_platform_mangle_global(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the first element in the list of target preprocessor defines."]
    pub fn ir_platform_define_first() -> *const ir_platform_define_t;
}
extern "C" {
    #[doc = " Returns the element following @p define in the list of target preprocessor\n defines or NULL if @p define is the last element."]
    pub fn ir_platform_define_next(
        define: *const ir_platform_define_t,
    ) -> *const ir_platform_define_t;
}
extern "C" {
    #[doc = " Returns the name of the preprocessor define @p define."]
    pub fn ir_platform_define_name(
        define: *const ir_platform_define_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parses machine triple string @p triple_string into a ir_machine_triple_t\n structure."]
    pub fn ir_parse_machine_triple(
        triple_string: *const ::std::os::raw::c_char,
    ) -> *mut ir_machine_triple_t;
}
extern "C" {
    #[doc = " Creates a machine triple matching the host machine. Always succeeds\n or calls panic()."]
    pub fn ir_get_host_machine_triple() -> *mut ir_machine_triple_t;
}
extern "C" {
    #[doc = " Returns the CPU type part of machine triple @p triple."]
    pub fn ir_triple_get_cpu_type(
        triple: *const ir_machine_triple_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the manufacturer part of machine triple @p triple."]
    pub fn ir_triple_get_manufacturer(
        triple: *const ir_machine_triple_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the operating system part of machine triple @p triple."]
    pub fn ir_triple_get_operating_system(
        triple: *const ir_machine_triple_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Changes CPU type of @p triple to @p cpu_type."]
    pub fn ir_triple_set_cpu_type(
        triple: *mut ir_machine_triple_t,
        cpu_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Frees the machine triple structure @p triple."]
    pub fn ir_free_machine_triple(triple: *mut ir_machine_triple_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_timer_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Switch to real-time scheduling.\n This shall make measurements more precise.\n @note Does not work for all operating systems.\n @note You could need special user privileges.\n @return 0 on success, else UNIX error code."]
    pub fn ir_timer_enter_high_priority() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Leave the high priority mode.\n @see ir_timer_enter_high_priority()\n @return 0 on success, else UNIX error code."]
    pub fn ir_timer_leave_high_priority() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new timer\n @return The timer.\n @see #ir_timer_t"]
    pub fn ir_timer_new() -> *mut ir_timer_t;
}
extern "C" {
    #[doc = " free memory occupied by a timer\n @param timer The timer"]
    pub fn ir_timer_free(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Start a timer.\n @param timer The timer."]
    pub fn ir_timer_start(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Reset a timer and start it.\n @param timer The timer."]
    pub fn ir_timer_reset_and_start(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Reset a timer.\n @param timer The timer."]
    pub fn ir_timer_reset(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Stop a timer.\n Stopping a stopped timer has no effect.\n @param timer The timer."]
    pub fn ir_timer_stop(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Set currently running timer as parent to @p timer"]
    pub fn ir_timer_init_parent(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Push a timer of the timer stack. This automatically\n stop the previous timer on tos and start the new one.\n\n @param timer   The timer to push on stack.\n @return non-zero on succes, zero if the timer is already on the stack."]
    pub fn ir_timer_push(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Pop the current timer. This automatically stops it and\n start the timer that is now on the stack.\n @return the popped timer"]
    pub fn ir_timer_pop(timer: *mut ir_timer_t);
}
extern "C" {
    #[doc = " Returns the number of milliseconds, the timer has elapsed.\n @param timer The timer.\n @return The number of milliseconds the timer is (was) running."]
    pub fn ir_timer_elapsed_msec(timer: *const ir_timer_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Returns the number of microseconds, the timer has elapsed.\n @param timer The timer.\n @return The number of milliseconds the timer is (was) running."]
    pub fn ir_timer_elapsed_usec(timer: *const ir_timer_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Returns the number of seconds, the timer has elapsed."]
    pub fn ir_timer_elapsed_sec(timer: *const ir_timer_t) -> f64;
}
extern "C" {
    #[doc = " Constructor function for new tarvals.\n\n @param str   The string representing the target value\n @param len   The length of the string\n @param mode  The mode requested for the result tarval\n\n This function creates a new tarval representing the value represented\n by a CString, aka char array. If a tarval representing this value already\n exists, this tarval is returned instead of a new one. So tarvals are\n directly comparable since their representation is unique.\n\n This function accepts the following strings:\n\n if mode is int_number:\n  - [+-]?0[xX][0-9a-fA-F]+ (hexadecimal representation)\n  - [+-]?0[0-7]*           (octal representation)\n  - [+-]?0[bB][01]+        (binary representation)\n  - [+-]?[1-9][0-9]*       (decimal representation)\n\n if mode is float_number:\n  - [+-]?(decimal int) (. (decimal int))? ([eE][+-]?(decimal int))?\n\n if mode is boolean: true, True, TRUE ... False... 0, 1,\n\n if mode is reference: \"null\" and the same as for int_number\n\n Leading and/or trailing spaces are ignored\n\n @return\n   A tarval of proper type representing the requested value is returned.\n   Tarvals are unique, so for any value/mode pair at most one tarval will\n   exist, which will be returned upon further requests with an identical\n   value/mode pair.\n\n @note\n   Behaviour is undefined if the number in @p str is malformed. Debug builds\n   should fail assertions in these cases.\n\n @sa\n   irmode.h for predefined modes\n   new_tarval_from_long()\n   new_tarval_from_double()"]
    pub fn new_tarval_from_str(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        mode: *mut ir_mode,
    ) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Construct a new tarval from a given string.\n\n @param str      The string representing the target value\n @param len      The length of the string\n @param negative != 0 if number should be negative\n @param base     number system base.\n                 binary(2), octal(8), decimal(10) and hexadecimal(16) numbers\n                 are supported.\n @param mode     The mode requested for the result tarval\n\n @return\n   A tarval with the given mode. If overflow settings are set to\n   TV_OVERFLOW_BAD then a tarval_bad is returned if the number can't be\n   represented in the given mode.\n   Returns bad if the number couldn't successfully be parsed."]
    pub fn new_integer_tarval_from_str(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        negative: ::std::os::raw::c_int,
        base: ::std::os::raw::c_uchar,
        mode: *mut ir_mode,
    ) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Constructor function for new tarvals\n\n @param l     The long representing the value\n @param mode  The mode requested for the result tarval must be a\n              twos_complement mode.\n\n This function creates a new tarval representing the value represented\n by a long integer. If a tarval representing this value already exists,\n this tarval is returned instead of a new one. So tarvals are directly\n comparable since their representation is unique.\n\n @return\n   A tarval of proper type representing the requested value is returned.\n   Tarvals are unique, so for any value/mode pair at most one tarval will\n   exist, which will be returned upon further requests with an identical\n   value/mode pair.\n\n @note\n   If the long is not representable in the given mode an assertion is\n   thrown in assert build.\n\n @sa\n   irmode.h for predefined modes\n   new_tarval_from_str()\n   new_tarval_from_double()\n"]
    pub fn new_tarval_from_long(l: ::std::os::raw::c_long, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Construct a new tarval from a sequence of bytes. The bytes are interpreted\n in a \"little endian\" fashion which means less significant bytes come first.\n\n @param buf  pointer to a buffer holding at least\n             get_ir_mode_size_bytes(mode) bytes.\n @param mode mode for the resulting tarval\n @return A newly created (or cached) tarval representing the value."]
    pub fn new_tarval_from_bytes(
        buf: *const ::std::os::raw::c_uchar,
        mode: *mut ir_mode,
    ) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Construct a new floating point quiet NaN value.\n @param mode       floating point mode for the resulting value\n @param signaling  if != 0 produces a signaling NaN else a quiet one.\n @param payload    if != NULL puts the integer tarval into the mantissa."]
    pub fn new_tarval_nan(
        mode: *mut ir_mode,
        signaling: ::std::os::raw::c_int,
        payload: *const ir_tarval,
    ) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Write tarval to a sequence of bytes. The value is written in a\n \"little endian\" fashion which means the less significant bytes come first."]
    pub fn tarval_to_bytes(buffer: *mut ::std::os::raw::c_uchar, tv: *const ir_tarval);
}
extern "C" {
    #[doc = " Returns value as long if possible."]
    pub fn get_tarval_long(tv: *const ir_tarval) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " This validates if get_tarval_long() will return something sensible.\n This is the case if the value is a two_complement (integer/reference) mode\n and converting it to a mode equivalent to \"long\" would not result in\n information loss. So ULONGMAX in an unsigned mode is fine, ULONG_MAX in a\n signed mode not.\n\n @param tv    the tarval"]
    pub fn tarval_is_long(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Constructor function for new tarvals.\n\n @param d     The (long) double representing the value\n @param mode  The mode requested for the result tarval\n\n This function creates a new tarval representing the value represented\n by a (long) double. If a tarval representing this value already exists,\n this tarval is returned instead of a new one. So tarvals are directly\n comparable since their representation is unique.\n Only modes of sort float_number can be constructed this way.\n\n @return\n   A tarval of proper type representing the requested value is returned.\n   Tarvals are unique, so for any value/mode pair at most one tarval will\n   exist, which will be returned upon further requests with an identical\n   value/mode pair.\n\n @note\n   If the (long) double is not representable in the given mode an assertion\n   is thrown. This will happen for any mode not of sort float_number.\n\n @sa\n   irmode.h for predefined values\n   new_tarval_from_str()\n   new_tarval_from_long()"]
    pub fn new_tarval_from_double(d: f64, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " same as new_tarval_from_double(), but with a long double argument"]
    pub fn new_tarval_from_long_double(d: u128, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " This returns a double with the value represented value, or\n gibberish, depending on the size of double and the size of the\n stored value.\n This will overflow silently, so use only if you know what\n you are doing! (better check with tarval_is_long...)\n\n @param tv    the tarval"]
    pub fn get_tarval_double(tv: *const ir_tarval) -> f64;
}
extern "C" {
    #[doc = " same as get_tarval_double but returns a long double value"]
    pub fn get_tarval_long_double(tv: *const ir_tarval) -> u128;
}
extern "C" {
    #[doc = " This validates if tarval_to_double() will return a satisfying\n result. I.e. if tv is an float_number and between min, max\n of double\n\n @param tv    the tarval"]
    pub fn tarval_is_double(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the mode of the tarval.\n\n @param tv    the tarval"]
    pub fn get_tarval_mode(tv: *const ir_tarval) -> *mut ir_mode;
}
extern "C" {
    #[doc = " Returns 1 if tv is negative\n\n @param tv    the tarval"]
    pub fn tarval_is_negative(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if tv is null\n\n @param tv    the tarval"]
    pub fn tarval_is_null(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns 1 if tv is the \"one\"\n\n @param tv    the tarval"]
    pub fn tarval_is_one(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns non-zero if all bits in the tarval are set.\n This means the value is -1 for signed modes with irma_twos_complement."]
    pub fn tarval_is_all_one(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the tarval is a constant (i.e. NOT\n a reserved tarval like bad, undef, reachable etc.)"]
    pub fn tarval_is_constant(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The 'bad' tarval. Representing \"no value\", do not confuse this with\n tarval_unknown."]
    pub static tarval_bad: *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the 'bad' tarval."]
    pub fn get_tarval_bad() -> *mut ir_tarval;
}
extern "C" {
    #[doc = " The 'unknown' tarval. Representing an unknown (but legal) value, do\n not confuse this with tarval_bad."]
    pub static tarval_unknown: *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the 'unknown' tarval."]
    pub fn get_tarval_unknown() -> *mut ir_tarval;
}
extern "C" {
    #[doc = " The mode_b tarval 'false'."]
    pub static mut tarval_b_false: *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the mode_b tarval 'false'."]
    pub fn get_tarval_b_false() -> *mut ir_tarval;
}
extern "C" {
    #[doc = " The mode_b tarval 'true'."]
    pub static mut tarval_b_true: *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the mode_b tarval 'true'."]
    pub fn get_tarval_b_true() -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Sets whether values should wrap on overflow or return the bad value."]
    pub fn tarval_set_wrap_on_overflow(wrap_on_overflow: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns 0 if operations return bad on overflow, != 0 if they wrap around."]
    pub fn tarval_get_wrap_on_overflow() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two tarvals\n\n Compare a with b and return their relation.\n This is either ir_rel_unordered, ir_rel_less, ir_rel_greater, ir_rel_equal\n or ir_rel_false if a or b are symbolic pointers which can not be compared at\n all.\n\n @param a   the first tarval to be compared\n @param b   the second tarval to be compared"]
    pub fn tarval_cmp(a: *const ir_tarval, b: *const ir_tarval) -> ir_relation;
}
extern "C" {
    #[doc = " Converts a tarval to another mode.\n\n Convert tarval 'src' to mode 'mode', this will succeed if and only if mode\n 'mode' is wider than the mode of src, as defined in the firm documentation\n and as returned by the function mode_is_smaller defined in irmode.h.\n\n @param src    The tarval to convert\n @param mode   Tho mode to convert to\n\n @return\n   If a tarval of mode 'mode' with the result of the conversion of the 'src'\n   tarvals value already exists, it will be returned, else a new tarval is\n   constructed and returned\n\n @note\n    Illegal conversions will trigger a panic\n\n @sa\n    FIRM documentation for conversion rules\n    mode_is_smaller defined in irmode.h"]
    pub fn tarval_convert_to(src: *const ir_tarval, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Converts a tarval to another mode by reinterpreting the contained\n bits. This is only allowed if the source and destination mode have the\n same number of bits."]
    pub fn tarval_bitcast(src: *const ir_tarval, mode: *mut ir_mode) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Bitwise Negation of a tarval.\n\n @param a  the first tarval\n\n @return ~a or tarval_bad"]
    pub fn tarval_not(a: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Arithmetic Negation of a tarval.\n\n @param a  the first tarval\n\n @return -a or tarval_bad"]
    pub fn tarval_neg(a: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Addition of two tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a + b or tarval_bad"]
    pub fn tarval_add(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Subtraction from a tarval.\n\n @param a         the first tarval\n @param b         the second tarval\n\n @return a - b or tarval_bad"]
    pub fn tarval_sub(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Multiplication of tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a * b or tarval_bad"]
    pub fn tarval_mul(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Integer division of two tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a / b or tarval_bad"]
    pub fn tarval_div(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Remainder of integer division.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a % b or tarval_bad"]
    pub fn tarval_mod(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Integer division AND remainder.\n\n @param a        the first tarval\n @param b        the second tarval\n @param mod_res  after return, contains the remainder result, a % b or tarval_bad\n\n @return a / b or tarval_bad"]
    pub fn tarval_divmod(
        a: *const ir_tarval,
        b: *const ir_tarval,
        mod_res: *mut *mut ir_tarval,
    ) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Absolute value of a tarval.\n\n @param a  the first tarval\n\n @return |a| or tarval_bad"]
    pub fn tarval_abs(a: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Bitwise and of two integer tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a & b or tarval_bad"]
    pub fn tarval_and(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Bitwise and not of two integer tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a & ~b or tarval_bad"]
    pub fn tarval_andnot(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Bitwise or of two integer tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a | b or tarval_bad"]
    pub fn tarval_or(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Bitwise or not of two integer tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a | ~b or tarval_bad"]
    pub fn tarval_ornot(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Bitwise exclusive or of two integer tarvals.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a ^ b or tarval_bad"]
    pub fn tarval_eor(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Logical Left shift.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a << b or tarval_bad"]
    pub fn tarval_shl(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " logical left shift (variant with unsigned argument).\n @see tarval_shl()"]
    pub fn tarval_shl_unsigned(a: *const ir_tarval, b: ::std::os::raw::c_uint) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Unsigned (logical) right shift.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a >>u b or tarval_bad"]
    pub fn tarval_shr(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " unsigned (logical) right shift (variant with unsigned argument).\n @see tarval_shr()"]
    pub fn tarval_shr_unsigned(a: *const ir_tarval, b: ::std::os::raw::c_uint) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Signed (arithmetic) right shift.\n\n @param a  the first tarval\n @param b  the second tarval\n\n @return a >>s b or tarval_bad"]
    pub fn tarval_shrs(a: *const ir_tarval, b: *const ir_tarval) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " signed (arithmetic) right shift (variant with unsigned argument).\n @see tarval_shrs()"]
    pub fn tarval_shrs_unsigned(a: *const ir_tarval, b: ::std::os::raw::c_uint) -> *mut ir_tarval;
}
extern "C" {
    #[doc = " Returns the bitpattern of the bytes_ofs byte.\n\n This function succeeds even if the mode of the tarval uses fewer bits\n than requested, in that case the bitpattern is filled with zero bits.\n\n To query a 32bit value the following code can be used:\n\n val0 = tarval_sub_bits(tv, 0);  <- lowest bits\n val1 = tarval_sub_bits(tv, 1);\n val2 = tarval_sub_bits(tv, 2);\n val3 = tarval_sub_bits(tv, 3);  <- highest bits\n\n Because this is the bit representation of the target machine, only the\n following operations are legal on the result:\n\n - concatenation (endian dependence MUST be handled by the CALLER)\n - bitwise logical operations to select/mask bits\n\n @param tv        the tarval\n @param byte_ofs  the byte offset from lower to higher\n\n @note\n   The result of this function is undefined if the mode is neither integer\n   nor float."]
    pub fn get_tarval_sub_bits(
        tv: *const ir_tarval,
        byte_ofs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Returns the number of set bits in a given (integer) tarval.\n\n @param tv    the tarval\n\n @return number of set bits or -1 on error"]
    pub fn get_tarval_popcount(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of the lowest set bit in a given (integer) tarval.\n\n @param tv    the tarval\n\n @return number of lowest set bit or -1 on error"]
    pub fn get_tarval_lowest_bit(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of the highest set bit in a given (integer) tarval.\n\n @param tv    the tarval\n\n @return number of highest set bit or -1 on error"]
    pub fn get_tarval_highest_bit(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the mantissa of a floating point tarval is zero\n (i.e. 1.0Exxx)\n\n @param tv    the tarval"]
    pub fn tarval_zero_mantissa(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the exponent of a floating point IEEE-754\n tarval.\n\n @param tv    the tarval"]
    pub fn tarval_get_exponent(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the tarval can be converted to the given mode without\n precision loss.\n\n @param tv    the tarval\n @param mode  the mode to convert to"]
    pub fn tarval_ieee754_can_conv_lossless(
        tv: *const ir_tarval,
        mode: *const ir_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns non-zero if the result of the last IEEE-754 operation was exact."]
    pub fn tarval_ieee754_get_exact() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check if @p tv is a floating point NaN.\n\n @param tv    the tarval"]
    pub fn tarval_is_nan(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if @p tv is a floating point quiet NaN.\n\n @param tv    the tarval"]
    pub fn tarval_is_quiet_nan(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if @p tv is a floating point signaling NaN.\n\n @param tv    the tarval"]
    pub fn tarval_is_signaling_nan(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the tarval represents a finite value, ie neither NaN nor inf.\n\n @param tv    the tarval"]
    pub fn tarval_is_finite(tv: *const ir_tarval) -> ::std::os::raw::c_int;
}
#[doc = "< No information could be derived so far"]
pub const range_types_VRP_UNDEFINED: range_types = 0;
#[doc = "< bottom and top form a range, including both values"]
pub const range_types_VRP_RANGE: range_types = 1;
#[doc = "< range from bottom to top cannot be, but borders might\nbe"]
pub const range_types_VRP_ANTIRANGE: range_types = 2;
#[doc = "< information cannot be derived"]
pub const range_types_VRP_VARYING: range_types = 3;
#[doc = " Type of a value range"]
pub type range_types = ::std::os::raw::c_uint;
#[doc = " VRP information for a single node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrp_attr {
    #[doc = "< The bits which, by analysis, are\ndefinitely set:\n0: may be not set, 1: definitely set"]
    pub bits_set: *mut ir_tarval,
    #[doc = "< The bits which by analysis are definitely\nnot set:\n1 for may be set, 0: definitely not set"]
    pub bits_not_set: *mut ir_tarval,
    #[doc = "< The range represented by range_top, range_bottom"]
    pub range_type: range_types,
    #[doc = "< lower end of the value range"]
    pub range_bottom: *mut ir_tarval,
    #[doc = "< upper end of the value range"]
    pub range_top: *mut ir_tarval,
}
#[test]
fn bindgen_test_layout_vrp_attr() {
    const UNINIT: ::std::mem::MaybeUninit<vrp_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrp_attr>(),
        40usize,
        concat!("Size of: ", stringify!(vrp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<vrp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(vrp_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(bits_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_not_set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(bits_not_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(range_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_bottom) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(range_bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_top) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrp_attr),
            "::",
            stringify!(range_top)
        )
    );
}
extern "C" {
    #[doc = " Sets vrp data on the graph irg\n @param irg graph on which to set vrp data"]
    pub fn set_vrp_data(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " free vrp infos in an irg"]
    pub fn free_vrp_data(irg: *mut ir_graph);
}
extern "C" {
    #[doc = " Test, if the two nodes can be compared with their vrp information\n\n @param left: the left node\n @param right: the right node\n @return all possible relations"]
    pub fn vrp_cmp(left: *const ir_node, right: *const ir_node) -> ir_relation;
}
extern "C" {
    #[doc = " Returns the vrp data for this node\n Note: only allowed for nodes with an integer mode!\n\n @param n: the node for which to return the vrp information\n @return a pointer to the vrp data or NULL if there is none"]
    pub fn vrp_get_info(n: *const ir_node) -> *mut vrp_attr;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
